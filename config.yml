# [TODO: Write full specifications for this file (#649)]
#
# "location: default" is for the case when location
# will be filled out by the consumer, and sets the location
# to the parser's start and end location in the interim

tokens:
  - name: EOF
    value: 0
    comment: final token in the file
  - name: MISSING
    comment: "a token that was expected but not found"
  - name: NOT_PROVIDED
    comment: "a token that was not present but it is okay"
  - name: AMPERSAND
    comment: "&"
  - name: AMPERSAND_AMPERSAND
    comment: "&&"
  - name: AMPERSAND_AMPERSAND_EQUAL
    comment: "&&="
  - name: AMPERSAND_DOT
    comment: "&."
  - name: AMPERSAND_EQUAL
    comment: "&="
  - name: BACKTICK
    comment: "`"
  - name: BACK_REFERENCE
    comment: "a back reference"
  - name: BANG
    comment: "! or !@"
  - name: BANG_EQUAL
    comment: "!="
  - name: BANG_TILDE
    comment: "!~"
  - name: BRACE_LEFT
    comment: "{"
  - name: BRACE_RIGHT
    comment: "}"
  - name: BRACKET_LEFT
    comment: "["
  - name: BRACKET_LEFT_ARRAY
    comment: "[ for the beginning of an array"
  - name: BRACKET_LEFT_RIGHT
    comment: "[]"
  - name: BRACKET_LEFT_RIGHT_EQUAL
    comment: "[]="
  - name: BRACKET_RIGHT
    comment: "]"
  - name: CARET
    comment: "^"
  - name: CARET_EQUAL
    comment: "^="
  - name: CHARACTER_LITERAL
    comment: "a character literal"
  - name: CLASS_VARIABLE
    comment: "a class variable"
  - name: COLON
    comment: ":"
  - name: COLON_COLON
    comment: "::"
  - name: COMMA
    comment: ","
  - name: COMMENT
    comment: "a comment"
  - name: CONSTANT
    comment: "a constant"
  - name: DOT
    comment: "."
  - name: DOT_DOT
    comment: ".."
  - name: DOT_DOT_DOT
    comment: "..."
  - name: EMBDOC_BEGIN
    comment: "=begin"
  - name: EMBDOC_END
    comment: "=end"
  - name: EMBDOC_LINE
    comment: "a line inside of embedded documentation"
  - name: EMBEXPR_BEGIN
    comment: "#{"
  - name: EMBEXPR_END
    comment: "}"
  - name: EMBVAR
    comment: "#"
  - name: EQUAL
    comment: "="
  - name: EQUAL_EQUAL
    comment: "=="
  - name: EQUAL_EQUAL_EQUAL
    comment: "==="
  - name: EQUAL_GREATER
    comment: "=>"
  - name: EQUAL_TILDE
    comment: "=~"
  - name: FLOAT
    comment: "a floating point number"
  - name: GLOBAL_VARIABLE
    comment: "a global variable"
  - name: GREATER
    comment: ">"
  - name: GREATER_EQUAL
    comment: ">="
  - name: GREATER_GREATER
    comment: ">>"
  - name: GREATER_GREATER_EQUAL
    comment: ">>="
  - name: HEREDOC_END
    comment: "the end of a heredoc"
  - name: HEREDOC_START
    comment: "the start of a heredoc"
  - name: IDENTIFIER
    comment: "an identifier"
  - name: IGNORED_NEWLINE
    comment: "an ignored newline"
  - name: IMAGINARY_NUMBER
    comment: "an imaginary number literal"
  - name: INSTANCE_VARIABLE
    comment: "an instance variable"
  - name: INTEGER
    comment: "an integer (any base)"
  - name: KEYWORD_ALIAS
    comment: "alias"
  - name: KEYWORD_AND
    comment: "and"
  - name: KEYWORD_BEGIN
    comment: "begin"
  - name: KEYWORD_BEGIN_UPCASE
    comment: "BEGIN"
  - name: KEYWORD_BREAK
    comment: "break"
  - name: KEYWORD_CASE
    comment: "case"
  - name: KEYWORD_CLASS
    comment: "class"
  - name: KEYWORD_DEF
    comment: "def"
  - name: KEYWORD_DEFINED
    comment: "defined?"
  - name: KEYWORD_DO
    comment: "do"
  - name: KEYWORD_DO_LOOP
    comment: "do keyword for a predicate in a while, until, or for loop"
  - name: KEYWORD_ELSE
    comment: "else"
  - name: KEYWORD_ELSIF
    comment: "elsif"
  - name: KEYWORD_END
    comment: "end"
  - name: KEYWORD_END_UPCASE
    comment: "END"
  - name: KEYWORD_ENSURE
    comment: "ensure"
  - name: KEYWORD_FALSE
    comment: "false"
  - name: KEYWORD_FOR
    comment: "for"
  - name: KEYWORD_IF
    comment: "if"
  - name: KEYWORD_IF_MODIFIER
    comment: "if in the modifier form"
  - name: KEYWORD_IN
    comment: "in"
  - name: KEYWORD_MODULE
    comment: "module"
  - name: KEYWORD_NEXT
    comment: "next"
  - name: KEYWORD_NIL
    comment: "nil"
  - name: KEYWORD_NOT
    comment: "not"
  - name: KEYWORD_OR
    comment: "or"
  - name: KEYWORD_REDO
    comment: "redo"
  - name: KEYWORD_RESCUE
    comment: "rescue"
  - name: KEYWORD_RESCUE_MODIFIER
    comment: "rescue in the modifier form"
  - name: KEYWORD_RETRY
    comment: "retry"
  - name: KEYWORD_RETURN
    comment: "return"
  - name: KEYWORD_SELF
    comment: "self"
  - name: KEYWORD_SUPER
    comment: "super"
  - name: KEYWORD_THEN
    comment: "then"
  - name: KEYWORD_TRUE
    comment: "true"
  - name: KEYWORD_UNDEF
    comment: "undef"
  - name: KEYWORD_UNLESS
    comment: "unless"
  - name: KEYWORD_UNLESS_MODIFIER
    comment: "unless in the modifier form"
  - name: KEYWORD_UNTIL
    comment: "until"
  - name: KEYWORD_UNTIL_MODIFIER
    comment: "until in the modifier form"
  - name: KEYWORD_WHEN
    comment: "when"
  - name: KEYWORD_WHILE
    comment: "while"
  - name: KEYWORD_WHILE_MODIFIER
    comment: "while in the modifier form"
  - name: KEYWORD_YIELD
    comment: "yield"
  - name: KEYWORD___ENCODING__
    comment: "__ENCODING__"
  - name: KEYWORD___FILE__
    comment: "__FILE__"
  - name: KEYWORD___LINE__
    comment: "__LINE__"
  - name: LABEL
    comment: "a label"
  - name: LABEL_END
    comment: "the end of a label"
  - name: LAMBDA_BEGIN
    comment: "{"
  - name: LESS
    comment: "<"
  - name: LESS_EQUAL
    comment: "<="
  - name: LESS_EQUAL_GREATER
    comment: "<=>"
  - name: LESS_LESS
    comment: "<<"
  - name: LESS_LESS_EQUAL
    comment: "<<="
  - name: MINUS
    comment: "-"
  - name: MINUS_EQUAL
    comment: "-="
  - name: MINUS_GREATER
    comment: "->"
  - name: NEWLINE
    comment: "a newline character outside of other tokens"
  - name: NTH_REFERENCE
    comment: "an nth global variable reference"
  - name: PARENTHESIS_LEFT
    comment: "("
  - name: PARENTHESIS_LEFT_PARENTHESES
    comment: "( for a parentheses node"
  - name: PARENTHESIS_RIGHT
    comment: ")"
  - name: PERCENT
    comment: "%"
  - name: PERCENT_EQUAL
    comment: "%="
  - name: PERCENT_LOWER_I
    comment: "%i"
  - name: PERCENT_LOWER_W
    comment: "%w"
  - name: PERCENT_LOWER_X
    comment: "%x"
  - name: PERCENT_UPPER_I
    comment: "%I"
  - name: PERCENT_UPPER_W
    comment: "%W"
  - name: PIPE
    comment: "|"
  - name: PIPE_EQUAL
    comment: "|="
  - name: PIPE_PIPE
    comment: "||"
  - name: PIPE_PIPE_EQUAL
    comment: "||="
  - name: PLUS
    comment: "+"
  - name: PLUS_EQUAL
    comment: "+="
  - name: QUESTION_MARK
    comment: "?"
  - name: RATIONAL_NUMBER
    comment: "a rational number literal"
  - name: REGEXP_BEGIN
    comment: "the beginning of a regular expression"
  - name: REGEXP_END
    comment: "the end of a regular expression"
  - name: SEMICOLON
    comment: ";"
  - name: SLASH
    comment: "/"
  - name: SLASH_EQUAL
    comment: "/="
  - name: STAR
    comment: "*"
  - name: STAR_EQUAL
    comment: "*="
  - name: STAR_STAR
    comment: "**"
  - name: STAR_STAR_EQUAL
    comment: "**="
  - name: STRING_BEGIN
    comment: "the beginning of a string"
  - name: STRING_CONTENT
    comment: "the contents of a string"
  - name: STRING_END
    comment: "the end of a string"
  - name: SYMBOL_BEGIN
    comment: "the beginning of a symbol"
  - name: TILDE
    comment: "~ or ~@"
  - name: UCOLON_COLON
    comment: "unary ::"
  - name: UDOT_DOT
    comment: "unary .."
  - name: UDOT_DOT_DOT
    comment: "unary ..."
  - name: UMINUS
    comment: "-@"
  - name: UPLUS
    comment: "+@"
  - name: USTAR
    comment: "unary *"
  - name: WORDS_SEP
    comment: "a separator between words in a list"
  - name: __END__
    comment: "marker for the point in the file at which the parser should stop"
nodes:
  - name: AliasNode
    child_nodes:
      - name: new_name
        type: node
      - name: old_name
        type: node
      - name: keyword_loc
        type: location
    comment: |
      Represents the use of the `alias` keyword.

          alias foo bar
          ^^^^^^^^^^^^^
  - name: AndNode
    child_nodes:
      - name: left
        type: node
      - name: right
        type: node
      - name: operator
        type: token
    comment: |
      Represents the use of the `&&` operator or the `and` keyword.

          left and right
          ^^^^^^^^^^^^^^
  - name: ArgumentsNode
    child_nodes:
      - name: arguments
        type: node[]
    location: default
    comment: |
      Represents a set of arguments to a method or a keyword.

          return foo, bar, baz
                 ^^^^^^^^^^^^^
  - name: ArrayNode
    child_nodes:
      - name: elements
        type: node[]
      - name: opening
        type: token?
      - name: closing
        type: token?
    comment: |
      Represents an array literal. This can be a regular array using brackets or
      a special array using % like %w or %i.

          [1, 2, 3]
          ^^^^^^^^^
  - name: AssocNode
    child_nodes:
      - name: key
        type: node
      - name: value
        type: node?
      - name: operator
        type: token?
    comment: |
      Represents a hash key/value pair.

          { a => b }
            ^^^^^^
  - name: AssocSplatNode
    child_nodes:
      - name: value
        type: node
      - name: operator_loc
        type: location
    comment: |
      Represents a splat in a hash literal.

          { **foo }
            ^^^^^
  - name: BeginNode
    child_nodes:
      - name: begin_keyword
        type: token?
      - name: statements
        type: node
      - name: rescue_clause
        type: node?
      - name: else_clause
        type: node?
      - name: ensure_clause
        type: node?
      - name: end_keyword
        type: token?
    comment: |
      Represents a begin statement.

          begin
            foo
          end
          ^^^^^
  - name: BlockArgumentNode
    child_nodes:
      - name: expression
        type: node
      - name: operator_loc
        type: location
    comment: |
      Represents block method arguments.

          bar(&args)
          ^^^^^^^^^^
  - name: BlockNode
    child_nodes:
      - name: scope
        type: node
      - name: parameters
        type: node?
      - name: statements
        type: node?
      - name: opening_loc
        type: location
      - name: closing_loc
        type: location
    comment: |
      Represents a block of ruby code.

      [1, 2, 3].each { |i| puts x }
                     ^^^^^^^^^^^^^^
  - name: BlockParameterNode
    child_nodes:
      - name: name
        type: token?
      - name: operator_loc
        type: location
    comment: |
      Represents a block parameter to a method, block, or lambda definition.

          def a(&b)
                ^^
          end
  - name: BlockParametersNode
    child_nodes:
      - name: parameters
        type: node
      - name: locals
        type: token[]
    comment: |
      Represents a block variable declaration.

          -> (a, b = 1; local) { }
              ^^^^^^^^^^^^^^^
  - name: BreakNode
    child_nodes:
      - name: arguments
        type: node?
      - name: keyword_loc
        type: location
    comment: |
      Represents the use of the `break` keyword.

          break foo
          ^^^^^^^^^
  - name: CallNode
    child_nodes:
      - name: receiver
        type: node?
      - name: call_operator
        type: token?
      - name: message
        type: token?
      - name: opening
        type: token?
      - name: arguments
        type: node?
      - name: closing
        type: token?
      - name: block
        type: node?
      - name: name
        type: string
    comment: |
      Represents a method call, in all of the various forms that that can take.

          foo
          ^^^

          +foo
          ^^^^

          foo + bar
          ^^^^^^^^^

          foo.bar
          ^^^^^^^
  - name: CaseNode
    child_nodes:
      - name: predicate
        type: node?
      - name: conditions
        type: node[]
      - name: consequent
        type: node?
      - name: case_keyword_loc
        type: location
      - name: end_keyword_loc
        type: location
    comment: |
      Represents the use of a case statement.

      case true
      ^^^^^^^^^
      when false
      end
  - name: ClassNode
    child_nodes:
      - name: scope
        type: node
      - name: class_keyword
        type: token
      - name: constant_path
        type: node
      - name: inheritance_operator
        type: token?
      - name: superclass
        type: node?
      - name: statements
        type: node
      - name: end_keyword
        type: token
    location: class_keyword->end_keyword
    comment: |
      Represents a class declaration involving the `class` keyword.

          class Foo end
          ^^^^^^^^^^^^^
  - name: ClassVariableReadNode
    comment: |
      Represents referencing a class variable.

          @@foo
          ^^^^^
  - name: ClassVariableWriteNode
    child_nodes:
      - name: name_loc
        type: location
      - name: value
        type: node?
      - name: operator_loc
        type: location?
    comment: |
      Represents writing to a class variable.

          @@foo = 1
          ^^^^^^^^^
  - name: ConstantPathNode
    child_nodes:
      - name: parent
        type: node?
      - name: delimiter
        type: token
      - name: child
        type: node
    location: parent|delimiter->child
    comment: |
      Represents accessing a constant through a path of `::` operators.

          Foo::Bar
          ^^^^^^^^
  - name: ConstantPathWriteNode
    child_nodes:
      - name: target
        type: node
      - name: operator
        type: token?
      - name: value
        type: node?
    location: target->value|target
    comment: |
      Represents writing to a constant.

          Foo = 1
          ^^^^^^^

          Foo::Bar = 1
          ^^^^^^^^^^^^
  - name: ConstantReadNode
    comment: |
      Represents referencing a constant.

          Foo
          ^^^
  - name: DefNode
    child_nodes:
      - name: name
        type: token
      - name: receiver
        type: node?
      - name: parameters
        type: node?
      - name: statements
        type: node
      - name: scope
        type: node
      - name: def_keyword_loc
        type: location
      - name: operator_loc
        type: location?
      - name: lparen_loc
        type: location?
      - name: rparen_loc
        type: location?
      - name: equal_loc
        type: location?
      - name: end_keyword_loc
        type: location?
    comment: |
      Represents a method definition.

          def method
          end
          ^^^^^^^^^^
  - name: DefinedNode
    child_nodes:
      - name: lparen
        type: token?
      - name: value
        type: node
      - name: rparen
        type: token?
      - name: keyword_loc
        type: location
    location: keyword_loc->rparen|value
    comment: |
      Represents the use of the `defined?` keyword.

          defined?(a)
          ^^^^^^^^^^^
  - name: ElseNode
    child_nodes:
      - name: else_keyword
        type: token
      - name: statements
        type: node?
      - name: end_keyword
        type: token
    location: else_keyword->end_keyword
    comment: |
      Represents an `else` clause in a `case`, `if`, or `unless` statement.

          if a then b else c end
                      ^^^^^^^^^^
  - name: EnsureNode
    child_nodes:
      - name: ensure_keyword
        type: token
      - name: statements
        type: node
      - name: end_keyword
        type: token
    location: ensure_keyword->end_keyword
    comment: |
      Represents an `ensure` clause in a `begin` statement.

          begin
            foo
          ensure
          ^^^^^^
            bar
          end
  - name: FalseNode
    comment: |
      Represents the use of the literal `false` keyword.

          false
          ^^^^^
  - name: FloatNode
    comment: |
      Represents a floating point number literal.

          1.0
          ^^^
  - name: ForNode
    child_nodes:
      - name: index
        type: node
      - name: collection
        type: node
      - name: statements
        type: node
      - name: for_keyword_loc
        type: location
      - name: in_keyword_loc
        type: location
      - name: do_keyword_loc
        type: location?
      - name: end_keyword_loc
        type: location
    comment: |
      Represents the use of the `for` keyword.

          for i in a end
          ^^^^^^^^^^^^^^
  - name: ForwardingArgumentsNode
    comment: |
      Represents forwarding all arguments to this method to another method.

          def foo(...)
            bar(...)
            ^^^^^^^^
          end
  - name: ForwardingParameterNode
    comment: |
      Represents the use of the forwarding parameter in a method, block, or lambda declaration.

          def foo(...)
                  ^^^
          end
  - name: ForwardingSuperNode
    child_nodes:
      - name: block
        type: node?
    comment: |
      Represents the use of the `super` keyword without parentheses or arguments.

          super
          ^^^^^
  - name: GlobalVariableReadNode
    child_nodes:
      - name: name
        type: token
    location: name
    comment: |
      Represents referencing a global variable.

          $foo
          ^^^^
  - name: GlobalVariableWriteNode
    child_nodes:
      - name: name
        type: token
      - name: operator
        type: token?
      - name: value
        type: node?
    location: name->value|name
    comment: |
      Represents writing to a global variable.

          $foo = 1
          ^^^^^^^^
  - name: HashNode
    child_nodes:
      - name: opening
        type: token?
      - name: elements
        type: node[]
      - name: closing
        type: token?
    location: opening|elements->closing|elements
    comment: |
      Represents a hash literal.

          { a => b }
          ^^^^^^^^^^
  - name: HeredocNode
    child_nodes:
      - name: opening
        type: token
      - name: parts
        type: node[]
      - name: closing
        type: token
      - name: dedent
        type: integer
    location: opening->closing
    comment: |
      Represents the use of a heredoc.

          <<~HERE
            Content.
          HERE
          ^^^^^^^^^^
  - name: IfNode
    child_nodes:
      - name: if_keyword
        type: token
      - name: predicate
        type: node
      - name: statements
        type: node
      - name: consequent
        type: node?
      - name: end_keyword
        type: token?
    location: if_keyword->end_keyword|consequent|statements
    comment: |
      Represents the use of the `if` keyword, either in the block form or the modifier form.

          bar if foo
          ^^^^^^^^^^

          if foo then bar end
          ^^^^^^^^^^^^^^^^^^^
  - name: ImaginaryNode
    comment: |
      Represents an imaginary number literal.

          1.0i
          ^^^^
  - name: InNode
    child_nodes:
      - name: pattern
        type: node
      - name: statements
        type: node?
      - name: in_loc
        type: location
      - name: then_loc
        type: location?
    comment: |
      Represents the use of the `in` keyword in a case statement.

          case a; in b then c end
                  ^^^^^^^^^^^
  - name: InstanceVariableReadNode
    comment: |
      Represents referencing an instance variable.

          @foo
          ^^^^
  - name: InstanceVariableWriteNode
    child_nodes:
      - name: name_loc
        type: location
      - name: value
        type: node?
      - name: operator_loc
        type: location?
    comment: |
      Represents writing to an instance variable.

          @foo = 1
          ^^^^^^^^
  - name: IntegerNode
    comment: |
      Represents an integer number literal.

          1
          ^
  - name: InterpolatedRegularExpressionNode
    child_nodes:
      - name: opening
        type: token
      - name: parts
        type: node[]
      - name: closing
        type: token
    location: opening->closing
    comment: |
      Represents a regular expression literal that contains interpolation.

          /foo #{bar} baz/
          ^^^^^^^^^^^^^^^^
  - name: InterpolatedStringNode
    child_nodes:
      - name: opening
        type: token?
      - name: parts
        type: node[]
      - name: closing
        type: token?
    location: opening|parts->closing|parts
    comment: |
      Represents a string literal that contains interpolation.

          "foo #{bar} baz"
          ^^^^^^^^^^^^^^^^
  - name: InterpolatedSymbolNode
    child_nodes:
      - name: opening
        type: token?
      - name: parts
        type: node[]
      - name: closing
        type: token?
    location: opening|parts->closing|parts
    comment: |
      Represents a symbol literal that contains interpolation.

          :"foo #{bar} baz"
          ^^^^^^^^^^^^^^^^^
  - name: InterpolatedXStringNode
    child_nodes:
      - name: opening
        type: token
      - name: parts
        type: node[]
      - name: closing
        type: token
    location: opening->closing
    comment: |
      Represents an xstring literal that contains interpolation.

          `foo #{bar} baz`
          ^^^^^^^^^^^^^^^^
  - name: KeywordParameterNode
    child_nodes:
      - name: name
        type: token
      - name: value
        type: node?
    location: name
    comment: |
      Represents a keyword parameter to a method, block, or lambda definition.

          def a(b:)
                ^^
          end

          def a(b: 1)
                ^^^^
          end
  - name: KeywordRestParameterNode
    child_nodes:
      - name: operator
        type: token
      - name: name
        type: token?
    location: operator->name|operator
    comment: |
      Represents a keyword rest parameter to a method, block, or lambda definition.

          def a(**b)
                ^^^
          end
  - name: KeywordStarNode
    child_nodes:
      - name: operator
        type: token
      - name: expression
        type: node
    location: operator->expression
    comment: |
      Represents keyword splat method arguments.

          bar(**kwargs)
          ^^^^^^^^^^^
  - name: LambdaNode
    child_nodes:
      - name: scope
        type: node
      - name: opening
        type: token
      - name: lparen
        type: token?
      - name: parameters
        type: node?
      - name: rparen
        type: token?
      - name: statements
        type: node
    location: opening->statements
    comment: |
      Represents using a lambda literal (not the lambda method call).

          ->(value) { value * 2 }
          ^^^^^^^^^^^^^^^^^^^^^^^
  - name: LocalVariableReadNode
    child_nodes:
      - name: name
        type: token
    location: name
    comment: |
      Represents reading a local variable. Note that this requires that a local
      variable of the same name has already been written to in the same scope,
      otherwise it is parsed as a method call.

          foo
          ^^^
  - name: LocalVariableWriteNode
    child_nodes:
      - name: name
        type: token
      - name: operator
        type: token?
      - name: value
        type: node?
    location: name->value|name
    comment: |
      Represents writing to a local variable.

          foo = 1
          ^^^^^^^
  - name: MatchPredicateNode
    child_nodes:
      - name: value
        type: node
      - name: pattern
        type: node
      - name: operator_loc
        type: location
    comment: |
      Represents the use of the modifier `in` operator.

          foo in bar
          ^^^^^^^^^^
  - name: MatchRequiredNode
    child_nodes:
      - name: value
        type: node
      - name: pattern
        type: node
      - name: operator_loc
        type: location
    comment: |
      Represents the use of the `=>` operator.

          foo => bar
          ^^^^^^^^^^
  - name: MissingNode
    comment: |
      Represents a node that is missing from the source and results in a syntax
      error.
  - name: ModuleNode
    child_nodes:
      - name: scope
        type: node
      - name: module_keyword
        type: token
      - name: constant_path
        type: node
      - name: statements
        type: node
      - name: end_keyword
        type: token
    location: module_keyword->end_keyword
    comment: |
      Represents a module declaration involving the `module` keyword.

          module Foo end
          ^^^^^^^^^^^^^^
  - name: MultiWriteNode
    child_nodes:
      - name: targets
        type: node[]
      - name: operator
        type: token?
      - name: value
        type: node?
      - name: lparen_loc
        type: location?
      - name: rparen_loc
        type: location?
    location: targets
    comment: |
      Represents a multi-target expression.

          a, b, c = 1, 2, 3
          ^^^^^^^^^^^^^^^^^
  - name: NextNode
    child_nodes:
      - name: arguments
        type: node?
      - name: keyword_loc
        type: location
    comment: |
      Represents the use of the `next` keyword.

          next 1
          ^^^^^^
  - name: NilNode
    comment: |
      Represents the use of the `nil` keyword.

          nil
          ^^^
  - name: NoKeywordsParameterNode
    child_nodes:
      - name: operator_loc
        type: location
      - name: keyword_loc
        type: location
    comment: |
      Represents the use of `**nil` inside method arguments.

          def a(**nil)
                ^^^^^
          end
  - name: OperatorAndAssignmentNode
    child_nodes:
      - name: target
        type: node
      - name: value
        type: node
      - name: operator_loc
        type: location
    comment: |
      Represents the use of the `&&=` operator for assignment.

          target &&= value
          ^^^^^^^^^^^^^^^^
  - name: OperatorAssignmentNode
    child_nodes:
      - name: target
        type: node
      - name: operator
        type: token
      - name: value
        type: node
    location: target->value
    comment: |
      Represents assigning to a value using an operator that isn't `=`.

          foo += bar
          ^^^^^^^^^^
  - name: OperatorOrAssignmentNode
    child_nodes:
      - name: target
        type: node
      - name: value
        type: node
      - name: operator_loc
        type: location
    comment: |
      Represents the use of the `||=` operator for assignment.

          target ||= value
          ^^^^^^^^^^^^^^^^
  - name: OptionalParameterNode
    child_nodes:
      - name: name
        type: token
      - name: equal_operator
        type: token
      - name: value
        type: node
    location: name->value
    comment: |
      Represents an optional parameter to a method, block, or lambda definition.

          def a(b = 1)
                ^^^^^
          end
  - name: OrNode
    child_nodes:
      - name: left
        type: node
      - name: right
        type: node
      - name: operator_loc
        type: location
    comment: |
      Represents the use of the `||` operator or the `or` keyword.

          left or right
          ^^^^^^^^^^^^^
  - name: ParametersNode
    child_nodes:
      - name: requireds
        type: node[]
      - name: optionals
        type: node[]
      - name: rest
        type: node?
      - name: keywords
        type: node[]
      - name: keyword_rest
        type: node?
      - name: block
        type: node?
    comment: |
      Represents the list of parameters on a method, block, or lambda definition.

          def a(b, c, d)
                ^^^^^^^
          end
  - name: ParenthesesNode
    child_nodes:
      - name: statements
        type: node?
      - name: opening_loc
        type: location
      - name: closing_loc
        type: location
    comment: |
      Represents a parentesized expression

          (10 + 34)
          ^^^^^^^^^
  - name: PinnedVariableNode
    child_nodes:
      - name: variable
        type: node
      - name: operator_loc
        type: location
    comment: |
      Represents the use of the `^` operator for pinning a variable in a pattern
      matching expression.

          case foo in ^bar
                      ^^^^
  - name: PostExecutionNode
    child_nodes:
      - name: statements
        type: node
      - name: keyword_loc
        type: location
      - name: opening_loc
        type: location
      - name: closing_loc
        type: location
    comment: |
      Represents the use of the `END` keyword.

          BEGIN { foo }
          ^^^^^^^^^^^^^
  - name: PreExecutionNode
    child_nodes:
      - name: statements
        type: node
      - name: keyword_loc
        type: location
      - name: opening_loc
        type: location
      - name: closing_loc
        type: location
    comment: |
      Represents the use of the `END` keyword.

          END { foo }
          ^^^^^^^^^^^
  - name: ProgramNode
    child_nodes:
      - name: scope
        type: node
      - name: statements
        type: node
    location: statements
    comment: The top level node of any parse tree.
  - name: RangeNode
    child_nodes:
      - name: left
        type: node?
      - name: right
        type: node?
      - name: operator_loc
        type: location
    comment: |
      Represents the use of the `..` or `...` operators.

          1..2
          ^^^^

          c if a =~ /left/ ... b =~ /right/
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  - name: RationalNode
    comment: |
      Represents a rational number literal.

          1.0r
          ^^^^
  - name: RedoNode
    comment: |
      Represents the use of the `redo` keyword.

          redo
          ^^^^
  - name: RegularExpressionNode
    child_nodes:
      - name: opening
        type: token
      - name: content
        type: token
      - name: closing
        type: token
      - name: unescaped
        type: string
    location: opening->closing
    comment: |
      Represents a regular expression literal with no interpolation.

          /foo/i
          ^^^^^^
  - name: RequiredDestructuredParameterNode
    child_nodes:
      - name: parameters
        type: node[]
      - name: opening
        type: token
      - name: closing
        type: token
    location: parameters
    comment: |
      Represents a destructured required parameter node.

          def foo((bar, baz))
                  ^^^^^^^^^^
          end
  - name: RequiredParameterNode
    child_nodes:
      - name: name
        type: token
    location: name
    comment: |
      Represents a required parameter to a method, block, or lambda definition.

          def a(b)
                ^
          end
  - name: RescueModifierNode
    child_nodes:
      - name: expression
        type: node
      - name: rescue_keyword
        type: token
      - name: rescue_expression
        type: node
    location: expression->rescue_expression
    comment: |
      Represents an expression modified with a rescue.

        foo rescue nil
        ^^^^^^^^^^^^^^
  - name: RescueNode
    child_nodes:
      - name: rescue_keyword
        type: token
      - name: exceptions
        type: node[]
      - name: equal_greater
        type: token?
      - name: exception
        type: node?
      - name: statements
        type: node
      - name: consequent
        type: node?
    location: rescue_keyword->statements|consequent
    comment: |
      Represents a rescue statement.

          begin
          rescue
            foo
          ^^^^^^
          end
  - name: RestParameterNode
    child_nodes:
      - name: operator
        type: token
      - name: name
        type: token?
    location: operator->name|operator
    comment: |
      Represents a rest parameter to a method, block, or lambda definition.

          def a(*b)
                ^^
          end
  - name: RetryNode
    comment: |
      Represents the use of the `retry` keyword.

          retry
          ^^^^^
  - name: ReturnNode
    child_nodes:
      - name: keyword
        type: token
      - name: arguments
        type: node?
    location: keyword->arguments|keyword
    comment: |
      Represents the use of the `return` keyword.

          return 1
          ^^^^^^^^
  - name: Scope
    child_nodes:
      - name: locals
        type: token[]
    location: locals
    comment: |
      Represents the local variables within a given lexical scope. These are
      attached to nodes where a new scope is created.
  - name: SelfNode
    comment: |
      Represents the `self` keyword.

          self
          ^^^^
  - name: SingletonClassNode
    child_nodes:
      - name: scope
        type: node
      - name: class_keyword
        type: token
      - name: operator
        type: token
      - name: expression
        type: node
      - name: statements
        type: node
      - name: end_keyword
        type: token
    location: class_keyword->end_keyword
    comment: |
      Represents a singleton class declaration involving the `class` keyword.

          class << self end
          ^^^^^^^^^^^^^^^^^
  - name: SourceEncodingNode
    comment: |
      Represents the use of the `__ENCODING__` keyword.

          __ENCODING__
          ^^^^^^^^^^^^
  - name: SourceFileNode
    comment: |
      Represents the use of the `__FILE__` keyword.

          __FILE__
          ^^^^^^^^
  - name: SourceLineNode
    comment: |
      Represents the use of the `__LINE__` keyword.

          __LINE__
          ^^^^^^^^
  - name: SplatNode
    child_nodes:
      - name: operator
        type: token
      - name: expression
        type: node?
    location: operator->expression|operator
    comment: |
      Represents the use of the splat operator.

          [*a]
           ^^
  - name: StatementsNode
    child_nodes:
      - name: body
        type: node[]
    location: default
    comment: |
      Represents a set of statements contained within some scope.

          foo; bar; baz
          ^^^^^^^^^^^^^
  - name: StringConcatNode
    child_nodes:
      - name: left
        type: node
      - name: right
        type: node
    location: left->right
    comment: |
      Represents the use of compile-time string concatenation.

          "foo" "bar"
          ^^^^^^^^^^^
  - name: StringInterpolatedNode
    child_nodes:
      - name: opening
        type: token
      - name: statements
        type: node
      - name: closing
        type: token
    location: opening->closing
    comment: |
      Represents an interpolated set of statements within a string.

          "foo #{bar}"
               ^^^^^^
  - name: StringNode
    child_nodes:
      - name: opening
        type: token?
      - name: content
        type: token
      - name: closing
        type: token?
      - name: unescaped
        type: string
    location: opening|content->closing|content
    comment: |
      Represents a string literal, a string contained within a `%w` list, or
      plain string content within an interpolated string.

          "foo"
          ^^^^^

          %w[foo]
             ^^^

          "foo #{bar} baz"
           ^^^^      ^^^^
  - name: SuperNode
    child_nodes:
      - name: keyword
        type: token
      - name: lparen
        type: token?
      - name: arguments
        type: node?
      - name: rparen
        type: token?
      - name: block
        type: node?
    location: keyword->block|rparen|arguments|lparen|keyword
    comment: |
      Represents the use of the `super` keyword with parentheses or arguments.

          super()
          ^^^^^^^

          super foo, bar
          ^^^^^^^^^^^^^^
  - name: SymbolNode
    child_nodes:
      - name: opening
        type: token?
      - name: value
        type: token
      - name: closing
        type: token?
      - name: unescaped
        type: string
    location: opening|value->closing|value
    comment: |
      Represents a symbol literal or a symbol contained within a `%i` list.

          :foo
          ^^^^

          %i[foo]
             ^^^
  - name: TernaryNode
    child_nodes:
      - name: predicate
        type: node
      - name: question_mark
        type: token
      - name: true_expression
        type: node
      - name: colon
        type: token
      - name: false_expression
        type: node
    location: predicate->false_expression
    comment: |
      Represents the use of the ternary operators.

          foo ? bar : baz
          ^^^^^^^^^^^^^^^
  - name: TrueNode
    comment: |
      Represents the use of the literal `true` keyword.

          true
          ^^^^
  - name: UndefNode
    child_nodes:
      - name: names
        type: node[]
      - name: keyword_loc
        type: location
    comment: |
      Represents the use of the `undef` keyword.

          undef :foo, :bar, :baz
          ^^^^^^^^^^^^^^^^^^^^^^
  - name: UnlessNode
    child_nodes:
      - name: keyword
        type: token
      - name: predicate
        type: node
      - name: statements
        type: node
      - name: consequent
        type: node?
      - name: end_keyword
        type: token?
    location: keyword->statements
    comment: |
      Represents the use of the `unless` keyword, either in the block form or the modifier form.

          bar unless foo
          ^^^^^^^^^^^^^^

          unless foo then bar end
          ^^^^^^^^^^^^^^^^^^^^^^^
  - name: UntilNode
    child_nodes:
      - name: keyword
        type: token
      - name: predicate
        type: node
      - name: statements
        type: node
    location: keyword->statements
    comment: |
      Represents the use of the `until` keyword, either in the block form or the modifier form.

          bar until foo
          ^^^^^^^^^^^^^

          until foo do bar end
          ^^^^^^^^^^^^^^^^^^^^
  - name: WhenNode
    child_nodes:
      - name: when_keyword
        type: token
      - name: conditions
        type: node[]
      - name: statements
        type: node?
    location: when_keyword->statements|conditions
    comment: |
      case true
      when true
      ^^^^^^^^^
      end
  - name: WhileNode
    child_nodes:
      - name: keyword
        type: token
      - name: predicate
        type: node
      - name: statements
        type: node
    location: keyword->statements
    comment: |
      Represents the use of the `while` keyword, either in the block form or the modifier form.

          bar while foo
          ^^^^^^^^^^^^^

          while foo do bar end
          ^^^^^^^^^^^^^^^^^^^^
  - name: XStringNode
    child_nodes:
      - name: opening
        type: token
      - name: content
        type: token
      - name: closing
        type: token
      - name: unescaped
        type: string
    comment: |
      Represents an xstring literal with no interpolation.

          `foo`
          ^^^^^
  - name: YieldNode
    child_nodes:
      - name: keyword
        type: token
      - name: lparen
        type: token?
      - name: arguments
        type: node?
      - name: rparen
        type: token?
    location: keyword->rparen|arguments|lparen|keyword
    comment: |
      Represents the use of the `yield` keyword.

          yield 1
          ^^^^^^^
