/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually.                                                         */
/******************************************************************************/

#ifndef YARP_AST_H
#define YARP_AST_H

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

#include "yarp/util/yp_string.h"

// This enum represents every type of token in the Ruby source.
typedef enum yp_token_type {
<%- tokens.each do |token| -%>
  <%= token.declaration %>
<%- end -%>
  YP_TOKEN_MAXIMUM, // the maximum token value
} yp_token_type_t;

// This struct represents a token in the Ruby source. We use it to track both
// type and location information.
typedef struct {
  yp_token_type_t type;
  const char *start;
  const char *end;
} yp_token_t;

typedef struct {
  yp_token_t *tokens;
  size_t size;
  size_t capacity;
} yp_token_list_t;

struct yp_node;

typedef struct yp_node_list {
  struct yp_node **nodes;
  size_t size;
  size_t capacity;
} yp_node_list_t;

typedef enum {
<%- nodes.each_with_index do |node, index| -%>
  <%= node.type %> = <%= index %>,
<%- end -%>
} yp_node_type_t;

// This represents a range of bytes in the source string to which a node or
// token corresponds.
typedef struct {
  const char *start;
  const char *end;
} yp_location_t;

// This is the overall tagged union representing a node in the syntax tree.
typedef struct yp_node {
  // This represents the type of the node. It somewhat maps to the nodes that
  // existed in the original grammar and ripper, but it's not a 1:1 mapping.
  yp_node_type_t type;

  // This is the location of the node in the source. It's a range of bytes
  // containing a start and an end.
  yp_location_t location;

  // Every entry in this union is a different kind of node in the tree. For
  // the most part they only contain one or two child nodes, except for the
  // more complicated nodes like params. There may be an opportunity for
  // optimization here by combining node types that share the same shape, but
  // it might not end up mattering in the final compiled code.
  union {
  <%- nodes.each do |node| -%>
    // <%= node.name %>
    struct {
    <%- node.params.each do |param| -%>
      <%= case param
      in NodeParam | OptionalNodeParam then "struct yp_node *#{param.name}"
      in NodeListParam then "struct yp_node_list #{param.name}"
      in TokenParam | OptionalTokenParam then "yp_token_t #{param.name}"
      in TokenListParam then "yp_token_list_t #{param.name}"
      in StringParam then "yp_string_t #{param.name}"
      in LocationParam | OptionalLocationParam then "yp_location_t #{param.name}"
      in IntegerParam then "int #{param.name}"
      end
      %>;
    <%- end -%>
    } <%= node.human %>;
<%= "\n" if node != nodes.last -%>
  <%- end -%>
  } as;
} yp_node_t;

#endif // YARP_AST_H
