/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually.                                                         */
/******************************************************************************/

#include "extension.h"

extern VALUE rb_cYARP;
extern VALUE rb_cYARPNode;

<%- nodes.each do |node| -%>
static VALUE rb_cYARP<%= node.name %>;
<%- end -%>

static void
yp_node_data_mark(void *data) {
  yp_node_t *node = (yp_node_t *) data;

  switch (node->type) {
    <%- nodes.each do |node| -%>
    <%- next if node.params.none? { |param| param.is_a?(NodeParam) || param.is_a?(OptionalNodeParam) || param.is_a?(NodeListParam) } -%>
    case <%= node.type %>: {
      yp_<%= node.human %>_t *cast = (yp_<%= node.human %>_t *) node;
      <%- node.params.each do |param| -%>
      <%- case param -%>
      <%- when NodeParam, OptionalNodeParam -%>
      rb_gc_mark_movable((VALUE) cast-><%= param.name %>);
      <%- when NodeListParam -%>
      {
        for (size_t index = 0; index < cast-><%= param.name %>.size; index++) {
          rb_gc_mark_movable((VALUE) cast-><%= param.name %>.nodes[index]);
        }
      }
      <%- end -%>
      <%- end -%>
      break;
    }
    <%- end -%>
    default:
      break;
  }
}

static void
yp_node_data_free(void *data) {
  free(data);
}

static size_t
yp_node_data_memsize(const void *data) {
  return sizeof(yp_node_t);
}

static void
yp_node_data_compact(void *data) {
  yp_node_t *node = (yp_node_t *) data;

  switch (node->type) {
    <%- nodes.each do |node| -%>
    <%- next if node.params.none? { |param| param.is_a?(NodeParam) || param.is_a?(OptionalNodeParam) || param.is_a?(NodeListParam) } -%>
    case <%= node.type %>: {
      yp_<%= node.human %>_t *cast = (yp_<%= node.human %>_t *) node;
      <%- node.params.each do |param| -%>
      <%- case param -%>
      <%- when NodeParam, OptionalNodeParam -%>
      cast-><%= param.name %> = (<%= param.c_type %>_t *) rb_gc_location((VALUE) cast-><%= param.name %>);
      <%- when NodeListParam -%>
      {
        for (size_t index = 0; index < cast-><%= param.name %>.size; index++) {
          cast-><%= param.name %>.nodes[index] = (yp_node_t *) rb_gc_location((VALUE) cast-><%= param.name %>.nodes[index]);
        }
      }
      <%- end -%>
      <%- end -%>
      break;
    }
    <%- end -%>
    default:
      break;
  }
}

static const rb_data_type_t yp_node_data_type = {
  "yp_node_t",
  { yp_node_data_mark, yp_node_data_free, yp_node_data_memsize, yp_node_data_compact },
  NULL, NULL, RUBY_TYPED_FREE_IMMEDIATELY
};

VALUE
yp_node_data_new(yp_node_t *node) {
  switch (node->type) {
    <%- nodes.each do |node| -%>
    case <%= node.type %>: {
      <%- if node.params.any? { |param| param.is_a?(NodeParam) || param.is_a?(OptionalNodeParam) || param.is_a?(NodeListParam) } -%>
      yp_<%= node.human %>_t *cast = (yp_<%= node.human %>_t *) node;

      <%- node.params.each do |param| -%>
      <%- case param -%>
      <%- when NodeParam, OptionalNodeParam -%>
      VALUE <%= param.name %> = yp_node_data_new((yp_node_t *) cast-><%= param.name %>);
      <%- when NodeListParam -%>
      VALUE <%= param.name %>[cast-><%= param.name %>.size];
      {
        for (size_t index = 0; index < cast-><%= param.name %>.size; index++) {
          <%= param.name %>[index] = yp_node_data_new((yp_node_t *) cast-><%= param.name %>.nodes[index]);
        }
      }
      <%- end -%>
      <%- end -%>

      <%- node.params.each do |param| -%>
      <%- case param -%>
      <%- when NodeParam, OptionalNodeParam -%>
      cast-><%= param.name %> = (<%= param.c_type %>_t *) <%= param.name %>;
      <%- when NodeListParam -%>
      {
        for (size_t index = 0; index < cast-><%= param.name %>.size; index++) {
          cast-><%= param.name %>.nodes[index] = (yp_node_t *) <%= param.name %>[index];
        }
      }
      <%- end -%>
      <%- end -%>
      <%- end -%>

      VALUE result = TypedData_Wrap_Struct(rb_cYARP<%= node.name %>, &yp_node_data_type, node);

      <%- if node.params.any? { |param| param.is_a?(NodeParam) || param.is_a?(OptionalNodeParam) || param.is_a?(NodeListParam) } -%>
      <%- node.params.each do |param| -%>
      <%- case param -%>
      <%- when NodeParam, OptionalNodeParam -%>
      RB_GC_GUARD(<%= param.name %>);
      <%- when NodeListParam -%>
      {
        for (size_t index = 0; index < cast-><%= param.name %>.size; index++) {
          RB_GC_GUARD(<%= param.name %>[index]);
        }
      }
      <%- end -%>
      <%- end -%>
      <%- end -%>

      return result;
    }
    <%- end -%>
  }
}

<%- nodes.each do |node| -%>
<%- node.params.each do |param| -%>
<%- case param -%>
<%- when NodeParam, OptionalNodeParam -%>
// <%= node.name %>#<%= param.name %>
static VALUE
yp_<%= node.human %>_<%= param.name %>_get(VALUE self) {
  yp_<%= node.human %>_t *node;
  TypedData_Get_Struct(self, yp_<%= node.human %>_t, &yp_node_data_type, node);
  return (VALUE) node-><%= param.name %>;
}

<%- when NodeListParam -%>
// <%= node.name %>#<%= param.name %>
static VALUE
yp_<%= node.human %>_<%= param.name %>_get(VALUE self) {
  yp_<%= node.human %>_t *node;
  TypedData_Get_Struct(self, yp_<%= node.human %>_t, &yp_node_data_type, node);
  return rb_ary_new_from_values(node-><%= param.name %>.size, (VALUE *) node-><%= param.name %>.nodes);
}

<%- end -%>
<%- end -%>
// <%= node.name %>#accept
static VALUE
yp_<%= node.human %>_accept(VALUE self, VALUE visitor) {
  yp_<%= node.human %>_t *node;
  TypedData_Get_Struct(self, yp_<%= node.human %>_t, &yp_node_data_type, node);
  return rb_funcall(visitor, rb_intern("visit_<%= node.human %>"), 1, self);
}

// <%= node.name %>#child_nodes
static VALUE
yp_<%= node.human %>_child_nodes(VALUE self) {
  yp_<%= node.human %>_t *node;
  TypedData_Get_Struct(self, yp_<%= node.human %>_t, &yp_node_data_type, node);

  VALUE result = rb_ary_new();
  <%- node.params.each do |param| -%>
  <%- case param -%>
  <%- when NodeParam, OptionalNodeParam -%>
  rb_ary_push(result, (VALUE) node-><%= param.name %>);
  <%- when NodeListParam -%>
  {
    for (size_t index = 0; index < node-><%= param.name %>.size; index++) {
      rb_ary_push(result, (VALUE) node-><%= param.name %>.nodes[index]);
    }
  }
  <%- end -%>
  <%- end -%>
  return result;
}

// <%= node.name %>#deconstruct_keys
static VALUE
yp_<%= node.human %>_deconstruct_keys(VALUE self, VALUE keys) {
  yp_<%= node.human %>_t *node;
  TypedData_Get_Struct(self, yp_<%= node.human %>_t, &yp_node_data_type, node);

  VALUE result = rb_hash_new();
  <%- node.params.each do |param| -%>
  <%- case param -%>
  <%- when NodeParam, OptionalNodeParam -%>
  rb_hash_aset(result, ID2SYM(rb_intern("<%= param.name %>")), (VALUE) node-><%= param.name %>);
  <%- when NodeListParam -%>
  rb_hash_aset(result, ID2SYM(rb_intern("<%= param.name %>")), rb_ary_new_from_values(node-><%= param.name %>.size, (VALUE *) node-><%= param.name %>.nodes));
  <%- end -%>
  <%- end -%>
  return result;
}

<%- end -%>
void
Init_yarp_node_data(void) {
  <%- nodes.each do |node| -%>
  rb_cYARP<%= node.name %> = rb_define_class_under(rb_cYARP, "<%= node.name %>", rb_cYARPNode);
  <%- end -%>
  <%- nodes.each do |node| -%>

  <%- node.params.each do |param| -%>
  <%- case param -%>
  <%- when NodeParam, OptionalNodeParam, NodeListParam -%>
  rb_define_method(rb_cYARP<%= node.name %>, "<%= param.name %>", yp_<%= node.human %>_<%= param.name %>_get, 0);
  <%- end -%>
  <%- end -%>
  rb_define_method(rb_cYARP<%= node.name %>, "accept", yp_<%= node.human %>_accept, 1);
  rb_define_method(rb_cYARP<%= node.name %>, "child_nodes", yp_<%= node.human %>_child_nodes, 0);
  rb_define_method(rb_cYARP<%= node.name %>, "deconstruct", yp_<%= node.human %>_child_nodes, 0);
  rb_define_method(rb_cYARP<%= node.name %>, "deconstruct_keys", yp_<%= node.human %>_deconstruct_keys, 1);
  <%- end -%>
}
