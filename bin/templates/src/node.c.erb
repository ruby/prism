/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually.                                                         */
/******************************************************************************/

#include "yarp/node.h"

// Allocate the space for a new yp_node_t. Currently we're not using the
// parser argument, but it's there to allow for the future possibility of
// pre-allocating larger memory pools and then pulling from those here.
static inline yp_node_t *
yp_node_alloc(yp_parser_t *parser) {
  return (yp_node_t *) malloc(sizeof(yp_node_t));
}

// Clear the node but preserves the location.
void yp_node_clear(yp_node_t *node) {
  yp_location_t location = node->location;
  memset(node, 0, sizeof(yp_node_t));
  node->location = location;
}

// Initialize a yp_token_list_t with its default values.
void
yp_token_list_init(yp_token_list_t *token_list) {
  *token_list = (yp_token_list_t) { .tokens = NULL, .size = 0, .capacity = 0 };
}

// Calculate the size of the token list in bytes.
static size_t
yp_token_list_memsize(yp_token_list_t *token_list) {
  return sizeof(yp_token_list_t) + (token_list->capacity * sizeof(yp_token_t));
}

// Append a token to the given list.
void
yp_token_list_append(yp_token_list_t *token_list, const yp_token_t *token) {
  if (token_list->size == token_list->capacity) {
    token_list->capacity = token_list->capacity == 0 ? 1 : token_list->capacity * 2;
    token_list->tokens = realloc(token_list->tokens, sizeof(yp_token_t) * token_list->capacity);
  }
  token_list->tokens[token_list->size++] = *token;
}

// Checks if the current token list includes the given token.
bool
yp_token_list_includes(yp_token_list_t *token_list, const yp_token_t *token) {
  size_t length = token->end - token->start;

  for (size_t index = 0; index < token_list->size; index++) {
    yp_token_t current_token = token_list->tokens[index];

    if (
      ((current_token.end - current_token.start) == length) &&
      (memcmp(current_token.start, token->start, length) == 0)
    ) {
      return true;
    }
  }
  return false;
}

// Free the memory associated with the token list.
static void
yp_token_list_free(yp_token_list_t *token_list) {
  if (token_list->tokens != NULL) {
    free(token_list->tokens);
  }
}

static void
yp_node_memsize_node(yp_node_t *node, yp_memsize_t *memsize);

// Initiailize a list of nodes.
void
yp_node_list_init(yp_node_list_t *node_list) {
  *node_list = (yp_node_list_t) { .nodes = NULL, .size = 0, .capacity = 0 };
}

// Calculate the size of the node list in bytes.
static size_t
yp_node_list_memsize(yp_node_list_t *node_list, yp_memsize_t *memsize) {
  size_t size = sizeof(yp_node_list_t) + (node_list->capacity * sizeof(yp_node_t *));
  for (size_t index = 0; index < node_list->size; index++) {
    yp_node_memsize_node(node_list->nodes[index], memsize);
  }
  return size;
}

// Append a new node onto the end of the node list.
void
yp_node_list_append(yp_parser_t *parser, yp_node_t *parent, yp_node_list_t *list, yp_node_t *node) {
  if (list->size == list->capacity) {
    list->capacity = list->capacity == 0 ? 4 : list->capacity * 2;
    list->nodes = realloc(list->nodes, list->capacity * sizeof(yp_node_t *));
  }

  list->nodes[list->size++] = node;

  if (list->size == 1) parent->location.start = node->location.start;
  parent->location.end = node->location.end;
}

__attribute__((__visibility__("default"))) void
yp_node_destroy(yp_parser_t *parser, yp_node_t *node);

// Deallocate the inner memory of a list of nodes. The parser argument is not
// used, but is here for the future possibility of pre-allocating memory pools.
static void
yp_node_list_free(yp_parser_t *parser, yp_node_list_t *list) {
  if (list->capacity > 0) {
    for (size_t index = 0; index < list->size; index++) {
      yp_node_destroy(parser, list->nodes[index]);
    }
    free(list->nodes);
  }
}

<%- nodes.each do |node| -%>
// Allocate a new <%= node.name %> node.
yp_node_t *
<%- assigns = node.params.map { |param| 
  case param
  in NodeParam | OptionalNodeParam | IntegerParam then ".#{param.name} = #{param.name}"
  in TokenParam | OptionalTokenParam then ".#{param.name} = *#{param.name}"
  in LocationParam | OptionalLocationParam then ".#{param.name} = *#{param.name}"
  in StringParam | NodeListParam | TokenListParam then nil
  end
}.compact.join(", ") -%>
yp_node_<%= node.human %>_create(<%= ["yp_parser_t *parser", *node.params.map(&:param), ("yp_location_t *location" if node.location_provided?)].compact.join(", ") %>) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) { .type = <%= node.type %>, .location = <%= node.location %><%= assigns.empty? ? "" : ", .as.#{node.human} = { #{assigns} }" %> };
  <%- node.params.each do |param| -%>
  <%- case param -%>
  <%- when NodeListParam -%>
  yp_node_list_init(&node->as.<%= node.human %>.<%= param.name %>);
  <%- when TokenListParam -%>
  yp_token_list_init(&node->as.<%= node.human %>.<%= param.name %>);
  <%- end -%>
  <%- end -%>
  return node;
}

<%- end -%>
// Deallocate the space for a yp_node_t. Similarly to yp_node_alloc, we're not
// using the parser argument, but it's there to allow for the future possibility
// of pre-allocating larger memory pools.
__attribute__((__visibility__("default"))) void
yp_node_destroy(yp_parser_t *parser, yp_node_t *node) {
  switch (node->type) {
    <%- nodes.each do |node| -%>
    case <%= node.type %>:
      <%- node.params.each do |param| -%>
      <%- case param -%>
      <%- when TokenParam, OptionalTokenParam, LocationParam, OptionalLocationParam, IntegerParam -%>
      <%- when NodeParam -%>
      yp_node_destroy(parser, node->as.<%= node.human %>.<%= param.name %>);
      <%- when OptionalNodeParam -%>
      if (node->as.<%= node.human %>.<%= param.name %> != NULL) {
        yp_node_destroy(parser, node->as.<%= node.human %>.<%= param.name %>);
      }
      <%- when StringParam -%>
      yp_string_free(&node->as.<%= node.human %>.<%= param.name %>);
      <%- when NodeListParam -%>
      yp_node_list_free(parser, &node->as.<%= node.human %>.<%= param.name %>);
      <%- when TokenListParam -%>
      yp_token_list_free(&node->as.<%= node.human %>.<%= param.name %>);
      <%- else -%>
      <%- raise -%>
      <%- end -%>
      <%- end -%>
      break;
    <%- end -%>
    default:
      assert(false && "unreachable");
      break;
  }
  free(node);
}

static void
yp_node_memsize_node(yp_node_t *node, yp_memsize_t *memsize) {
  memsize->node_count++;

  switch (node->type) {
    <%- nodes.each do |node| -%>
    case <%= node.type %>: {
      memsize->memsize += sizeof(yp_node_t);
      <%- node.params.each do |param| -%>
      <%- case param -%>
      <%- when TokenParam, OptionalTokenParam -%>
      <%- when NodeParam -%>
      yp_node_memsize_node(node->as.<%= node.human %>.<%= param.name %>, memsize);
      <%- when OptionalNodeParam -%>
      if (node->as.<%= node.human %>.<%= param.name %> != NULL) {
        yp_node_memsize_node(node->as.<%= node.human %>.<%= param.name %>, memsize);
      }
      <%- when StringParam -%>
      memsize->memsize += yp_string_memsize(&node->as.<%= node.human %>.<%= param.name %>);
      <%- when NodeListParam -%>
      yp_node_list_memsize(&node->as.<%= node.human %>.<%= param.name %>, memsize);
      <%- when TokenListParam -%>
      memsize->memsize += yp_token_list_memsize(&node->as.<%= node.human %>.<%= param.name %>);
      <%- when LocationParam, OptionalLocationParam -%>
      memsize->memsize += sizeof(yp_location_t);
      <%- when IntegerParam -%>
      memsize->memsize += sizeof(int);
      <%- else -%>
      <%- raise -%>
      <%- end -%>
      <%- end -%>
      break;
    }
    <%- end -%>
  }
}

// Calculates the memory footprint of a given node.
__attribute__((__visibility__("default"))) extern void
yp_node_memsize(yp_node_t *node, yp_memsize_t *memsize) {
  *memsize = (yp_memsize_t) { .memsize = 0, .node_count = 0 };
  yp_node_memsize_node(node, memsize);
}
