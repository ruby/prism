package org.yarp;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

// GENERATED BY <%= File.basename(__FILE__) %>
// @formatter:off
public class Loader {

    public static Nodes.Node load(byte[] source, byte[] serialized) {
        return new Loader(source, serialized).load();
    }

    private final ByteBuffer buffer;

    private Loader(byte[] source, byte[] serialized) {
        buffer = ByteBuffer.wrap(serialized).order(ByteOrder.nativeOrder());
    }

    private Nodes.Node load() {
        expect((byte) 'Y');
        expect((byte) 'A');
        expect((byte) 'R');
        expect((byte) 'P');

        expect((byte) 0);
        expect((byte) 4);
        expect((byte) 0);

        Nodes.Node node = loadNode();

        expect((byte) 0); // yp_serialize() appends a final \0 byte

        int left = buffer.capacity() - buffer.position();
        if (left != 0) {
            throw new Error("Expected to consume all bytes while deserializing but there were " + left + " bytes left");
        }

        return node;
    }

    private byte[] loadString() {
        int length = loadVarInt();
        byte[] string = new byte[length];
        buffer.get(string);
        return string;
    }

    private Nodes.Token loadOptionalToken() {
        if (buffer.get(buffer.position()) != 0) {
            return loadToken();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Nodes.Node loadOptionalNode() {
        if (buffer.get(buffer.position()) != 0) {
            return loadNode();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Nodes.Token[] loadTokens() {
        int length = loadVarInt();
        Nodes.Token[] tokens = new Nodes.Token[length];
        for (int i = 0; i < length; i++) {
            tokens[i] = loadToken();
        }
        return tokens;
    }

    private Nodes.Node[] loadNodes() {
        int length = loadVarInt();
        Nodes.Node[] nodes = new Nodes.Node[length];
        for (int i = 0; i < length; i++) {
            nodes[i] = loadNode();
        }
        return nodes;
    }

    private Nodes.Token loadToken() {
        int type = buffer.get() & 0xFF;
        int startOffset = loadVarInt();
        int length = loadVarInt();
        int endOffset = startOffset + length;

        final Nodes.TokenType tokenType = Nodes.TOKEN_TYPES[type];
        return new Nodes.Token(tokenType, startOffset, endOffset);
    }

    private Nodes.Location loadLocation() {
        int startOffset = loadVarInt();
        int length = loadVarInt();
        int endOffset = startOffset + length;
        return new Nodes.Location(startOffset, endOffset);
    }

    private Nodes.Location loadOptionalLocation() {
        if (buffer.get() != 0) {
            return loadLocation();
        } else {
            return null;
        }
    }

    // From https://github.com/protocolbuffers/protobuf/blob/v23.1/java/core/src/main/java/com/google/protobuf/BinaryReader.java#L1507
    private int loadVarInt() {
        int x;
        if ((x = buffer.get()) >= 0) {
            return x;
        } else if ((x ^= (buffer.get() << 7)) < 0) {
            x ^= (~0 << 7);
        } else if ((x ^= (buffer.get() << 14)) >= 0) {
            x ^= (~0 << 7) ^ (~0 << 14);
        } else if ((x ^= (buffer.get() << 21)) < 0) {
            x ^= (~0 << 7) ^ (~0 << 14) ^ (~0 << 21);
        } else {
            x ^= buffer.get() << 28;
            x ^= (~0 << 7) ^ (~0 << 14) ^ (~0 << 21) ^ (~0 << 28);
        }
        return x;
    }

    private Nodes.Node loadNode() {
        int type = buffer.get() & 0xFF;
        int startOffset = loadVarInt();
        int length = loadVarInt();
        int endOffset = startOffset + length;

        switch (type) {
            <%- nodes.each_with_index do |node, index| -%>
            case <%= index + 1 %>:
            <%-
            params = node.needs_serialized_length? ? ["buffer.getInt()"] : []
            params.concat node.params.map { |param|
              case param
              when NodeParam then "#{param.java_cast}loadNode()"
              when OptionalNodeParam then "#{param.java_cast}loadOptionalNode()"
              when StringParam then "loadString()"
              when NodeListParam then "loadNodes()"
              when TokenParam then "loadToken()"
              when TokenListParam then "loadTokens()"
              when OptionalTokenParam then "loadOptionalToken()"
              when LocationParam then "loadLocation()"
              when OptionalLocationParam then "loadOptionalLocation()"
              when UInt32Param then "loadVarInt()"
              else raise
              end
            }
            params.concat ["startOffset", "endOffset"]
            -%>
                return new Nodes.<%= node.name %>(<%= params.join(", ") -%>);
            <%- end -%>
            default:
                throw new Error("Unknown node type: " + type);
        }
    }

    private void expect(byte value) {
        byte b = buffer.get();
        if (b != value) {
            throw new Error("Expected " + value + " but was " + b + " at position " + buffer.position());
        }
    }

}
// @formatter:on
