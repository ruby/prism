package org.yarp;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

// GENERATED BY <%= File.basename(__FILE__) %>
// @formatter:off
public class Loader {

    public static Nodes.Node load(byte[] source, byte[] serialized) {
        return new Loader(serialized).load(source);
    }

    private static final class ConstantPool {

        private final byte[] source;
        private final int bufferOffset;
        private final byte[][] cache;

        ConstantPool(byte[] source, int bufferOffset, int length) {
            this.source = source;
            this.bufferOffset = bufferOffset;
            cache = new byte[length][];
        }

        byte[] get(ByteBuffer buffer, int oneBasedIndex) {
            int index = oneBasedIndex - 1;
            byte[] constant = cache[index];
            if (constant == null) {
                int offset = buffer.getInt(bufferOffset + index * 8);
                int length = buffer.getInt(bufferOffset + index * 8 + 4);

                constant = new byte[length];
                System.arraycopy(source, offset, constant, 0, length);
                cache[index] = constant;
            }
            return constant;
        }

    }

    private final ByteBuffer buffer;
    private ConstantPool constantPool;

    private Loader(byte[] serialized) {
        buffer = ByteBuffer.wrap(serialized).order(ByteOrder.nativeOrder());
    }

    private Nodes.Node load(byte[] source) {
        expect((byte) 'Y');
        expect((byte) 'A');
        expect((byte) 'R');
        expect((byte) 'P');

        expect((byte) 0);
        expect((byte) 4);
        expect((byte) 0);

        int constantPoolBufferOffset = buffer.getInt();
        int constantPoolLength = loadVarInt();
        this.constantPool = new ConstantPool(source, constantPoolBufferOffset, constantPoolLength);

        Nodes.Node node = loadNode();
        int left = constantPoolBufferOffset - buffer.position();

        if (left != 0) {
            throw new Error("Expected to consume all bytes while deserializing but there were " + left + " bytes left");
        }

        return node;
    }

    private byte[] loadString() {
        int length = loadVarInt();
        byte[] string = new byte[length];
        buffer.get(string);
        return string;
    }

    private Nodes.Token loadOptionalToken() {
        if (buffer.get(buffer.position()) != 0) {
            return loadToken();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Nodes.Node loadOptionalNode() {
        if (buffer.get(buffer.position()) != 0) {
            return loadNode();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Nodes.Token[] loadTokens() {
        int length = loadVarInt();
        Nodes.Token[] tokens = new Nodes.Token[length];
        for (int i = 0; i < length; i++) {
            tokens[i] = loadToken();
        }
        return tokens;
    }

    private byte[] loadConstant() {
        return constantPool.get(buffer, loadVarInt());
    }

    private byte[][] loadConstants() {
        int length = loadVarInt();
        byte[][] constants = new byte[length][];
        for (int i = 0; i < length; i++) {
            constants[i] = constantPool.get(buffer, loadVarInt());
        }
        return constants;
    }

    private Nodes.Node[] loadNodes() {
        int length = loadVarInt();
        Nodes.Node[] nodes = new Nodes.Node[length];
        for (int i = 0; i < length; i++) {
            nodes[i] = loadNode();
        }
        return nodes;
    }

    private Nodes.Token loadToken() {
        int type = buffer.get() & 0xFF;
        final Nodes.TokenType tokenType = Nodes.TOKEN_TYPES[type];
        return new Nodes.Token(tokenType, loadVarInt(), loadVarInt());
    }

    private Nodes.Location loadLocation() {
        return new Nodes.Location(loadVarInt(), loadVarInt());
    }

    private Nodes.Location loadOptionalLocation() {
        if (buffer.get() != 0) {
            return loadLocation();
        } else {
            return null;
        }
    }

    // From https://github.com/protocolbuffers/protobuf/blob/v23.1/java/core/src/main/java/com/google/protobuf/BinaryReader.java#L1507
    private int loadVarInt() {
        int x;
        if ((x = buffer.get()) >= 0) {
            return x;
        } else if ((x ^= (buffer.get() << 7)) < 0) {
            x ^= (~0 << 7);
        } else if ((x ^= (buffer.get() << 14)) >= 0) {
            x ^= (~0 << 7) ^ (~0 << 14);
        } else if ((x ^= (buffer.get() << 21)) < 0) {
            x ^= (~0 << 7) ^ (~0 << 14) ^ (~0 << 21);
        } else {
            x ^= buffer.get() << 28;
            x ^= (~0 << 7) ^ (~0 << 14) ^ (~0 << 21) ^ (~0 << 28);
        }
        return x;
    }

    private Nodes.Node loadNode() {
        int type = buffer.get() & 0xFF;
        int startOffset = loadVarInt();
        int length = loadVarInt();

        switch (type) {
            <%- nodes.each_with_index do |node, index| -%>
            case <%= index + 1 %>:
            <%-
            params = node.needs_serialized_length? ? ["buffer.getInt()"] : []
            params.concat node.params.map { |param|
              case param
              when NodeParam then "#{param.java_cast}loadNode()"
              when OptionalNodeParam then "#{param.java_cast}loadOptionalNode()"
              when StringParam then "loadString()"
              when NodeListParam then "loadNodes()"
              when TokenParam then "loadToken()"
              when TokenListParam then "loadTokens()"
              when ConstantParam then "loadConstant()"
              when ConstantListParam then "loadConstants()"
              when OptionalTokenParam then "loadOptionalToken()"
              when LocationParam then "loadLocation()"
              when OptionalLocationParam then "loadOptionalLocation()"
              when UInt32Param then "loadVarInt()"
              else raise
              end
            }
            params.concat ["startOffset", "length"]
            -%>
                return new Nodes.<%= node.name %>(<%= params.join(", ") -%>);
            <%- end -%>
            default:
                throw new Error("Unknown node type: " + type);
        }
    }

    private void expect(byte value) {
        byte b = buffer.get();
        if (b != value) {
            throw new Error("Expected " + value + " but was " + b + " at position " + buffer.position());
        }
    }

}
// @formatter:on
