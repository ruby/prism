package org.yarp;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

// GENERATED BY <%= File.basename(__FILE__) %>
public class Loader {

    public static Nodes.Node load(byte[] source, byte[] serialized) {
        return new Loader(source, serialized).load();
    }

    private final ByteBuffer buffer;

    private Loader(byte[] source, byte[] serialized) {
        buffer = ByteBuffer.wrap(serialized).order(ByteOrder.nativeOrder());
    }

    private Nodes.Node load() {
        expect((byte) 'Y');
        expect((byte) 'A');
        expect((byte) 'R');
        expect((byte) 'P');

        expect((byte) 0);
        expect((byte) 2);
        expect((byte) 0);

        return loadNode();
    }

    private byte[] loadString() {
        int length = buffer.getInt();
        byte[] string = new byte[length];
        buffer.get(string);
        return string;
    }

    private Nodes.Token loadOptionalToken() {
        if (buffer.get(buffer.position()) != 0) {
            return loadToken();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Nodes.Node loadOptionalNode() {
        if (buffer.get(buffer.position()) != 0) {
            return loadNode();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private Nodes.Token[] loadTokens() {
        int length = buffer.getInt();
        Nodes.Token[] tokens = new Nodes.Token[length];
        for (int i = 0; i < length; i++) {
            tokens[i] = loadToken();
        }
        return tokens;
    }

    private Nodes.Node[] loadNodes() {
        int length = buffer.getInt();
        Nodes.Node[] nodes = new Nodes.Node[length];
        for (int i = 0; i < length; i++) {
            nodes[i] = loadNode();
        }
        return nodes;
    }

    private Nodes.Token loadToken() {
        int type = buffer.get() & 0xFF;
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();

        final Nodes.TokenType tokenType = Nodes.TOKEN_TYPES[type];
        return new Nodes.Token(tokenType, startOffset, endOffset);
    }

    private Nodes.Location loadLocation() {
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();
        return new Nodes.Location(startOffset, endOffset);
    }

    private int loadInteger() {
        return buffer.getInt();
    }

    private Nodes.Node loadNode() {
        int type = buffer.get() & 0xFF;
        int length = buffer.getInt();
        int startOffset = buffer.getInt();
        int endOffset = buffer.getInt();

        switch (type) {
            <%- nodes.each_with_index do |node, index| -%>
            case <%= index %>:
                return new Nodes.<%= node.name %>(<%= (node.params.map { |param|
                    case param
                    when NodeParam then "loadNode()"
                    when OptionalNodeParam then "loadOptionalNode()"
                    when StringParam then "loadString()"
                    when NodeListParam then "loadNodes()"
                    when TokenParam then "loadToken()"
                    when TokenListParam then "loadTokens()"
                    when OptionalTokenParam then "loadOptionalToken()"
                    when LocationParam then "loadLocation()"
                    when IntegerParam then "loadInteger()"
                    else raise
                    end
            } + ["startOffset", "endOffset"]).join(", ") -%>);
            <%- end -%>
            default:
                throw new Error("Unknown node type: " + type);
        }
    }

    private void expect(byte value) {
        byte b = buffer.get();
        if (b != value) {
            throw new Error("Expected " + value + " but was " + b + " at position " + buffer.position());
        }
    }

}
