# Generated from lib/prism/parse_result/newlines.rb with RBS::Inline

module Prism
  class ParseResult < Result
    # The :line tracepoint event gets fired whenever the Ruby VM encounters an
    # expression on a new line. The types of expressions that can trigger this
    # event are:
    #
    # * if statements
    # * unless statements
    # * nodes that are children of statements lists
    #
    # In order to keep track of the newlines, we have a list of offsets that
    # come back from the parser. We assign these offsets to the first nodes that
    # we find in the tree that are on those lines.
    #
    # Note that the logic in this file should be kept in sync with the Java
    # MarkNewlinesVisitor, since that visitor is responsible for marking the
    # newlines for JRuby/TruffleRuby.
    #
    # This file is autoloaded only when `mark_newlines!` is called, so the
    # re-opening of the various nodes in this file will only be performed in
    # that case. We do that to avoid storing the extra `@newline` instance
    # variable on every node if we don't need it.
    class Newlines < Visitor
      @lines: Array[bool]

      # Create a new Newlines visitor with the given newline offsets.
      # --
      # : (Integer lines) -> void
      def initialize: (Integer lines) -> void

      # Permit block nodes to mark newlines within themselves.
      # --
      # : (BlockNode node) -> void
      def visit_block_node: (BlockNode node) -> void

      # Permit lambda nodes to mark newlines within themselves.
      # --
      # : (LambdaNode node) -> void
      def visit_lambda_node: (LambdaNode node) -> void

      # Mark if nodes as newlines.
      # --
      # : (IfNode node) -> void
      def visit_if_node: (IfNode node) -> void

      # Mark unless nodes as newlines.
      # --
      # : (UnlessNode node) -> void
      def visit_unless_node: (UnlessNode node) -> void

      # Permit statements lists to mark newlines within themselves.
      # --
      # : (StatementsNode node) -> void
      def visit_statements_node: (StatementsNode node) -> void
    end
  end

  class Node
    @newline_flag: bool

    # : () -> bool
    def newline_flag?: () -> bool

    # : (Array[bool] lines) -> void
    def newline_flag!: (Array[bool] lines) -> void
  end

  class BeginNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class ParenthesesNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class IfNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class UnlessNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class UntilNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class WhileNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class RescueModifierNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class InterpolatedMatchLastLineNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class InterpolatedRegularExpressionNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class InterpolatedStringNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class InterpolatedSymbolNode < Node
    # @rbs override
    def newline_flag!: ...
  end

  class InterpolatedXStringNode < Node
    # @rbs override
    def newline_flag!: ...
  end
end
