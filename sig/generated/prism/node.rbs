# Generated from lib/prism/node.rb with RBS::Inline

module Prism
  interface _Repository
    def enter: (Integer node_id, Symbol field_name) -> Relocation::Entry
  end

  interface _Node
    def deconstruct: () -> Array[Prism::node?]

    def inspect: () -> String
  end

  type node = Node & _Node

  # This represents a node in the tree. It is the parent class of all of the
  # various node types.
  class Node
    # A pointer to the source that this node was created from.
    # :stopdoc:
    attr_reader source: Source

    # A unique identifier for this node. This is used in a very specific
    # use case where you want to keep around a reference to a node without
    # having to keep around the syntax tree in memory. This unique identifier
    # will be consistent across multiple parses of the same source code.
    attr_reader node_id: Integer

    @location: Location | Integer

    # Save this node using a saved source so that it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save: (_Repository repository) -> Relocation::Entry

    # A Location instance that represents the location of this node in the
    # source.
    # --
    # : () -> Location
    def location: () -> Location

    # Save the location using a saved source so that it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_location: (_Repository repository) -> Relocation::Entry

    # Delegates to [`start_line`](rdoc-ref:Location#start_line) of the associated location object.
    # --
    # : () -> Integer
    def start_line: () -> Integer

    # Delegates to [`end_line`](rdoc-ref:Location#end_line) of the associated location object.
    # --
    # : () -> Integer
    def end_line: () -> Integer

    # Delegates to [`start_offset`](rdoc-ref:Location#start_offset) of the associated location object.
    # --
    # : () -> Integer
    def start_offset: () -> Integer

    # Delegates to [`end_offset`](rdoc-ref:Location#end_offset) of the associated location object.
    # --
    # : () -> Integer
    def end_offset: () -> Integer

    # Delegates to [`start_character_offset`](rdoc-ref:Location#start_character_offset)
    # of the associated location object.
    # --
    # : () -> Integer
    def start_character_offset: () -> Integer

    # Delegates to [`end_character_offset`](rdoc-ref:Location#end_character_offset)
    # of the associated location object.
    # --
    # : () -> Integer
    def end_character_offset: () -> Integer

    # Delegates to [`cached_start_code_units_offset`](rdoc-ref:Location#cached_start_code_units_offset)
    # of the associated location object.
    # --
    # : (_CodeUnitsCache cache) -> Integer
    def cached_start_code_units_offset: (_CodeUnitsCache cache) -> Integer

    # Delegates to [`cached_end_code_units_offset`](rdoc-ref:Location#cached_end_code_units_offset)
    # of the associated location object.
    # --
    # : (_CodeUnitsCache cache) -> Integer
    def cached_end_code_units_offset: (_CodeUnitsCache cache) -> Integer

    # Delegates to [`start_column`](rdoc-ref:Location#start_column) of the associated location object.
    # --
    # : () -> Integer
    def start_column: () -> Integer

    # Delegates to [`end_column`](rdoc-ref:Location#end_column) of the associated location object.
    # --
    # : () -> Integer
    def end_column: () -> Integer

    # Delegates to [`start_character_column`](rdoc-ref:Location#start_character_column)
    # of the associated location object.
    # --
    # : () -> Integer
    def start_character_column: () -> Integer

    # Delegates to [`end_character_column`](rdoc-ref:Location#end_character_column)
    # of the associated location object.
    # --
    # : () -> Integer
    def end_character_column: () -> Integer

    # Delegates to [`cached_start_code_units_column`](rdoc-ref:Location#cached_start_code_units_column)
    # of the associated location object.
    # --
    # : (_CodeUnitsCache cache) -> Integer
    def cached_start_code_units_column: (_CodeUnitsCache cache) -> Integer

    # Delegates to [`cached_end_code_units_column`](rdoc-ref:Location#cached_end_code_units_column)
    # of the associated location object.
    # --
    # : (_CodeUnitsCache cache) -> Integer
    def cached_end_code_units_column: (_CodeUnitsCache cache) -> Integer

    # Delegates to [`leading_comments`](rdoc-ref:Location#leading_comments) of the associated location object.
    # --
    # : () -> Array[Comment]
    def leading_comments: () -> Array[Comment]

    # Delegates to [`trailing_comments`](rdoc-ref:Location#trailing_comments) of the associated location object.
    # --
    # : () -> Array[Comment]
    def trailing_comments: () -> Array[Comment]

    # Delegates to [`comments`](rdoc-ref:Location#comments) of the associated location object.
    # --
    # : () -> Array[Comment]
    def comments: () -> Array[Comment]

    # Returns all of the lines of the source code associated with this node.
    # --
    # : () -> Array[String]
    def source_lines: () -> Array[String]

    # An alias for source_lines, used to mimic the API from
    # RubyVM::AbstractSyntaxTree to make it easier to migrate.
    alias script_lines source_lines

    # Slice the location of the node from the source.
    # --
    # : () -> String
    def slice: () -> String

    # Slice the location of the node from the source, starting at the beginning
    # of the line that the location starts on, ending at the end of the line
    # that the location ends on.
    # --
    # : () -> String
    def slice_lines: () -> String

    # An bitset of flags for this node. There are certain flags that are common
    # for all nodes, and then some nodes have specific flags.
    # :stopdoc:
    attr_reader flags: Integer

    # Returns true if the node has the newline flag set.
    # --
    # : () -> bool
    def newline?: () -> bool

    # Returns true if the node has the static literal flag set.
    # --
    # : () -> bool
    def static_literal?: () -> bool

    # Similar to inspect, but respects the current level of indentation given by
    # the pretty print object.
    # --
    # : (PP q) -> void
    def pretty_print: (PP q) -> void

    # Convert this node into a graphviz dot graph string.
    # --
    # : () -> String
    def to_dot: () -> String

    # Returns a list of nodes that are descendants of this node that contain the
    # given line and column. This is useful for locating a node that is selected
    # based on the line and column of the source code.
    #
    # Important to note is that the column given to this method should be in
    # bytes, as opposed to characters or code units.
    # --
    # : (Integer line, Integer column) -> Array[node]
    def tunnel: (Integer line, Integer column) -> Array[node]

    # Returns the first node that matches the given block when visited in a
    # breadth-first search. This is useful for finding a node that matches a
    # particular condition.
    #
    #     node.breadth_first_search { |node| node.node_id == node_id }
    # --
    # : () { (node) -> bool } -> node?
    def breadth_first_search: () { (node) -> bool } -> node?

    alias find breadth_first_search

    # Returns all of the nodes that match the given block when visited in a
    # breadth-first search. This is useful for finding all nodes that match a
    # particular condition.
    #
    #     node.breadth_first_search_all { |node| node.is_a?(Prism::CallNode) }
    # --
    # : () { (node) -> bool } -> Array[node]
    def breadth_first_search_all: () { (node) -> bool } -> Array[node]

    alias find_all breadth_first_search_all

    # Returns a list of the fields that exist for this node class. Fields
    # describe the structure of the node. This kind of reflection is useful for
    # things like recursively visiting each node _and_ field in the tree.
    # --
    # : () -> Array[Reflection::Field]
    def self.fields: () -> Array[Reflection::Field]

    # Accepts a visitor and calls back into the specialized visit function.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # Returns an array of child nodes, including `nil`s in the place of optional
    # nodes that were not present.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    alias deconstruct child_nodes

    # With a block given, yields each child node. Without a block, returns
    # an enumerator that contains each child node. Excludes any `nil`s in
    # the place of optional nodes that were not present.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # Returns an array of child nodes, excluding any `nil`s in the place of
    # optional nodes that were not present.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # Returns an array of child nodes and locations that could potentially have
    # comments attached to them.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # Returns a string representation of the node.
    # --
    # : () -> String
    def inspect: () -> String

    # Sometimes you want to check an instance of a node against a list of
    # classes to see what kind of behavior to perform. Usually this is done by
    # calling `[cls1, cls2].include?(node.class)` or putting the node into a
    # case statement and doing `case node; when cls1; when cls2; end`. Both of
    # these approaches are relatively slow because of the constant lookups,
    # method calls, and/or array allocations.
    #
    # Instead, you can call #type, which will return to you a symbol that you
    # can use for comparison. This is faster than the other approaches because
    # it uses a single integer comparison, but also because if you're on CRuby
    # you can take advantage of the fact that case statements with all symbol
    # keys will use a jump table.
    # --
    # : () -> Symbol
    def type: () -> Symbol

    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    # --
    # : () -> Symbol
    def self.type: () -> Symbol
  end

  # Represents the use of the `alias` keyword to alias a global variable.
  #
  #     alias $foo $bar
  #     ^^^^^^^^^^^^^^^
  class AliasGlobalVariableNode < Node
    @keyword_loc: Location

    @old_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode

    @new_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode

    # Initialize a new AliasGlobalVariableNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode) new_name, (GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode) old_name, Location keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode new_name, GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode old_name, Location keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> AliasGlobalVariableNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?new_name: (GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode), ?old_name: (GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode), ?keyword_loc: Location) -> AliasGlobalVariableNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?new_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode, ?old_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode, ?keyword_loc: Location) -> AliasGlobalVariableNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :alias_global_variable_node
    def type: () -> :alias_global_variable_node

    # See `Node.type`.
    # --
    # : () -> :alias_global_variable_node
    def self.type: () -> :alias_global_variable_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   new_name -> GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode
    #
    # Represents the new name of the global variable that can be used after aliasing.
    #
    #     alias $foo $bar
    #           ^^^^
    # --
    # : () -> (GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode)
    def new_name: () -> (GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode)

    # :call-seq:
    #   old_name -> GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode
    #
    # Represents the old name of the global variable that can be used before aliasing.
    #
    #     alias $foo $bar
    #                ^^^^
    # --
    # : () -> (GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode)
    def old_name: () -> (GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode)

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # The Location of the `alias` keyword.
    #
    #     alias $foo $bar
    #     ^^^^^
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `alias` keyword to alias a method.
  #
  #     alias foo bar
  #     ^^^^^^^^^^^^^
  class AliasMethodNode < Node
    @keyword_loc: Location

    @old_name: SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode

    @new_name: SymbolNode | InterpolatedSymbolNode

    # Initialize a new AliasMethodNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (SymbolNode | InterpolatedSymbolNode) new_name, (SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode) old_name, Location keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, SymbolNode | InterpolatedSymbolNode new_name, SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode old_name, Location keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> AliasMethodNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?new_name: (SymbolNode | InterpolatedSymbolNode), ?old_name: (SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode), ?keyword_loc: Location) -> AliasMethodNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?new_name: SymbolNode | InterpolatedSymbolNode, ?old_name: SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode, ?keyword_loc: Location) -> AliasMethodNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :alias_method_node
    def type: () -> :alias_method_node

    # See `Node.type`.
    # --
    # : () -> :alias_method_node
    def self.type: () -> :alias_method_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   new_name -> SymbolNode | InterpolatedSymbolNode
    #
    # Represents the new name of the method that will be aliased.
    #
    #     alias foo bar
    #           ^^^
    #
    #     alias :foo :bar
    #           ^^^^
    #
    #     alias :"#{foo}" :"#{bar}"
    #           ^^^^^^^^^
    # --
    # : () -> (SymbolNode | InterpolatedSymbolNode)
    def new_name: () -> (SymbolNode | InterpolatedSymbolNode)

    # :call-seq:
    #   old_name -> SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode
    #
    # Represents the old name of the method that will be aliased.
    #
    #     alias foo bar
    #               ^^^
    #
    #     alias :foo :bar
    #                ^^^^
    #
    #     alias :"#{foo}" :"#{bar}"
    #                     ^^^^^^^^^
    # --
    # : () -> (SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode)
    def old_name: () -> (SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode)

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Represents the Location of the `alias` keyword.
    #
    #     alias foo bar
    #     ^^^^^
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an alternation pattern in pattern matching.
  #
  #     foo => bar | baz
  #            ^^^^^^^^^
  class AlternationPatternNode < Node
    @operator_loc: Location

    @right: Prism::node

    @left: Prism::node

    # Initialize a new AlternationPatternNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> AlternationPatternNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> AlternationPatternNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> AlternationPatternNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :alternation_pattern_node
    def type: () -> :alternation_pattern_node

    # See `Node.type`.
    # --
    # : () -> :alternation_pattern_node
    def self.type: () -> :alternation_pattern_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   left -> Node
    #
    # Represents the left side of the expression.
    #
    #     foo => bar | baz
    #            ^^^
    # --
    # : () -> Prism::node
    def left: () -> Prism::node

    # :call-seq:
    #   right -> Node
    #
    # Represents the right side of the expression.
    #
    #     foo => bar | baz
    #                  ^^^
    # --
    # : () -> Prism::node
    def right: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Represents the alternation operator Location.
    #
    #     foo => bar | baz
    #                ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&` operator or the `and` keyword.
  #
  #     left and right
  #     ^^^^^^^^^^^^^^
  class AndNode < Node
    @operator_loc: Location

    @right: Prism::node

    @left: Prism::node

    # Initialize a new AndNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> AndNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> AndNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> AndNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :and_node
    def type: () -> :and_node

    # See `Node.type`.
    # --
    # : () -> :and_node
    def self.type: () -> :and_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   left -> Node
    #
    # Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     left and right
    #     ^^^^
    #
    #     1 && 2
    #     ^
    # --
    # : () -> Prism::node
    def left: () -> Prism::node

    # :call-seq:
    #   right -> Node
    #
    # Represents the right side of the expression.
    #
    #     left && right
    #             ^^^^^
    #
    #     1 and 2
    #           ^
    # --
    # : () -> Prism::node
    def right: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `and` keyword or the `&&` operator.
    #
    #     left and right
    #          ^^^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a set of arguments to a method or a keyword.
  #
  #     return foo, bar, baz
  #            ^^^^^^^^^^^^^
  class ArgumentsNode < Node
    @arguments: Array[Prism::node]

    # Initialize a new ArgumentsNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] arguments) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] arguments) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ArgumentsNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: Array[Prism::node]) -> ArgumentsNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: Array[Prism::node]) -> ArgumentsNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :arguments_node
    def type: () -> :arguments_node

    # See `Node.type`.
    # --
    # : () -> :arguments_node
    def self.type: () -> :arguments_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # if the arguments contain forwarding
    # --
    # : () -> bool
    def contains_forwarding?: () -> bool

    # :category: Flags
    # if the arguments contain keywords
    # --
    # : () -> bool
    def contains_keywords?: () -> bool

    # :category: Flags
    # if the arguments contain a keyword splat
    # --
    # : () -> bool
    def contains_keyword_splat?: () -> bool

    # :category: Flags
    # if the arguments contain a splat
    # --
    # : () -> bool
    def contains_splat?: () -> bool

    # :category: Flags
    # if the arguments contain multiple splats
    # --
    # : () -> bool
    def contains_multiple_splats?: () -> bool

    # :call-seq:
    #   arguments -> Array[Node]
    #
    # The list of arguments, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo(bar, baz)
    #         ^^^^^^^^
    # --
    # : () -> Array[Prism::node]
    def arguments: () -> Array[Prism::node]

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
  #
  #     [1, 2, 3]
  #     ^^^^^^^^^
  class ArrayNode < Node
    @closing_loc: Location?

    @opening_loc: Location?

    @elements: Array[Prism::node]

    # Initialize a new ArrayNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] elements, Location? opening_loc, Location? closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] elements, Location? opening_loc, Location? closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ArrayNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?elements: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?) -> ArrayNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?elements: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?) -> ArrayNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :array_node
    def type: () -> :array_node

    # See `Node.type`.
    # --
    # : () -> :array_node
    def self.type: () -> :array_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # if array contains splat nodes
    # --
    # : () -> bool
    def contains_splat?: () -> bool

    # :call-seq:
    #   elements -> Array[Node]
    #
    # Represent the list of zero or more [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression) within the array.
    # --
    # : () -> Array[Prism::node]
    def elements: () -> Array[Prism::node]

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # Represents the optional source Location for the opening token.
    #
    #     [1,2,3]                 # "["
    #     %w[foo bar baz]         # "%w["
    #     %I(apple orange banana) # "%I("
    #     foo = 1, 2, 3           # nil
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Represents the optional source Location for the closing token.
    #
    #     [1,2,3]                 # "]"
    #     %w[foo bar baz]         # "]"
    #     %I(apple orange banana) # ")"
    #     foo = 1, 2, 3           # nil
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an array pattern in pattern matching.
  #
  #     foo in 1, 2
  #     ^^^^^^^^^^^
  #
  #     foo in [1, 2]
  #     ^^^^^^^^^^^^^
  #
  #     foo in *bar
  #     ^^^^^^^^^^^
  #
  #     foo in Bar[]
  #     ^^^^^^^^^^^^
  #
  #     foo in Bar[1, 2, 3]
  #     ^^^^^^^^^^^^^^^^^^^
  class ArrayPatternNode < Node
    @closing_loc: Location?

    @opening_loc: Location?

    @posts: Array[Prism::node]

    @rest: Prism::node?

    @requireds: Array[Prism::node]

    @constant: (ConstantPathNode | ConstantReadNode)?

    # Initialize a new ArrayPatternNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (ConstantPathNode | ConstantReadNode)? constant, Array[Prism::node] requireds, Prism::node? rest, Array[Prism::node] posts, Location? opening_loc, Location? closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, (ConstantPathNode | ConstantReadNode)? constant, Array[Prism::node] requireds, Prism::node? rest, Array[Prism::node] posts, Location? opening_loc, Location? closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ArrayPatternNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: (ConstantPathNode | ConstantReadNode)?, ?requireds: Array[Prism::node], ?rest: Prism::node?, ?posts: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?) -> ArrayPatternNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: (ConstantPathNode | ConstantReadNode)?, ?requireds: Array[Prism::node], ?rest: Prism::node?, ?posts: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?) -> ArrayPatternNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :array_pattern_node
    def type: () -> :array_pattern_node

    # See `Node.type`.
    # --
    # : () -> :array_pattern_node
    def self.type: () -> :array_pattern_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   constant -> ConstantPathNode | ConstantReadNode | nil
    #
    # Represents the optional constant preceding the Array
    #
    #     foo in Bar[]
    #            ^^^
    #
    #     foo in Bar[1, 2, 3]
    #            ^^^
    #
    #     foo in Bar::Baz[1, 2, 3]
    #            ^^^^^^^^
    # --
    # : () -> (ConstantPathNode | ConstantReadNode)?
    def constant: () -> (ConstantPathNode | ConstantReadNode)?

    # :call-seq:
    #   requireds -> Array[Node]
    #
    # Represents the required elements of the array pattern.
    #
    #     foo in [1, 2]
    #             ^  ^
    # --
    # : () -> Array[Prism::node]
    def requireds: () -> Array[Prism::node]

    # :call-seq:
    #   rest -> Node | nil
    #
    # Represents the rest element of the array pattern.
    #
    #     foo in *bar
    #            ^^^^
    # --
    # : () -> Prism::node?
    def rest: () -> Prism::node?

    # :call-seq:
    #   posts -> Array[Node]
    #
    # Represents the elements after the rest element of the array pattern.
    #
    #     foo in *bar, baz
    #                  ^^^
    # --
    # : () -> Array[Prism::node]
    def posts: () -> Array[Prism::node]

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # Represents the opening Location of the array pattern.
    #
    #     foo in [1, 2]
    #            ^
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Represents the closing Location of the array pattern.
    #
    #     foo in [1, 2]
    #                 ^
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a hash key/value pair.
  #
  #     { a => b }
  #       ^^^^^^
  class AssocNode < Node
    @operator_loc: Location?

    @value: Prism::node

    @key: Prism::node

    # Initialize a new AssocNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node key, Prism::node value, Location? operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node key, Prism::node value, Location? operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> AssocNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?key: Prism::node, ?value: Prism::node, ?operator_loc: Location?) -> AssocNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?key: Prism::node, ?value: Prism::node, ?operator_loc: Location?) -> AssocNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :assoc_node
    def type: () -> :assoc_node

    # See `Node.type`.
    # --
    # : () -> :assoc_node
    def self.type: () -> :assoc_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   key -> Node
    #
    # The key of the association. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     { a: b }
    #       ^
    #
    #     { foo => bar }
    #       ^^^
    #
    #     { def a; end => 1 }
    #       ^^^^^^^^^^
    # --
    # : () -> Prism::node
    def key: () -> Prism::node

    # :call-seq:
    #   value -> Node
    #
    # The value of the association, if present. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     { foo => bar }
    #              ^^^
    #
    #     { x: 1 }
    #          ^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location | nil
    #
    # The Location of the `=>` operator, if present.
    #
    #     { foo => bar }
    #           ^^
    # --
    # : () -> Location?
    def operator_loc: () -> Location?

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   operator -> String | nil
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String?
    def operator: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a splat in a hash literal.
  #
  #     { **foo }
  #       ^^^^^
  class AssocSplatNode < Node
    @operator_loc: Location

    @value: Prism::node?

    # Initialize a new AssocSplatNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? value, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? value, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> AssocSplatNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node?, ?operator_loc: Location) -> AssocSplatNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node?, ?operator_loc: Location) -> AssocSplatNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :assoc_splat_node
    def type: () -> :assoc_splat_node

    # See `Node.type`.
    # --
    # : () -> :assoc_splat_node
    def self.type: () -> :assoc_splat_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   value -> Node | nil
    #
    # The value to be splatted, if present. Will be missing when keyword rest argument forwarding is used.
    #
    #     { **foo }
    #         ^^^
    # --
    # : () -> Prism::node?
    def value: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `**` operator.
    #
    #     { **x }
    #       ^^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents reading a reference to a field in the previous match.
  #
  #     $'
  #     ^^
  class BackReferenceReadNode < Node
    @name: Symbol

    # Initialize a new BackReferenceReadNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> BackReferenceReadNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> BackReferenceReadNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> BackReferenceReadNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :back_reference_read_node
    def type: () -> :back_reference_read_node

    # See `Node.type`.
    # --
    # : () -> :back_reference_read_node
    def self.type: () -> :back_reference_read_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the back-reference variable, including the leading `$`.
    #
    #     $& # name `:$&`
    #
    #     $+ # name `:$+`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a begin statement.
  #
  #     begin
  #       foo
  #     end
  #     ^^^^^
  class BeginNode < Node
    @end_keyword_loc: Location?

    @ensure_clause: EnsureNode?

    @else_clause: ElseNode?

    @rescue_clause: RescueNode?

    @statements: StatementsNode?

    @begin_keyword_loc: Location?

    # Initialize a new BeginNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location? begin_keyword_loc, StatementsNode? statements, RescueNode? rescue_clause, ElseNode? else_clause, EnsureNode? ensure_clause, Location? end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? begin_keyword_loc, StatementsNode? statements, RescueNode? rescue_clause, ElseNode? else_clause, EnsureNode? ensure_clause, Location? end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> BeginNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?begin_keyword_loc: Location?, ?statements: StatementsNode?, ?rescue_clause: RescueNode?, ?else_clause: ElseNode?, ?ensure_clause: EnsureNode?, ?end_keyword_loc: Location?) -> BeginNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?begin_keyword_loc: Location?, ?statements: StatementsNode?, ?rescue_clause: RescueNode?, ?else_clause: ElseNode?, ?ensure_clause: EnsureNode?, ?end_keyword_loc: Location?) -> BeginNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :begin_node
    def type: () -> :begin_node

    # See `Node.type`.
    # --
    # : () -> :begin_node
    def self.type: () -> :begin_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   begin_keyword_loc -> Location | nil
    #
    # Represents the Location of the `begin` keyword.
    #
    #     begin x end
    #     ^^^^^
    # --
    # : () -> Location?
    def begin_keyword_loc: () -> Location?

    # :category: Repository
    # Save the begin_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_begin_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Represents the statements within the begin block.
    #
    #     begin x end
    #           ^
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :call-seq:
    #   rescue_clause -> RescueNode | nil
    #
    # Represents the rescue clause within the begin block.
    #
    #     begin x; rescue y; end
    #              ^^^^^^^^
    # --
    # : () -> RescueNode?
    def rescue_clause: () -> RescueNode?

    # :call-seq:
    #   else_clause -> ElseNode | nil
    #
    # Represents the else clause within the begin block.
    #
    #     begin x; rescue y; else z; end
    #                        ^^^^^^
    # --
    # : () -> ElseNode?
    def else_clause: () -> ElseNode?

    # :call-seq:
    #   ensure_clause -> EnsureNode | nil
    #
    # Represents the ensure clause within the begin block.
    #
    #     begin x; ensure y; end
    #              ^^^^^^^^
    # --
    # : () -> EnsureNode?
    def ensure_clause: () -> EnsureNode?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location | nil
    #
    # Represents the Location of the `end` keyword.
    #
    #     begin x end
    #             ^^^
    # --
    # : () -> Location?
    def end_keyword_loc: () -> Location?

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   begin_keyword -> String | nil
    #
    # Slice the location of begin_keyword_loc from the source.
    # --
    # : () -> String?
    def begin_keyword: () -> String?

    # :call-seq:
    #   end_keyword -> String | nil
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String?
    def end_keyword: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a block argument using `&`.
  #
  #     bar(&args)
  #     ^^^^^^^^^^
  class BlockArgumentNode < Node
    @operator_loc: Location

    @expression: Prism::node?

    # Initialize a new BlockArgumentNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? expression, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? expression, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> BlockArgumentNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node?, ?operator_loc: Location) -> BlockArgumentNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node?, ?operator_loc: Location) -> BlockArgumentNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :block_argument_node
    def type: () -> :block_argument_node

    # See `Node.type`.
    # --
    # : () -> :block_argument_node
    def self.type: () -> :block_argument_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   expression -> Node | nil
    #
    # The expression that is being passed as a block argument. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo(&args)
    #         ^^^^^
    # --
    # : () -> Prism::node?
    def expression: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Represents the Location of the `&` operator.
    #
    #     foo(&args)
    #         ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a block local variable.
  #
  #     a { |; b| }
  #            ^
  class BlockLocalVariableNode < Node
    @name: Symbol

    # Initialize a new BlockLocalVariableNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> BlockLocalVariableNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> BlockLocalVariableNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> BlockLocalVariableNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :block_local_variable_node
    def type: () -> :block_local_variable_node

    # See `Node.type`.
    # --
    # : () -> :block_local_variable_node
    def self.type: () -> :block_local_variable_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a parameter name that has been repeated in the method signature
    # --
    # : () -> bool
    def repeated_parameter?: () -> bool

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the block local variable.
    #
    #     a { |; b| } # name `:b`
    #            ^
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a block of ruby code.
  #
  #     [1, 2, 3].each { |i| puts x }
  #                    ^^^^^^^^^^^^^^
  class BlockNode < Node
    @closing_loc: Location

    @opening_loc: Location

    @body: (StatementsNode | BeginNode)?

    @parameters: (BlockParametersNode | NumberedParametersNode | ItParametersNode)?

    @locals: Array[Symbol]

    # Initialize a new BlockNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, (BlockParametersNode | NumberedParametersNode | ItParametersNode)? parameters, (StatementsNode | BeginNode)? body, Location opening_loc, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, (BlockParametersNode | NumberedParametersNode | ItParametersNode)? parameters, (StatementsNode | BeginNode)? body, Location opening_loc, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> BlockNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?parameters: (BlockParametersNode | NumberedParametersNode | ItParametersNode)?, ?body: (StatementsNode | BeginNode)?, ?opening_loc: Location, ?closing_loc: Location) -> BlockNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?parameters: (BlockParametersNode | NumberedParametersNode | ItParametersNode)?, ?body: (StatementsNode | BeginNode)?, ?opening_loc: Location, ?closing_loc: Location) -> BlockNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :block_node
    def type: () -> :block_node

    # See `Node.type`.
    # --
    # : () -> :block_node
    def self.type: () -> :block_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   locals -> Array[Symbol]
    #
    # The local variables declared in the block.
    #
    #     [1, 2, 3].each { |i| puts x } # locals: [:i]
    #                       ^
    # --
    # : () -> Array[Symbol]
    def locals: () -> Array[Symbol]

    # :call-seq:
    #   parameters -> BlockParametersNode | NumberedParametersNode | ItParametersNode | nil
    #
    # The parameters of the block.
    #
    #     [1, 2, 3].each { |i| puts x }
    #                      ^^^
    #     [1, 2, 3].each { puts _1 }
    #                    ^^^^^^^^^^^
    #     [1, 2, 3].each { puts it }
    #                    ^^^^^^^^^^^
    # --
    # : () -> (BlockParametersNode | NumberedParametersNode | ItParametersNode)?
    def parameters: () -> (BlockParametersNode | NumberedParametersNode | ItParametersNode)?

    # :call-seq:
    #   body -> StatementsNode | BeginNode | nil
    #
    # The body of the block.
    #
    #     [1, 2, 3].each { |i| puts x }
    #                          ^^^^^^
    # --
    # : () -> (StatementsNode | BeginNode)?
    def body: () -> (StatementsNode | BeginNode)?

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Represents the Location of the opening `{` or `do`.
    #
    #     [1, 2, 3].each { |i| puts x }
    #                    ^
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Represents the Location of the closing `}` or `end`.
    #
    #     [1, 2, 3].each { |i| puts x }
    #                                 ^
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a block parameter of a method, block, or lambda definition.
  #
  #     def a(&b)
  #           ^^
  #     end
  class BlockParameterNode < Node
    @operator_loc: Location

    @name_loc: Location?

    @name: Symbol?

    # Initialize a new BlockParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> BlockParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> BlockParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> BlockParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :block_parameter_node
    def type: () -> :block_parameter_node

    # See `Node.type`.
    # --
    # : () -> :block_parameter_node
    def self.type: () -> :block_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a parameter name that has been repeated in the method signature
    # --
    # : () -> bool
    def repeated_parameter?: () -> bool

    # :call-seq:
    #   name -> Symbol | nil
    #
    # The name of the block parameter.
    #
    #     def a(&b) # name `:b`
    #            ^
    #     end
    # --
    # : () -> Symbol?
    def name: () -> Symbol?

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location | nil
    #
    # Represents the Location of the block parameter name.
    #
    #     def a(&b)
    #            ^
    # --
    # : () -> Location?
    def name_loc: () -> Location?

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_name_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Represents the Location of the `&` operator.
    #
    #     def a(&b)
    #           ^
    #     end
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a block's parameters declaration.
  #
  #     -> (a, b = 1; local) { }
  #        ^^^^^^^^^^^^^^^^^
  #
  #     foo do |a, b = 1; local|
  #            ^^^^^^^^^^^^^^^^^
  #     end
  class BlockParametersNode < Node
    @closing_loc: Location?

    @opening_loc: Location?

    @locals: Array[BlockLocalVariableNode]

    @parameters: ParametersNode?

    # Initialize a new BlockParametersNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ParametersNode? parameters, Array[BlockLocalVariableNode] locals, Location? opening_loc, Location? closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, ParametersNode? parameters, Array[BlockLocalVariableNode] locals, Location? opening_loc, Location? closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> BlockParametersNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?parameters: ParametersNode?, ?locals: Array[BlockLocalVariableNode], ?opening_loc: Location?, ?closing_loc: Location?) -> BlockParametersNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parameters: ParametersNode?, ?locals: Array[BlockLocalVariableNode], ?opening_loc: Location?, ?closing_loc: Location?) -> BlockParametersNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :block_parameters_node
    def type: () -> :block_parameters_node

    # See `Node.type`.
    # --
    # : () -> :block_parameters_node
    def self.type: () -> :block_parameters_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   parameters -> ParametersNode | nil
    #
    # Represents the parameters of the block.
    #
    #     -> (a, b = 1; local) { }
    #         ^^^^^^^^
    #
    #     foo do |a, b = 1; local|
    #             ^^^^^^^^
    #     end
    # --
    # : () -> ParametersNode?
    def parameters: () -> ParametersNode?

    # :call-seq:
    #   locals -> Array[BlockLocalVariableNode]
    #
    # Represents the local variables of the block.
    #
    #     -> (a, b = 1; local) { }
    #                   ^^^^^
    #
    #     foo do |a, b = 1; local|
    #                       ^^^^^
    #     end
    # --
    # : () -> Array[BlockLocalVariableNode]
    def locals: () -> Array[BlockLocalVariableNode]

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # Represents the opening Location of the block parameters.
    #
    #     -> (a, b = 1; local) { }
    #        ^
    #
    #     foo do |a, b = 1; local|
    #            ^
    #     end
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Represents the closing Location of the block parameters.
    #
    #     -> (a, b = 1; local) { }
    #                        ^
    #
    #     foo do |a, b = 1; local|
    #                            ^
    #     end
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `break` keyword.
  #
  #     break foo
  #     ^^^^^^^^^
  class BreakNode < Node
    @keyword_loc: Location

    @arguments: ArgumentsNode?

    # Initialize a new BreakNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ArgumentsNode? arguments, Location keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, ArgumentsNode? arguments, Location keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> BreakNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: ArgumentsNode?, ?keyword_loc: Location) -> BreakNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: ArgumentsNode?, ?keyword_loc: Location) -> BreakNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :break_node
    def type: () -> :break_node

    # See `Node.type`.
    # --
    # : () -> :break_node
    def self.type: () -> :break_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # The arguments to the break statement, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     break foo
    #           ^^^
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # The Location of the `break` keyword.
    #
    #     break foo
    #     ^^^^^
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&=` operator on a call.
  #
  #     foo.bar &&= value
  #     ^^^^^^^^^^^^^^^^^
  class CallAndWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @write_name: Symbol

    @read_name: Symbol

    @message_loc: Location?

    @call_operator_loc: Location?

    @receiver: Prism::node?

    # Initialize a new CallAndWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> CallAndWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node) -> CallAndWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node) -> CallAndWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :call_and_write_node
    def type: () -> :call_and_write_node

    # See `Node.type`.
    # --
    # : () -> :call_and_write_node
    def self.type: () -> :call_and_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node | nil
    #
    # The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo.bar &&= value
    #     ^^^
    # --
    # : () -> Prism::node?
    def receiver: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   call_operator_loc -> Location | nil
    #
    # Represents the Location of the call operator.
    #
    #     foo.bar &&= value
    #        ^
    # --
    # : () -> Location?
    def call_operator_loc: () -> Location?

    # :category: Repository
    # Save the call_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_call_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   message_loc -> Location | nil
    #
    # Represents the Location of the message.
    #
    #     foo.bar &&= value
    #         ^^^
    # --
    # : () -> Location?
    def message_loc: () -> Location?

    # :category: Repository
    # Save the message_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_message_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   read_name -> Symbol
    #
    # Represents the name of the method being called.
    #
    #     foo.bar &&= value # read_name `:bar`
    #         ^^^
    # --
    # : () -> Symbol
    def read_name: () -> Symbol

    # :call-seq:
    #   write_name -> Symbol
    #
    # Represents the name of the method being written to.
    #
    #     foo.bar &&= value # write_name `:bar=`
    #         ^^^
    # --
    # : () -> Symbol
    def write_name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Represents the Location of the operator.
    #
    #     foo.bar &&= value
    #             ^^^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Represents the value being assigned.
    #
    #     foo.bar &&= value
    #                 ^^^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   call_operator -> String | nil
    #
    # Slice the location of call_operator_loc from the source.
    # --
    # : () -> String?
    def call_operator: () -> String?

    # :call-seq:
    #   message -> String | nil
    #
    # Slice the location of message_loc from the source.
    # --
    # : () -> String?
    def message: () -> String?

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a method call, in all of the various forms that can take.
  #
  #     foo
  #     ^^^
  #
  #     foo()
  #     ^^^^^
  #
  #     +foo
  #     ^^^^
  #
  #     foo + bar
  #     ^^^^^^^^^
  #
  #     foo.bar
  #     ^^^^^^^
  #
  #     foo&.bar
  #     ^^^^^^^^
  class CallNode < Node
    @block: (BlockNode | BlockArgumentNode)?

    @equal_loc: Location?

    @closing_loc: Location?

    @arguments: ArgumentsNode?

    @opening_loc: Location?

    @message_loc: Location?

    @name: Symbol

    @call_operator_loc: Location?

    @receiver: Prism::node?

    # Initialize a new CallNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Symbol name, Location? message_loc, Location? opening_loc, ArgumentsNode? arguments, Location? closing_loc, Location? equal_loc, (BlockNode | BlockArgumentNode)? block) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Symbol name, Location? message_loc, Location? opening_loc, ArgumentsNode? arguments, Location? closing_loc, Location? equal_loc, (BlockNode | BlockArgumentNode)? block) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> CallNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?name: Symbol, ?message_loc: Location?, ?opening_loc: Location?, ?arguments: ArgumentsNode?, ?closing_loc: Location?, ?equal_loc: Location?, ?block: (BlockNode | BlockArgumentNode)?) -> CallNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?name: Symbol, ?message_loc: Location?, ?opening_loc: Location?, ?arguments: ArgumentsNode?, ?closing_loc: Location?, ?equal_loc: Location?, ?block: (BlockNode | BlockArgumentNode)?) -> CallNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :call_node
    def type: () -> :call_node

    # See `Node.type`.
    # --
    # : () -> :call_node
    def self.type: () -> :call_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node | nil
    #
    # The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo.bar
    #     ^^^
    #
    #     +foo
    #      ^^^
    #
    #     foo + bar
    #     ^^^
    # --
    # : () -> Prism::node?
    def receiver: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   call_operator_loc -> Location | nil
    #
    # Represents the Location of the call operator.
    #
    #     foo.bar
    #        ^
    #
    #     foo&.bar
    #        ^^
    # --
    # : () -> Location?
    def call_operator_loc: () -> Location?

    # :category: Repository
    # Save the call_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_call_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   name -> Symbol
    #
    # Represents the name of the method being called.
    #
    #     foo.bar # name `:foo`
    #     ^^^
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   message_loc -> Location | nil
    #
    # Represents the Location of the message.
    #
    #     foo.bar
    #         ^^^
    # --
    # : () -> Location?
    def message_loc: () -> Location?

    # :category: Repository
    # Save the message_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_message_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # Represents the Location of the left parenthesis.
    #
    #     foo(bar)
    #        ^
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Represents the arguments to the method call. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo(bar)
    #         ^^^
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Represents the Location of the right parenthesis.
    #
    #     foo(bar)
    #            ^
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   equal_loc -> Location | nil
    #
    # Represents the Location of the equal sign, in the case that this is an attribute write.
    #
    #     foo.bar = value
    #             ^
    #
    #     foo[bar] = value
    #              ^
    # --
    # : () -> Location?
    def equal_loc: () -> Location?

    # :category: Repository
    # Save the equal_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_equal_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   block -> BlockNode | BlockArgumentNode | nil
    #
    # Represents the block that is being passed to the method.
    #
    #     foo { |a| a }
    #         ^^^^^^^^^
    # --
    # : () -> (BlockNode | BlockArgumentNode)?
    def block: () -> (BlockNode | BlockArgumentNode)?

    # :call-seq:
    #   call_operator -> String | nil
    #
    # Slice the location of call_operator_loc from the source.
    # --
    # : () -> String?
    def call_operator: () -> String?

    # :call-seq:
    #   message -> String | nil
    #
    # Slice the location of message_loc from the source.
    # --
    # : () -> String?
    def message: () -> String?

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # :call-seq:
    #   equal -> String | nil
    #
    # Slice the location of equal_loc from the source.
    # --
    # : () -> String?
    def equal: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of an assignment operator on a call.
  #
  #     foo.bar += baz
  #     ^^^^^^^^^^^^^^
  class CallOperatorWriteNode < Node
    @value: Prism::node

    @binary_operator_loc: Location

    @binary_operator: Symbol

    @write_name: Symbol

    @read_name: Symbol

    @message_loc: Location?

    @call_operator_loc: Location?

    @receiver: Prism::node?

    # Initialize a new CallOperatorWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Symbol binary_operator, Location binary_operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Symbol binary_operator, Location binary_operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> CallOperatorWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?binary_operator: Symbol, ?binary_operator_loc: Location, ?value: Prism::node) -> CallOperatorWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?binary_operator: Symbol, ?binary_operator_loc: Location, ?value: Prism::node) -> CallOperatorWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :call_operator_write_node
    def type: () -> :call_operator_write_node

    # See `Node.type`.
    # --
    # : () -> :call_operator_write_node
    def self.type: () -> :call_operator_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node | nil
    #
    # The object that the method is being called on. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo.bar += value
    #     ^^^
    # --
    # : () -> Prism::node?
    def receiver: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   call_operator_loc -> Location | nil
    #
    # Represents the Location of the call operator.
    #
    #     foo.bar += value
    #        ^
    # --
    # : () -> Location?
    def call_operator_loc: () -> Location?

    # :category: Repository
    # Save the call_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_call_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   message_loc -> Location | nil
    #
    # Represents the Location of the message.
    #
    #     foo.bar += value
    #         ^^^
    # --
    # : () -> Location?
    def message_loc: () -> Location?

    # :category: Repository
    # Save the message_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_message_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   read_name -> Symbol
    #
    # Represents the name of the method being called.
    #
    #     foo.bar += value # read_name `:bar`
    #         ^^^
    # --
    # : () -> Symbol
    def read_name: () -> Symbol

    # :call-seq:
    #   write_name -> Symbol
    #
    # Represents the name of the method being written to.
    #
    #     foo.bar += value # write_name `:bar=`
    #         ^^^
    # --
    # : () -> Symbol
    def write_name: () -> Symbol

    # :call-seq:
    #   binary_operator -> Symbol
    #
    # Represents the binary operator being used.
    #
    #     foo.bar += value # binary_operator `:+`
    #             ^
    # --
    # : () -> Symbol
    def binary_operator: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   binary_operator_loc -> Location
    #
    # Represents the Location of the binary operator.
    #
    #     foo.bar += value
    #             ^^
    # --
    # : () -> Location
    def binary_operator_loc: () -> Location

    # :category: Repository
    # Save the binary_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_binary_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Represents the value being assigned.
    #
    #     foo.bar += value
    #                ^^^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   call_operator -> String | nil
    #
    # Slice the location of call_operator_loc from the source.
    # --
    # : () -> String?
    def call_operator: () -> String?

    # :call-seq:
    #   message -> String | nil
    #
    # Slice the location of message_loc from the source.
    # --
    # : () -> String?
    def message: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||=` operator on a call.
  #
  #     foo.bar ||= value
  #     ^^^^^^^^^^^^^^^^^
  class CallOrWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @write_name: Symbol

    @read_name: Symbol

    @message_loc: Location?

    @call_operator_loc: Location?

    @receiver: Prism::node?

    # Initialize a new CallOrWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> CallOrWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node) -> CallOrWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node) -> CallOrWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :call_or_write_node
    def type: () -> :call_or_write_node

    # See `Node.type`.
    # --
    # : () -> :call_or_write_node
    def self.type: () -> :call_or_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node | nil
    #
    # The object that the method is being called on. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo.bar ||= value
    #     ^^^
    # --
    # : () -> Prism::node?
    def receiver: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   call_operator_loc -> Location | nil
    #
    # Represents the Location of the call operator.
    #
    #     foo.bar ||= value
    #        ^
    # --
    # : () -> Location?
    def call_operator_loc: () -> Location?

    # :category: Repository
    # Save the call_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_call_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   message_loc -> Location | nil
    #
    # Represents the Location of the message.
    #
    #     foo.bar ||= value
    #         ^^^
    # --
    # : () -> Location?
    def message_loc: () -> Location?

    # :category: Repository
    # Save the message_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_message_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   read_name -> Symbol
    #
    # Represents the name of the method being called.
    #
    #     foo.bar ||= value # read_name `:bar`
    #         ^^^
    # --
    # : () -> Symbol
    def read_name: () -> Symbol

    # :call-seq:
    #   write_name -> Symbol
    #
    # Represents the name of the method being written to.
    #
    #     foo.bar ||= value # write_name `:bar=`
    #         ^^^
    # --
    # : () -> Symbol
    def write_name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Represents the Location of the operator.
    #
    #     foo.bar ||= value
    #             ^^^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Represents the value being assigned.
    #
    #     foo.bar ||= value
    #                 ^^^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   call_operator -> String | nil
    #
    # Slice the location of call_operator_loc from the source.
    # --
    # : () -> String?
    def call_operator: () -> String?

    # :call-seq:
    #   message -> String | nil
    #
    # Slice the location of message_loc from the source.
    # --
    # : () -> String?
    def message: () -> String?

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to a method call.
  #
  #     foo.bar, = 1
  #     ^^^^^^^
  #
  #     begin
  #     rescue => foo.bar
  #               ^^^^^^^
  #     end
  #
  #     for foo.bar in baz do end
  #         ^^^^^^^
  class CallTargetNode < Node
    @message_loc: Location

    @name: Symbol

    @call_operator_loc: Location

    @receiver: Prism::node

    # Initialize a new CallTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node receiver, Location call_operator_loc, Symbol name, Location message_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node receiver, Location call_operator_loc, Symbol name, Location message_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> CallTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node, ?call_operator_loc: Location, ?name: Symbol, ?message_loc: Location) -> CallTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node, ?call_operator_loc: Location, ?name: Symbol, ?message_loc: Location) -> CallTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :call_target_node
    def type: () -> :call_target_node

    # See `Node.type`.
    # --
    # : () -> :call_target_node
    def self.type: () -> :call_target_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node
    #
    # The object that the method is being called on. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo.bar = 1
    #     ^^^
    # --
    # : () -> Prism::node
    def receiver: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   call_operator_loc -> Location
    #
    # Represents the Location of the call operator.
    #
    #     foo.bar = 1
    #        ^
    # --
    # : () -> Location
    def call_operator_loc: () -> Location

    # :category: Repository
    # Save the call_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_call_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   name -> Symbol
    #
    # Represents the name of the method being called.
    #
    #     foo.bar = 1 # name `:foo`
    #     ^^^
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   message_loc -> Location
    #
    # Represents the Location of the message.
    #
    #     foo.bar = 1
    #         ^^^
    # --
    # : () -> Location
    def message_loc: () -> Location

    # :category: Repository
    # Save the message_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_message_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   call_operator -> String
    #
    # Slice the location of call_operator_loc from the source.
    # --
    # : () -> String
    def call_operator: () -> String

    # :call-seq:
    #   message -> String
    #
    # Slice the location of message_loc from the source.
    # --
    # : () -> String
    def message: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to a local variable in pattern matching.
  #
  #     foo => [bar => baz]
  #            ^^^^^^^^^^^^
  class CapturePatternNode < Node
    @operator_loc: Location

    @target: LocalVariableTargetNode

    @value: Prism::node

    # Initialize a new CapturePatternNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node value, LocalVariableTargetNode target, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node value, LocalVariableTargetNode target, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> CapturePatternNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?target: LocalVariableTargetNode, ?operator_loc: Location) -> CapturePatternNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?target: LocalVariableTargetNode, ?operator_loc: Location) -> CapturePatternNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :capture_pattern_node
    def type: () -> :capture_pattern_node

    # See `Node.type`.
    # --
    # : () -> :capture_pattern_node
    def self.type: () -> :capture_pattern_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   value -> Node
    #
    # Represents the value to capture.
    #
    #     foo => bar
    #            ^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   target -> LocalVariableTargetNode
    #
    # Represents the target of the capture.
    #
    #     foo => bar
    #     ^^^
    # --
    # : () -> LocalVariableTargetNode
    def target: () -> LocalVariableTargetNode

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Represents the Location of the `=>` operator.
    #
    #     foo => bar
    #         ^^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of a case statement for pattern matching.
  #
  #     case true
  #     in false
  #     end
  #     ^^^^^^^^^
  class CaseMatchNode < Node
    @end_keyword_loc: Location

    @case_keyword_loc: Location

    @else_clause: ElseNode?

    @conditions: Array[InNode]

    @predicate: Prism::node?

    # Initialize a new CaseMatchNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? predicate, Array[InNode] conditions, ElseNode? else_clause, Location case_keyword_loc, Location end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? predicate, Array[InNode] conditions, ElseNode? else_clause, Location case_keyword_loc, Location end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> CaseMatchNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?predicate: Prism::node?, ?conditions: Array[InNode], ?else_clause: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location) -> CaseMatchNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?predicate: Prism::node?, ?conditions: Array[InNode], ?else_clause: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location) -> CaseMatchNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :case_match_node
    def type: () -> :case_match_node

    # See `Node.type`.
    # --
    # : () -> :case_match_node
    def self.type: () -> :case_match_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   predicate -> Node | nil
    #
    # Represents the predicate of the case match. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     case true; in false; end
    #     ^^^^
    # --
    # : () -> Prism::node?
    def predicate: () -> Prism::node?

    # :call-seq:
    #   conditions -> Array[InNode]
    #
    # Represents the conditions of the case match.
    #
    #     case true; in false; end
    #                ^^^^^^^^
    # --
    # : () -> Array[InNode]
    def conditions: () -> Array[InNode]

    # :call-seq:
    #   else_clause -> ElseNode | nil
    #
    # Represents the else clause of the case match.
    #
    #     case true; in false; else; end
    #                          ^^^^
    # --
    # : () -> ElseNode?
    def else_clause: () -> ElseNode?

    # :category: Locations
    # :call-seq:
    #   case_keyword_loc -> Location
    #
    # Represents the Location of the `case` keyword.
    #
    #     case true; in false; end
    #     ^^^^
    # --
    # : () -> Location
    def case_keyword_loc: () -> Location

    # :category: Repository
    # Save the case_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_case_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location
    #
    # Represents the Location of the `end` keyword.
    #
    #     case true; in false; end
    #                          ^^^
    # --
    # : () -> Location
    def end_keyword_loc: () -> Location

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   case_keyword -> String
    #
    # Slice the location of case_keyword_loc from the source.
    # --
    # : () -> String
    def case_keyword: () -> String

    # :call-seq:
    #   end_keyword -> String
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String
    def end_keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of a case statement.
  #
  #     case true
  #     when false
  #     end
  #     ^^^^^^^^^^
  class CaseNode < Node
    @end_keyword_loc: Location

    @case_keyword_loc: Location

    @else_clause: ElseNode?

    @conditions: Array[WhenNode]

    @predicate: Prism::node?

    # Initialize a new CaseNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? predicate, Array[WhenNode] conditions, ElseNode? else_clause, Location case_keyword_loc, Location end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? predicate, Array[WhenNode] conditions, ElseNode? else_clause, Location case_keyword_loc, Location end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> CaseNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?predicate: Prism::node?, ?conditions: Array[WhenNode], ?else_clause: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location) -> CaseNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?predicate: Prism::node?, ?conditions: Array[WhenNode], ?else_clause: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location) -> CaseNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :case_node
    def type: () -> :case_node

    # See `Node.type`.
    # --
    # : () -> :case_node
    def self.type: () -> :case_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   predicate -> Node | nil
    #
    # Represents the predicate of the case statement. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     case true; when false; end
    #          ^^^^
    # --
    # : () -> Prism::node?
    def predicate: () -> Prism::node?

    # :call-seq:
    #   conditions -> Array[WhenNode]
    #
    # Represents the conditions of the case statement.
    #
    #     case true; when false; end
    #                ^^^^^^^^^^
    # --
    # : () -> Array[WhenNode]
    def conditions: () -> Array[WhenNode]

    # :call-seq:
    #   else_clause -> ElseNode | nil
    #
    # Represents the else clause of the case statement.
    #
    #     case true; when false; else; end
    #                            ^^^^
    # --
    # : () -> ElseNode?
    def else_clause: () -> ElseNode?

    # :category: Locations
    # :call-seq:
    #   case_keyword_loc -> Location
    #
    # Represents the Location of the `case` keyword.
    #
    #     case true; when false; end
    #     ^^^^
    # --
    # : () -> Location
    def case_keyword_loc: () -> Location

    # :category: Repository
    # Save the case_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_case_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location
    #
    # Represents the Location of the `end` keyword.
    #
    #     case true; when false; end
    #                            ^^^
    # --
    # : () -> Location
    def end_keyword_loc: () -> Location

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   case_keyword -> String
    #
    # Slice the location of case_keyword_loc from the source.
    # --
    # : () -> String
    def case_keyword: () -> String

    # :call-seq:
    #   end_keyword -> String
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String
    def end_keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a class declaration involving the `class` keyword.
  #
  #     class Foo end
  #     ^^^^^^^^^^^^^
  class ClassNode < Node
    @name: Symbol

    @end_keyword_loc: Location

    @body: (StatementsNode | BeginNode)?

    @superclass: Prism::node?

    @inheritance_operator_loc: Location?

    @constant_path: ConstantReadNode | ConstantPathNode | CallNode

    @class_keyword_loc: Location

    @locals: Array[Symbol]

    # Initialize a new ClassNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location class_keyword_loc, (ConstantReadNode | ConstantPathNode | CallNode) constant_path, Location? inheritance_operator_loc, Prism::node? superclass, (StatementsNode | BeginNode)? body, Location end_keyword_loc, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location class_keyword_loc, ConstantReadNode | ConstantPathNode | CallNode constant_path, Location? inheritance_operator_loc, Prism::node? superclass, (StatementsNode | BeginNode)? body, Location end_keyword_loc, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ClassNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?class_keyword_loc: Location, ?constant_path: (ConstantReadNode | ConstantPathNode | CallNode), ?inheritance_operator_loc: Location?, ?superclass: Prism::node?, ?body: (StatementsNode | BeginNode)?, ?end_keyword_loc: Location, ?name: Symbol) -> ClassNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?class_keyword_loc: Location, ?constant_path: ConstantReadNode | ConstantPathNode | CallNode, ?inheritance_operator_loc: Location?, ?superclass: Prism::node?, ?body: (StatementsNode | BeginNode)?, ?end_keyword_loc: Location, ?name: Symbol) -> ClassNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :class_node
    def type: () -> :class_node

    # See `Node.type`.
    # --
    # : () -> :class_node
    def self.type: () -> :class_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   locals -> Array[Symbol]
    #
    # Returns the `locals` attribute.
    # --
    # : () -> Array[Symbol]
    def locals: () -> Array[Symbol]

    # :category: Locations
    # :call-seq:
    #   class_keyword_loc -> Location
    #
    # Represents the Location of the `class` keyword.
    #
    #     class Foo end
    #     ^^^^^
    # --
    # : () -> Location
    def class_keyword_loc: () -> Location

    # :category: Repository
    # Save the class_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_class_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   constant_path -> ConstantReadNode | ConstantPathNode | CallNode
    #
    # Returns the `constant_path` attribute.
    # --
    # : () -> (ConstantReadNode | ConstantPathNode | CallNode)
    def constant_path: () -> (ConstantReadNode | ConstantPathNode | CallNode)

    # :category: Locations
    # :call-seq:
    #   inheritance_operator_loc -> Location | nil
    #
    # Represents the Location of the `<` operator.
    #
    #     class Foo < Bar
    #               ^
    # --
    # : () -> Location?
    def inheritance_operator_loc: () -> Location?

    # :category: Repository
    # Save the inheritance_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_inheritance_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   superclass -> Node | nil
    #
    # Represents the superclass of the class.
    #
    #     class Foo < Bar
    #                 ^^^
    # --
    # : () -> Prism::node?
    def superclass: () -> Prism::node?

    # :call-seq:
    #   body -> StatementsNode | BeginNode | nil
    #
    # Represents the body of the class.
    #
    #     class Foo
    #       foo
    #       ^^^
    # --
    # : () -> (StatementsNode | BeginNode)?
    def body: () -> (StatementsNode | BeginNode)?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location
    #
    # Represents the Location of the `end` keyword.
    #
    #     class Foo end
    #               ^^^
    # --
    # : () -> Location
    def end_keyword_loc: () -> Location

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the class.
    #
    #     class Foo end # name `:Foo`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :call-seq:
    #   class_keyword -> String
    #
    # Slice the location of class_keyword_loc from the source.
    # --
    # : () -> String
    def class_keyword: () -> String

    # :call-seq:
    #   inheritance_operator -> String | nil
    #
    # Slice the location of inheritance_operator_loc from the source.
    # --
    # : () -> String?
    def inheritance_operator: () -> String?

    # :call-seq:
    #   end_keyword -> String
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String
    def end_keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&=` operator for assignment to a class variable.
  #
  #     @@target &&= value
  #     ^^^^^^^^^^^^^^^^^^
  class ClassVariableAndWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new ClassVariableAndWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ClassVariableAndWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ClassVariableAndWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ClassVariableAndWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :class_variable_and_write_node
    def type: () -> :class_variable_and_write_node

    # See `Node.type`.
    # --
    # : () -> :class_variable_and_write_node
    def self.type: () -> :class_variable_and_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
    #
    #     @@target &&= value # name `:@@target`
    #     ^^^^^^^^
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Represents the Location of the variable name.
    #
    #     @@target &&= value
    #     ^^^^^^^^
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Represents the Location of the `&&=` operator.
    #
    #     @@target &&= value
    #              ^^^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Represents the value being assigned. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     @@target &&= value
    #                  ^^^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to a class variable using an operator that isn't `=`.
  #
  #     @@target += value
  #     ^^^^^^^^^^^^^^^^^
  class ClassVariableOperatorWriteNode < Node
    @binary_operator: Symbol

    @value: Prism::node

    @binary_operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new ClassVariableOperatorWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ClassVariableOperatorWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ClassVariableOperatorWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ClassVariableOperatorWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :class_variable_operator_write_node
    def type: () -> :class_variable_operator_write_node

    # See `Node.type`.
    # --
    # : () -> :class_variable_operator_write_node
    def self.type: () -> :class_variable_operator_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   binary_operator_loc -> Location
    #
    # Returns the Location represented by `binary_operator_loc`.
    # --
    # : () -> Location
    def binary_operator_loc: () -> Location

    # :category: Repository
    # Save the binary_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_binary_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   binary_operator -> Symbol
    #
    # Returns the `binary_operator` attribute.
    # --
    # : () -> Symbol
    def binary_operator: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||=` operator for assignment to a class variable.
  #
  #     @@target ||= value
  #     ^^^^^^^^^^^^^^^^^^
  class ClassVariableOrWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new ClassVariableOrWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ClassVariableOrWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ClassVariableOrWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ClassVariableOrWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :class_variable_or_write_node
    def type: () -> :class_variable_or_write_node

    # See `Node.type`.
    # --
    # : () -> :class_variable_or_write_node
    def self.type: () -> :class_variable_or_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents referencing a class variable.
  #
  #     @@foo
  #     ^^^^^
  class ClassVariableReadNode < Node
    @name: Symbol

    # Initialize a new ClassVariableReadNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ClassVariableReadNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ClassVariableReadNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ClassVariableReadNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :class_variable_read_node
    def type: () -> :class_variable_read_node

    # See `Node.type`.
    # --
    # : () -> :class_variable_read_node
    def self.type: () -> :class_variable_read_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
    #
    #     @@abc   # name `:@@abc`
    #
    #     @@_test # name `:@@_test`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a class variable in a context that doesn't have an explicit value.
  #
  #     @@foo, @@bar = baz
  #     ^^^^^  ^^^^^
  class ClassVariableTargetNode < Node
    @name: Symbol

    # Initialize a new ClassVariableTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ClassVariableTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ClassVariableTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ClassVariableTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :class_variable_target_node
    def type: () -> :class_variable_target_node

    # See `Node.type`.
    # --
    # : () -> :class_variable_target_node
    def self.type: () -> :class_variable_target_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a class variable.
  #
  #     @@foo = 1
  #     ^^^^^^^^^
  class ClassVariableWriteNode < Node
    @operator_loc: Location

    @value: Prism::node

    @name_loc: Location

    @name: Symbol

    # Initialize a new ClassVariableWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ClassVariableWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> ClassVariableWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> ClassVariableWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :class_variable_write_node
    def type: () -> :class_variable_write_node

    # See `Node.type`.
    # --
    # : () -> :class_variable_write_node
    def self.type: () -> :class_variable_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
    #
    #     @@abc = 123     # name `@@abc`
    #
    #     @@_test = :test # name `@@_test`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # The Location of the variable name.
    #
    #     @@foo = :bar
    #     ^^^^^
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # The value to write to the class variable. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     @@foo = :bar
    #             ^^^^
    #
    #     @@_xyz = 123
    #              ^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `=` operator.
    #
    #     @@foo = :bar
    #           ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&=` operator for assignment to a constant.
  #
  #     Target &&= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantAndWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new ConstantAndWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantAndWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ConstantAndWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ConstantAndWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_and_write_node
    def type: () -> :constant_and_write_node

    # See `Node.type`.
    # --
    # : () -> :constant_and_write_node
    def self.type: () -> :constant_and_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to a constant using an operator that isn't `=`.
  #
  #     Target += value
  #     ^^^^^^^^^^^^^^^
  class ConstantOperatorWriteNode < Node
    @binary_operator: Symbol

    @value: Prism::node

    @binary_operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new ConstantOperatorWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantOperatorWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ConstantOperatorWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ConstantOperatorWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_operator_write_node
    def type: () -> :constant_operator_write_node

    # See `Node.type`.
    # --
    # : () -> :constant_operator_write_node
    def self.type: () -> :constant_operator_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   binary_operator_loc -> Location
    #
    # Returns the Location represented by `binary_operator_loc`.
    # --
    # : () -> Location
    def binary_operator_loc: () -> Location

    # :category: Repository
    # Save the binary_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_binary_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   binary_operator -> Symbol
    #
    # Returns the `binary_operator` attribute.
    # --
    # : () -> Symbol
    def binary_operator: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||=` operator for assignment to a constant.
  #
  #     Target ||= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantOrWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new ConstantOrWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantOrWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ConstantOrWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ConstantOrWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_or_write_node
    def type: () -> :constant_or_write_node

    # See `Node.type`.
    # --
    # : () -> :constant_or_write_node
    def self.type: () -> :constant_or_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&=` operator for assignment to a constant path.
  #
  #     Parent::Child &&= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathAndWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @target: ConstantPathNode

    # Initialize a new ConstantPathAndWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantPathAndWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathAndWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathAndWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_path_and_write_node
    def type: () -> :constant_path_and_write_node

    # See `Node.type`.
    # --
    # : () -> :constant_path_and_write_node
    def self.type: () -> :constant_path_and_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   target -> ConstantPathNode
    #
    # Returns the `target` attribute.
    # --
    # : () -> ConstantPathNode
    def target: () -> ConstantPathNode

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents accessing a constant through a path of `::` operators.
  #
  #     Foo::Bar
  #     ^^^^^^^^
  class ConstantPathNode < Node
    @name_loc: Location

    @delimiter_loc: Location

    @name: Symbol?

    @parent: Prism::node?

    # Initialize a new ConstantPathNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? parent, Symbol? name, Location delimiter_loc, Location name_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? parent, Symbol? name, Location delimiter_loc, Location name_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantPathNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?parent: Prism::node?, ?name: Symbol?, ?delimiter_loc: Location, ?name_loc: Location) -> ConstantPathNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parent: Prism::node?, ?name: Symbol?, ?delimiter_loc: Location, ?name_loc: Location) -> ConstantPathNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_path_node
    def type: () -> :constant_path_node

    # See `Node.type`.
    # --
    # : () -> :constant_path_node
    def self.type: () -> :constant_path_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   parent -> Node | nil
    #
    # The left-hand node of the path, if present. It can be `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression). It will be `nil` when the constant lookup is at the root of the module tree.
    #
    #     Foo::Bar
    #     ^^^
    #
    #     self::Test
    #     ^^^^
    #
    #     a.b::C
    #     ^^^
    # --
    # : () -> Prism::node?
    def parent: () -> Prism::node?

    # :call-seq:
    #   name -> Symbol | nil
    #
    # The name of the constant being accessed. This could be `nil` in the event of a syntax error.
    # --
    # : () -> Symbol?
    def name: () -> Symbol?

    # :category: Locations
    # :call-seq:
    #   delimiter_loc -> Location
    #
    # The Location of the `::` delimiter.
    #
    #     ::Foo
    #     ^^
    #
    #     One::Two
    #        ^^
    # --
    # : () -> Location
    def delimiter_loc: () -> Location

    # :category: Repository
    # Save the delimiter_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_delimiter_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # The Location of the name of the constant.
    #
    #     ::Foo
    #       ^^^
    #
    #     One::Two
    #          ^^^
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   delimiter -> String
    #
    # Slice the location of delimiter_loc from the source.
    # --
    # : () -> String
    def delimiter: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to a constant path using an operator that isn't `=`.
  #
  #     Parent::Child += value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOperatorWriteNode < Node
    @binary_operator: Symbol

    @value: Prism::node

    @binary_operator_loc: Location

    @target: ConstantPathNode

    # Initialize a new ConstantPathOperatorWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantPathOperatorWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ConstantPathOperatorWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ConstantPathOperatorWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_path_operator_write_node
    def type: () -> :constant_path_operator_write_node

    # See `Node.type`.
    # --
    # : () -> :constant_path_operator_write_node
    def self.type: () -> :constant_path_operator_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   target -> ConstantPathNode
    #
    # Returns the `target` attribute.
    # --
    # : () -> ConstantPathNode
    def target: () -> ConstantPathNode

    # :category: Locations
    # :call-seq:
    #   binary_operator_loc -> Location
    #
    # Returns the Location represented by `binary_operator_loc`.
    # --
    # : () -> Location
    def binary_operator_loc: () -> Location

    # :category: Repository
    # Save the binary_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_binary_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   binary_operator -> Symbol
    #
    # Returns the `binary_operator` attribute.
    # --
    # : () -> Symbol
    def binary_operator: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||=` operator for assignment to a constant path.
  #
  #     Parent::Child ||= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOrWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @target: ConstantPathNode

    # Initialize a new ConstantPathOrWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantPathOrWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathOrWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathOrWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_path_or_write_node
    def type: () -> :constant_path_or_write_node

    # See `Node.type`.
    # --
    # : () -> :constant_path_or_write_node
    def self.type: () -> :constant_path_or_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   target -> ConstantPathNode
    #
    # Returns the `target` attribute.
    # --
    # : () -> ConstantPathNode
    def target: () -> ConstantPathNode

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a constant path in a context that doesn't have an explicit value.
  #
  #     Foo::Foo, Bar::Bar = baz
  #     ^^^^^^^^  ^^^^^^^^
  class ConstantPathTargetNode < Node
    @name_loc: Location

    @delimiter_loc: Location

    @name: Symbol?

    @parent: Prism::node?

    # Initialize a new ConstantPathTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? parent, Symbol? name, Location delimiter_loc, Location name_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? parent, Symbol? name, Location delimiter_loc, Location name_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantPathTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?parent: Prism::node?, ?name: Symbol?, ?delimiter_loc: Location, ?name_loc: Location) -> ConstantPathTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parent: Prism::node?, ?name: Symbol?, ?delimiter_loc: Location, ?name_loc: Location) -> ConstantPathTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_path_target_node
    def type: () -> :constant_path_target_node

    # See `Node.type`.
    # --
    # : () -> :constant_path_target_node
    def self.type: () -> :constant_path_target_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   parent -> Node | nil
    #
    # Returns the `parent` attribute.
    # --
    # : () -> Prism::node?
    def parent: () -> Prism::node?

    # :call-seq:
    #   name -> Symbol | nil
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol?
    def name: () -> Symbol?

    # :category: Locations
    # :call-seq:
    #   delimiter_loc -> Location
    #
    # Returns the Location represented by `delimiter_loc`.
    # --
    # : () -> Location
    def delimiter_loc: () -> Location

    # :category: Repository
    # Save the delimiter_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_delimiter_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   delimiter -> String
    #
    # Slice the location of delimiter_loc from the source.
    # --
    # : () -> String
    def delimiter: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a constant path.
  #
  #     ::Foo = 1
  #     ^^^^^^^^^
  #
  #     Foo::Bar = 1
  #     ^^^^^^^^^^^^
  #
  #     ::Foo::Bar = 1
  #     ^^^^^^^^^^^^^^
  class ConstantPathWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @target: ConstantPathNode

    # Initialize a new ConstantPathWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantPathWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_path_write_node
    def type: () -> :constant_path_write_node

    # See `Node.type`.
    # --
    # : () -> :constant_path_write_node
    def self.type: () -> :constant_path_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   target -> ConstantPathNode
    #
    # A node representing the constant path being written to.
    #
    #     Foo::Bar = 1
    #     ^^^^^^^^
    #
    #     ::Foo = :abc
    #     ^^^^^
    # --
    # : () -> ConstantPathNode
    def target: () -> ConstantPathNode

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `=` operator.
    #
    #     ::ABC = 123
    #           ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # The value to write to the constant path. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     FOO::BAR = :abc
    #                ^^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents referencing a constant.
  #
  #     Foo
  #     ^^^
  class ConstantReadNode < Node
    @name: Symbol

    # Initialize a new ConstantReadNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantReadNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ConstantReadNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ConstantReadNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_read_node
    def type: () -> :constant_read_node

    # See `Node.type`.
    # --
    # : () -> :constant_read_node
    def self.type: () -> :constant_read_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).
    #
    #     X              # name `:X`
    #
    #     SOME_CONSTANT  # name `:SOME_CONSTANT`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a constant in a context that doesn't have an explicit value.
  #
  #     Foo, Bar = baz
  #     ^^^  ^^^
  class ConstantTargetNode < Node
    @name: Symbol

    # Initialize a new ConstantTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ConstantTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ConstantTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_target_node
    def type: () -> :constant_target_node

    # See `Node.type`.
    # --
    # : () -> :constant_target_node
    def self.type: () -> :constant_target_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a constant.
  #
  #     Foo = 1
  #     ^^^^^^^
  class ConstantWriteNode < Node
    @operator_loc: Location

    @value: Prism::node

    @name_loc: Location

    @name: Symbol

    # Initialize a new ConstantWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ConstantWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> ConstantWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> ConstantWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :constant_write_node
    def type: () -> :constant_write_node

    # See `Node.type`.
    # --
    # : () -> :constant_write_node
    def self.type: () -> :constant_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).
    #
    #     Foo = :bar # name `:Foo`
    #
    #     XYZ = 1    # name `:XYZ`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # The Location of the constant name.
    #
    #     FOO = 1
    #     ^^^
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # The value to write to the constant. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     FOO = :bar
    #           ^^^^
    #
    #     MyClass = Class.new
    #               ^^^^^^^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `=` operator.
    #
    #     FOO = :bar
    #         ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a method definition.
  #
  #     def method
  #     end
  #     ^^^^^^^^^^
  class DefNode < Node
    @end_keyword_loc: Location?

    @equal_loc: Location?

    @rparen_loc: Location?

    @lparen_loc: Location?

    @operator_loc: Location?

    @def_keyword_loc: Location

    @locals: Array[Symbol]

    @body: (StatementsNode | BeginNode)?

    @parameters: ParametersNode?

    @receiver: Prism::node?

    @name_loc: Location

    @name: Symbol

    # Initialize a new DefNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node? receiver, ParametersNode? parameters, (StatementsNode | BeginNode)? body, Array[Symbol] locals, Location def_keyword_loc, Location? operator_loc, Location? lparen_loc, Location? rparen_loc, Location? equal_loc, Location? end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node? receiver, ParametersNode? parameters, (StatementsNode | BeginNode)? body, Array[Symbol] locals, Location def_keyword_loc, Location? operator_loc, Location? lparen_loc, Location? rparen_loc, Location? equal_loc, Location? end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> DefNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?receiver: Prism::node?, ?parameters: ParametersNode?, ?body: (StatementsNode | BeginNode)?, ?locals: Array[Symbol], ?def_keyword_loc: Location, ?operator_loc: Location?, ?lparen_loc: Location?, ?rparen_loc: Location?, ?equal_loc: Location?, ?end_keyword_loc: Location?) -> DefNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?receiver: Prism::node?, ?parameters: ParametersNode?, ?body: (StatementsNode | BeginNode)?, ?locals: Array[Symbol], ?def_keyword_loc: Location, ?operator_loc: Location?, ?lparen_loc: Location?, ?rparen_loc: Location?, ?equal_loc: Location?, ?end_keyword_loc: Location?) -> DefNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :def_node
    def type: () -> :def_node

    # See `Node.type`.
    # --
    # : () -> :def_node
    def self.type: () -> :def_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   receiver -> Node | nil
    #
    # Returns the `receiver` attribute.
    # --
    # : () -> Prism::node?
    def receiver: () -> Prism::node?

    # :call-seq:
    #   parameters -> ParametersNode | nil
    #
    # Returns the `parameters` attribute.
    # --
    # : () -> ParametersNode?
    def parameters: () -> ParametersNode?

    # :call-seq:
    #   body -> StatementsNode | BeginNode | nil
    #
    # Returns the `body` attribute.
    # --
    # : () -> (StatementsNode | BeginNode)?
    def body: () -> (StatementsNode | BeginNode)?

    # :call-seq:
    #   locals -> Array[Symbol]
    #
    # Returns the `locals` attribute.
    # --
    # : () -> Array[Symbol]
    def locals: () -> Array[Symbol]

    # :category: Locations
    # :call-seq:
    #   def_keyword_loc -> Location
    #
    # Returns the Location represented by `def_keyword_loc`.
    # --
    # : () -> Location
    def def_keyword_loc: () -> Location

    # :category: Repository
    # Save the def_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_def_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location | nil
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location?
    def operator_loc: () -> Location?

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   lparen_loc -> Location | nil
    #
    # Returns the Location represented by `lparen_loc`.
    # --
    # : () -> Location?
    def lparen_loc: () -> Location?

    # :category: Repository
    # Save the lparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_lparen_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   rparen_loc -> Location | nil
    #
    # Returns the Location represented by `rparen_loc`.
    # --
    # : () -> Location?
    def rparen_loc: () -> Location?

    # :category: Repository
    # Save the rparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_rparen_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   equal_loc -> Location | nil
    #
    # Returns the Location represented by `equal_loc`.
    # --
    # : () -> Location?
    def equal_loc: () -> Location?

    # :category: Repository
    # Save the equal_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_equal_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location | nil
    #
    # Returns the Location represented by `end_keyword_loc`.
    # --
    # : () -> Location?
    def end_keyword_loc: () -> Location?

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   def_keyword -> String
    #
    # Slice the location of def_keyword_loc from the source.
    # --
    # : () -> String
    def def_keyword: () -> String

    # :call-seq:
    #   operator -> String | nil
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String?
    def operator: () -> String?

    # :call-seq:
    #   lparen -> String | nil
    #
    # Slice the location of lparen_loc from the source.
    # --
    # : () -> String?
    def lparen: () -> String?

    # :call-seq:
    #   rparen -> String | nil
    #
    # Slice the location of rparen_loc from the source.
    # --
    # : () -> String?
    def rparen: () -> String?

    # :call-seq:
    #   equal -> String | nil
    #
    # Slice the location of equal_loc from the source.
    # --
    # : () -> String?
    def equal: () -> String?

    # :call-seq:
    #   end_keyword -> String | nil
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String?
    def end_keyword: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `defined?` keyword.
  #
  #     defined?(a)
  #     ^^^^^^^^^^^
  class DefinedNode < Node
    @keyword_loc: Location

    @rparen_loc: Location?

    @value: Prism::node

    @lparen_loc: Location?

    # Initialize a new DefinedNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location? lparen_loc, Prism::node value, Location? rparen_loc, Location keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? lparen_loc, Prism::node value, Location? rparen_loc, Location keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> DefinedNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?lparen_loc: Location?, ?value: Prism::node, ?rparen_loc: Location?, ?keyword_loc: Location) -> DefinedNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lparen_loc: Location?, ?value: Prism::node, ?rparen_loc: Location?, ?keyword_loc: Location) -> DefinedNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :defined_node
    def type: () -> :defined_node

    # See `Node.type`.
    # --
    # : () -> :defined_node
    def self.type: () -> :defined_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   lparen_loc -> Location | nil
    #
    # Returns the Location represented by `lparen_loc`.
    # --
    # : () -> Location?
    def lparen_loc: () -> Location?

    # :category: Repository
    # Save the lparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_lparen_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   rparen_loc -> Location | nil
    #
    # Returns the Location represented by `rparen_loc`.
    # --
    # : () -> Location?
    def rparen_loc: () -> Location?

    # :category: Repository
    # Save the rparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_rparen_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   lparen -> String | nil
    #
    # Slice the location of lparen_loc from the source.
    # --
    # : () -> String?
    def lparen: () -> String?

    # :call-seq:
    #   rparen -> String | nil
    #
    # Slice the location of rparen_loc from the source.
    # --
    # : () -> String?
    def rparen: () -> String?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an `else` clause in a `case`, `if`, or `unless` statement.
  #
  #     if a then b else c end
  #                 ^^^^^^^^^^
  class ElseNode < Node
    @end_keyword_loc: Location?

    @statements: StatementsNode?

    @else_keyword_loc: Location

    # Initialize a new ElseNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location else_keyword_loc, StatementsNode? statements, Location? end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location else_keyword_loc, StatementsNode? statements, Location? end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ElseNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?else_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location?) -> ElseNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?else_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location?) -> ElseNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :else_node
    def type: () -> :else_node

    # See `Node.type`.
    # --
    # : () -> :else_node
    def self.type: () -> :else_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   else_keyword_loc -> Location
    #
    # Returns the Location represented by `else_keyword_loc`.
    # --
    # : () -> Location
    def else_keyword_loc: () -> Location

    # :category: Repository
    # Save the else_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_else_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location | nil
    #
    # Returns the Location represented by `end_keyword_loc`.
    # --
    # : () -> Location?
    def end_keyword_loc: () -> Location?

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   else_keyword -> String
    #
    # Slice the location of else_keyword_loc from the source.
    # --
    # : () -> String
    def else_keyword: () -> String

    # :call-seq:
    #   end_keyword -> String | nil
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String?
    def end_keyword: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an interpolated set of statements.
  #
  #     "foo #{bar}"
  #          ^^^^^^
  class EmbeddedStatementsNode < Node
    @closing_loc: Location

    @statements: StatementsNode?

    @opening_loc: Location

    # Initialize a new EmbeddedStatementsNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, StatementsNode? statements, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, StatementsNode? statements, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> EmbeddedStatementsNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?statements: StatementsNode?, ?closing_loc: Location) -> EmbeddedStatementsNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?statements: StatementsNode?, ?closing_loc: Location) -> EmbeddedStatementsNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :embedded_statements_node
    def type: () -> :embedded_statements_node

    # See `Node.type`.
    # --
    # : () -> :embedded_statements_node
    def self.type: () -> :embedded_statements_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an interpolated variable.
  #
  #     "foo #@bar"
  #          ^^^^^
  class EmbeddedVariableNode < Node
    @variable: InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode

    @operator_loc: Location

    # Initialize a new EmbeddedVariableNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, (InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode) variable) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode variable) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> EmbeddedVariableNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?variable: (InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode)) -> EmbeddedVariableNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?variable: InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode) -> EmbeddedVariableNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :embedded_variable_node
    def type: () -> :embedded_variable_node

    # See `Node.type`.
    # --
    # : () -> :embedded_variable_node
    def self.type: () -> :embedded_variable_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   variable -> InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode
    #
    # Returns the `variable` attribute.
    # --
    # : () -> (InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode)
    def variable: () -> (InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode)

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an `ensure` clause in a `begin` statement.
  #
  #     begin
  #       foo
  #     ensure
  #     ^^^^^^
  #       bar
  #     end
  class EnsureNode < Node
    @end_keyword_loc: Location

    @statements: StatementsNode?

    @ensure_keyword_loc: Location

    # Initialize a new EnsureNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location ensure_keyword_loc, StatementsNode? statements, Location end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location ensure_keyword_loc, StatementsNode? statements, Location end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> EnsureNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?ensure_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location) -> EnsureNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?ensure_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location) -> EnsureNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :ensure_node
    def type: () -> :ensure_node

    # See `Node.type`.
    # --
    # : () -> :ensure_node
    def self.type: () -> :ensure_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   ensure_keyword_loc -> Location
    #
    # Returns the Location represented by `ensure_keyword_loc`.
    # --
    # : () -> Location
    def ensure_keyword_loc: () -> Location

    # :category: Repository
    # Save the ensure_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_ensure_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location
    #
    # Returns the Location represented by `end_keyword_loc`.
    # --
    # : () -> Location
    def end_keyword_loc: () -> Location

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   ensure_keyword -> String
    #
    # Slice the location of ensure_keyword_loc from the source.
    # --
    # : () -> String
    def ensure_keyword: () -> String

    # :call-seq:
    #   end_keyword -> String
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String
    def end_keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the literal `false` keyword.
  #
  #     false
  #     ^^^^^
  class FalseNode < Node
    # Initialize a new FalseNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> FalseNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> FalseNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> FalseNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :false_node
    def type: () -> :false_node

    # See `Node.type`.
    # --
    # : () -> :false_node
    def self.type: () -> :false_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a find pattern in pattern matching.
  #
  #     foo in *bar, baz, *qux
  #            ^^^^^^^^^^^^^^^
  #
  #     foo in [*bar, baz, *qux]
  #            ^^^^^^^^^^^^^^^^^
  #
  #     foo in Foo(*bar, baz, *qux)
  #            ^^^^^^^^^^^^^^^^^^^^
  #
  #     foo => *bar, baz, *qux
  #            ^^^^^^^^^^^^^^^
  class FindPatternNode < Node
    @closing_loc: Location?

    @opening_loc: Location?

    @right: SplatNode | MissingNode

    @requireds: Array[Prism::node]

    @left: SplatNode

    @constant: (ConstantPathNode | ConstantReadNode)?

    # Initialize a new FindPatternNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (ConstantPathNode | ConstantReadNode)? constant, SplatNode left, Array[Prism::node] requireds, (SplatNode | MissingNode) right, Location? opening_loc, Location? closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, (ConstantPathNode | ConstantReadNode)? constant, SplatNode left, Array[Prism::node] requireds, SplatNode | MissingNode right, Location? opening_loc, Location? closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> FindPatternNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: (ConstantPathNode | ConstantReadNode)?, ?left: SplatNode, ?requireds: Array[Prism::node], ?right: (SplatNode | MissingNode), ?opening_loc: Location?, ?closing_loc: Location?) -> FindPatternNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: (ConstantPathNode | ConstantReadNode)?, ?left: SplatNode, ?requireds: Array[Prism::node], ?right: SplatNode | MissingNode, ?opening_loc: Location?, ?closing_loc: Location?) -> FindPatternNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :find_pattern_node
    def type: () -> :find_pattern_node

    # See `Node.type`.
    # --
    # : () -> :find_pattern_node
    def self.type: () -> :find_pattern_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   constant -> ConstantPathNode | ConstantReadNode | nil
    #
    # Represents the optional constant preceding the pattern
    #
    #     foo in Foo(*bar, baz, *qux)
    #            ^^^
    # --
    # : () -> (ConstantPathNode | ConstantReadNode)?
    def constant: () -> (ConstantPathNode | ConstantReadNode)?

    # :call-seq:
    #   left -> SplatNode
    #
    # Represents the first wildcard node in the pattern.
    #
    #     foo in *bar, baz, *qux
    #            ^^^^
    #
    #     foo in Foo(*bar, baz, *qux)
    #                ^^^^
    # --
    # : () -> SplatNode
    def left: () -> SplatNode

    # :call-seq:
    #   requireds -> Array[Node]
    #
    # Represents the nodes in between the wildcards.
    #
    #     foo in *bar, baz, *qux
    #                  ^^^
    #
    #     foo in Foo(*bar, baz, 1, *qux)
    #                      ^^^^^^
    # --
    # : () -> Array[Prism::node]
    def requireds: () -> Array[Prism::node]

    # :call-seq:
    #   right -> SplatNode | MissingNode
    #
    # Represents the second wildcard node in the pattern.
    #
    #     foo in *bar, baz, *qux
    #                       ^^^^
    #
    #     foo in Foo(*bar, baz, *qux)
    #                           ^^^^
    # --
    # : () -> (SplatNode | MissingNode)
    def right: () -> (SplatNode | MissingNode)

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # The Location of the opening brace.
    #
    #     foo in [*bar, baz, *qux]
    #            ^
    #
    #     foo in Foo(*bar, baz, *qux)
    #               ^
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # The Location of the closing brace.
    #
    #     foo in [*bar, baz, *qux]
    #                            ^
    #
    #     foo in Foo(*bar, baz, *qux)
    #                               ^
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `..` or `...` operators to create flip flops.
  #
  #     baz if foo .. bar
  #            ^^^^^^^^^^
  class FlipFlopNode < Node
    @operator_loc: Location

    @right: Prism::node?

    @left: Prism::node?

    # Initialize a new FlipFlopNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? left, Prism::node? right, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? left, Prism::node? right, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> FlipFlopNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location) -> FlipFlopNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location) -> FlipFlopNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :flip_flop_node
    def type: () -> :flip_flop_node

    # See `Node.type`.
    # --
    # : () -> :flip_flop_node
    def self.type: () -> :flip_flop_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # ... operator
    # --
    # : () -> bool
    def exclude_end?: () -> bool

    # :call-seq:
    #   left -> Node | nil
    #
    # Returns the `left` attribute.
    # --
    # : () -> Prism::node?
    def left: () -> Prism::node?

    # :call-seq:
    #   right -> Node | nil
    #
    # Returns the `right` attribute.
    # --
    # : () -> Prism::node?
    def right: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a floating point number literal.
  #
  #     1.0
  #     ^^^
  class FloatNode < Node
    @value: Float

    # Initialize a new FloatNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Float value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Float value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> FloatNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Float) -> FloatNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Float) -> FloatNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :float_node
    def type: () -> :float_node

    # See `Node.type`.
    # --
    # : () -> :float_node
    def self.type: () -> :float_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   value -> Float
    #
    # The value of the floating point number as a Float.
    # --
    # : () -> Float
    def value: () -> Float

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `for` keyword.
  #
  #     for i in a end
  #     ^^^^^^^^^^^^^^
  class ForNode < Node
    @end_keyword_loc: Location

    @do_keyword_loc: Location?

    @in_keyword_loc: Location

    @for_keyword_loc: Location

    @statements: StatementsNode?

    @collection: Prism::node

    @index: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode

    # Initialize a new ForNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode) index, Prism::node collection, StatementsNode? statements, Location for_keyword_loc, Location in_keyword_loc, Location? do_keyword_loc, Location end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode index, Prism::node collection, StatementsNode? statements, Location for_keyword_loc, Location in_keyword_loc, Location? do_keyword_loc, Location end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ForNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?index: (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode), ?collection: Prism::node, ?statements: StatementsNode?, ?for_keyword_loc: Location, ?in_keyword_loc: Location, ?do_keyword_loc: Location?, ?end_keyword_loc: Location) -> ForNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?index: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode, ?collection: Prism::node, ?statements: StatementsNode?, ?for_keyword_loc: Location, ?in_keyword_loc: Location, ?do_keyword_loc: Location?, ?end_keyword_loc: Location) -> ForNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :for_node
    def type: () -> :for_node

    # See `Node.type`.
    # --
    # : () -> :for_node
    def self.type: () -> :for_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   index -> LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode
    #
    # The index expression for `for` loops.
    #
    #     for i in a end
    #         ^
    # --
    # : () -> (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)
    def index: () -> (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)

    # :call-seq:
    #   collection -> Node
    #
    # The collection to iterate over.
    #
    #     for i in a end
    #              ^
    # --
    # : () -> Prism::node
    def collection: () -> Prism::node

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Represents the body of statements to execute for each iteration of the loop.
    #
    #     for i in a
    #       foo(i)
    #       ^^^^^^
    #     end
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :category: Locations
    # :call-seq:
    #   for_keyword_loc -> Location
    #
    # The Location of the `for` keyword.
    #
    #     for i in a end
    #     ^^^
    # --
    # : () -> Location
    def for_keyword_loc: () -> Location

    # :category: Repository
    # Save the for_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_for_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   in_keyword_loc -> Location
    #
    # The Location of the `in` keyword.
    #
    #     for i in a end
    #           ^^
    # --
    # : () -> Location
    def in_keyword_loc: () -> Location

    # :category: Repository
    # Save the in_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_in_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   do_keyword_loc -> Location | nil
    #
    # The Location of the `do` keyword, if present.
    #
    #     for i in a do end
    #                ^^
    # --
    # : () -> Location?
    def do_keyword_loc: () -> Location?

    # :category: Repository
    # Save the do_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_do_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location
    #
    # The Location of the `end` keyword.
    #
    #     for i in a end
    #                ^^^
    # --
    # : () -> Location
    def end_keyword_loc: () -> Location

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   for_keyword -> String
    #
    # Slice the location of for_keyword_loc from the source.
    # --
    # : () -> String
    def for_keyword: () -> String

    # :call-seq:
    #   in_keyword -> String
    #
    # Slice the location of in_keyword_loc from the source.
    # --
    # : () -> String
    def in_keyword: () -> String

    # :call-seq:
    #   do_keyword -> String | nil
    #
    # Slice the location of do_keyword_loc from the source.
    # --
    # : () -> String?
    def do_keyword: () -> String?

    # :call-seq:
    #   end_keyword -> String
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String
    def end_keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents forwarding all arguments to this method to another method.
  #
  #     def foo(...)
  #       bar(...)
  #           ^^^
  #     end
  class ForwardingArgumentsNode < Node
    # Initialize a new ForwardingArgumentsNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ForwardingArgumentsNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> ForwardingArgumentsNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ForwardingArgumentsNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :forwarding_arguments_node
    def type: () -> :forwarding_arguments_node

    # See `Node.type`.
    # --
    # : () -> :forwarding_arguments_node
    def self.type: () -> :forwarding_arguments_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the forwarding parameter in a method, block, or lambda declaration.
  #
  #     def foo(...)
  #             ^^^
  #     end
  class ForwardingParameterNode < Node
    # Initialize a new ForwardingParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ForwardingParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> ForwardingParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ForwardingParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :forwarding_parameter_node
    def type: () -> :forwarding_parameter_node

    # See `Node.type`.
    # --
    # : () -> :forwarding_parameter_node
    def self.type: () -> :forwarding_parameter_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `super` keyword without parentheses or arguments, but which might have a block.
  #
  #     super
  #     ^^^^^
  #
  #     super { 123 }
  #     ^^^^^^^^^^^^^
  #
  # If it has any other arguments, it would be a `SuperNode` instead.
  class ForwardingSuperNode < Node
    @block: BlockNode?

    # Initialize a new ForwardingSuperNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, BlockNode? block) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, BlockNode? block) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ForwardingSuperNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?block: BlockNode?) -> ForwardingSuperNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?block: BlockNode?) -> ForwardingSuperNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :forwarding_super_node
    def type: () -> :forwarding_super_node

    # See `Node.type`.
    # --
    # : () -> :forwarding_super_node
    def self.type: () -> :forwarding_super_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   block -> BlockNode | nil
    #
    # All other arguments are forwarded as normal, except the original block is replaced with the new block.
    # --
    # : () -> BlockNode?
    def block: () -> BlockNode?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&=` operator for assignment to a global variable.
  #
  #     $target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableAndWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new GlobalVariableAndWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> GlobalVariableAndWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> GlobalVariableAndWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> GlobalVariableAndWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :global_variable_and_write_node
    def type: () -> :global_variable_and_write_node

    # See `Node.type`.
    # --
    # : () -> :global_variable_and_write_node
    def self.type: () -> :global_variable_and_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to a global variable using an operator that isn't `=`.
  #
  #     $target += value
  #     ^^^^^^^^^^^^^^^^
  class GlobalVariableOperatorWriteNode < Node
    @binary_operator: Symbol

    @value: Prism::node

    @binary_operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new GlobalVariableOperatorWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> GlobalVariableOperatorWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> GlobalVariableOperatorWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> GlobalVariableOperatorWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :global_variable_operator_write_node
    def type: () -> :global_variable_operator_write_node

    # See `Node.type`.
    # --
    # : () -> :global_variable_operator_write_node
    def self.type: () -> :global_variable_operator_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   binary_operator_loc -> Location
    #
    # Returns the Location represented by `binary_operator_loc`.
    # --
    # : () -> Location
    def binary_operator_loc: () -> Location

    # :category: Repository
    # Save the binary_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_binary_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   binary_operator -> Symbol
    #
    # Returns the `binary_operator` attribute.
    # --
    # : () -> Symbol
    def binary_operator: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||=` operator for assignment to a global variable.
  #
  #     $target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableOrWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new GlobalVariableOrWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> GlobalVariableOrWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> GlobalVariableOrWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> GlobalVariableOrWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :global_variable_or_write_node
    def type: () -> :global_variable_or_write_node

    # See `Node.type`.
    # --
    # : () -> :global_variable_or_write_node
    def self.type: () -> :global_variable_or_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents referencing a global variable.
  #
  #     $foo
  #     ^^^^
  class GlobalVariableReadNode < Node
    @name: Symbol

    # Initialize a new GlobalVariableReadNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> GlobalVariableReadNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> GlobalVariableReadNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> GlobalVariableReadNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :global_variable_read_node
    def type: () -> :global_variable_read_node

    # See `Node.type`.
    # --
    # : () -> :global_variable_read_node
    def self.type: () -> :global_variable_read_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.
    #
    #     $foo   # name `:$foo`
    #
    #     $_Test # name `:$_Test`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a global variable in a context that doesn't have an explicit value.
  #
  #     $foo, $bar = baz
  #     ^^^^  ^^^^
  class GlobalVariableTargetNode < Node
    @name: Symbol

    # Initialize a new GlobalVariableTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> GlobalVariableTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> GlobalVariableTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> GlobalVariableTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :global_variable_target_node
    def type: () -> :global_variable_target_node

    # See `Node.type`.
    # --
    # : () -> :global_variable_target_node
    def self.type: () -> :global_variable_target_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a global variable.
  #
  #     $foo = 1
  #     ^^^^^^^^
  class GlobalVariableWriteNode < Node
    @operator_loc: Location

    @value: Prism::node

    @name_loc: Location

    @name: Symbol

    # Initialize a new GlobalVariableWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> GlobalVariableWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> GlobalVariableWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> GlobalVariableWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :global_variable_write_node
    def type: () -> :global_variable_write_node

    # See `Node.type`.
    # --
    # : () -> :global_variable_write_node
    def self.type: () -> :global_variable_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.
    #
    #     $foo = :bar  # name `:$foo`
    #
    #     $_Test = 123 # name `:$_Test`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # The Location of the global variable's name.
    #
    #     $foo = :bar
    #     ^^^^
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # The value to write to the global variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     $foo = :bar
    #            ^^^^
    #
    #     $-xyz = 123
    #             ^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `=` operator.
    #
    #     $foo = :bar
    #          ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a hash literal.
  #
  #     { a => b }
  #     ^^^^^^^^^^
  class HashNode < Node
    @closing_loc: Location

    @elements: Array[AssocNode | AssocSplatNode]

    @opening_loc: Location

    # Initialize a new HashNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[AssocNode | AssocSplatNode] elements, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[AssocNode | AssocSplatNode] elements, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> HashNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?elements: Array[AssocNode | AssocSplatNode], ?closing_loc: Location) -> HashNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?elements: Array[AssocNode | AssocSplatNode], ?closing_loc: Location) -> HashNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :hash_node
    def type: () -> :hash_node

    # See `Node.type`.
    # --
    # : () -> :hash_node
    def self.type: () -> :hash_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # The Location of the opening brace.
    #
    #     { a => b }
    #     ^
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   elements -> Array[AssocNode | AssocSplatNode]
    #
    # The elements of the hash. These can be either `AssocNode`s or `AssocSplatNode`s.
    #
    #     { a: b }
    #       ^^^^
    #
    #     { **foo }
    #       ^^^^^
    # --
    # : () -> Array[AssocNode | AssocSplatNode]
    def elements: () -> Array[AssocNode | AssocSplatNode]

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # The Location of the closing brace.
    #
    #     { a => b }
    #              ^
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a hash pattern in pattern matching.
  #
  #     foo => { a: 1, b: 2 }
  #            ^^^^^^^^^^^^^^
  #
  #     foo => { a: 1, b: 2, **c }
  #            ^^^^^^^^^^^^^^^^^^^
  #
  #     foo => Bar[a: 1, b: 2]
  #            ^^^^^^^^^^^^^^^
  #
  #     foo in { a: 1, b: 2 }
  #            ^^^^^^^^^^^^^^
  class HashPatternNode < Node
    @closing_loc: Location?

    @opening_loc: Location?

    @rest: (AssocSplatNode | NoKeywordsParameterNode)?

    @elements: Array[AssocNode]

    @constant: (ConstantPathNode | ConstantReadNode)?

    # Initialize a new HashPatternNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (ConstantPathNode | ConstantReadNode)? constant, Array[AssocNode] elements, (AssocSplatNode | NoKeywordsParameterNode)? rest, Location? opening_loc, Location? closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, (ConstantPathNode | ConstantReadNode)? constant, Array[AssocNode] elements, (AssocSplatNode | NoKeywordsParameterNode)? rest, Location? opening_loc, Location? closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> HashPatternNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: (ConstantPathNode | ConstantReadNode)?, ?elements: Array[AssocNode], ?rest: (AssocSplatNode | NoKeywordsParameterNode)?, ?opening_loc: Location?, ?closing_loc: Location?) -> HashPatternNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: (ConstantPathNode | ConstantReadNode)?, ?elements: Array[AssocNode], ?rest: (AssocSplatNode | NoKeywordsParameterNode)?, ?opening_loc: Location?, ?closing_loc: Location?) -> HashPatternNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :hash_pattern_node
    def type: () -> :hash_pattern_node

    # See `Node.type`.
    # --
    # : () -> :hash_pattern_node
    def self.type: () -> :hash_pattern_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   constant -> ConstantPathNode | ConstantReadNode | nil
    #
    # Represents the optional constant preceding the Hash.
    #
    #     foo => Bar[a: 1, b: 2]
    #          ^^^
    #
    #     foo => Bar::Baz[a: 1, b: 2]
    #          ^^^^^^^^
    # --
    # : () -> (ConstantPathNode | ConstantReadNode)?
    def constant: () -> (ConstantPathNode | ConstantReadNode)?

    # :call-seq:
    #   elements -> Array[AssocNode]
    #
    # Represents the explicit named hash keys and values.
    #
    #     foo => { a: 1, b:, ** }
    #              ^^^^^^^^
    # --
    # : () -> Array[AssocNode]
    def elements: () -> Array[AssocNode]

    # :call-seq:
    #   rest -> AssocSplatNode | NoKeywordsParameterNode | nil
    #
    # Represents the rest of the Hash keys and values. This can be named, unnamed, or explicitly forbidden via `**nil`, this last one results in a `NoKeywordsParameterNode`.
    #
    #     foo => { a: 1, b:, **c }
    #                        ^^^
    #
    #     foo => { a: 1, b:, ** }
    #                        ^^
    #
    #     foo => { a: 1, b:, **nil }
    #                        ^^^^^
    # --
    # : () -> (AssocSplatNode | NoKeywordsParameterNode)?
    def rest: () -> (AssocSplatNode | NoKeywordsParameterNode)?

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # The Location of the opening brace.
    #
    #     foo => { a: 1 }
    #            ^
    #
    #     foo => Bar[a: 1]
    #               ^
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # The Location of the closing brace.
    #
    #     foo => { a: 1 }
    #                   ^
    #
    #     foo => Bar[a: 1]
    #                    ^
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.
  #
  #     bar if foo
  #     ^^^^^^^^^^
  #
  #     if foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^
  #
  #     foo ? bar : baz
  #     ^^^^^^^^^^^^^^^
  class IfNode < Node
    @end_keyword_loc: Location?

    @subsequent: (ElseNode | IfNode)?

    @statements: StatementsNode?

    @then_keyword_loc: Location?

    @predicate: Prism::node

    @if_keyword_loc: Location?

    # Initialize a new IfNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location? if_keyword_loc, Prism::node predicate, Location? then_keyword_loc, StatementsNode? statements, (ElseNode | IfNode)? subsequent, Location? end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? if_keyword_loc, Prism::node predicate, Location? then_keyword_loc, StatementsNode? statements, (ElseNode | IfNode)? subsequent, Location? end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> IfNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?if_keyword_loc: Location?, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?subsequent: (ElseNode | IfNode)?, ?end_keyword_loc: Location?) -> IfNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?if_keyword_loc: Location?, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?subsequent: (ElseNode | IfNode)?, ?end_keyword_loc: Location?) -> IfNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :if_node
    def type: () -> :if_node

    # See `Node.type`.
    # --
    # : () -> :if_node
    def self.type: () -> :if_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   if_keyword_loc -> Location | nil
    #
    # The Location of the `if` keyword if present.
    #
    #     bar if foo
    #         ^^
    #
    # The `if_keyword_loc` field will be `nil` when the `IfNode` represents a ternary expression.
    # --
    # : () -> Location?
    def if_keyword_loc: () -> Location?

    # :category: Repository
    # Save the if_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_if_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   predicate -> Node
    #
    # The node for the condition the `IfNode` is testing.
    #
    #     if foo
    #        ^^^
    #       bar
    #     end
    #
    #     bar if foo
    #            ^^^
    #
    #     foo ? bar : baz
    #     ^^^
    # --
    # : () -> Prism::node
    def predicate: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   then_keyword_loc -> Location | nil
    #
    # The Location of the `then` keyword (if present) or the `?` in a ternary expression, `nil` otherwise.
    #
    #     if foo then bar end
    #            ^^^^
    #
    #     a ? b : c
    #       ^
    # --
    # : () -> Location?
    def then_keyword_loc: () -> Location?

    # :category: Repository
    # Save the then_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_then_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Represents the body of statements that will be executed when the predicate is evaluated as truthy. Will be `nil` when no body is provided.
    #
    #     if foo
    #       bar
    #       ^^^
    #       baz
    #       ^^^
    #     end
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :call-seq:
    #   subsequent -> ElseNode | IfNode | nil
    #
    # Represents an `ElseNode` or an `IfNode` when there is an `else` or an `elsif` in the `if` statement.
    #
    #     if foo
    #       bar
    #     elsif baz
    #     ^^^^^^^^^
    #       qux
    #       ^^^
    #     end
    #     ^^^
    #
    #     if foo then bar else baz end
    #                     ^^^^^^^^^^^^
    # --
    # : () -> (ElseNode | IfNode)?
    def subsequent: () -> (ElseNode | IfNode)?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location | nil
    #
    # The Location of the `end` keyword if present, `nil` otherwise.
    #
    #     if foo
    #       bar
    #     end
    #     ^^^
    # --
    # : () -> Location?
    def end_keyword_loc: () -> Location?

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   if_keyword -> String | nil
    #
    # Slice the location of if_keyword_loc from the source.
    # --
    # : () -> String?
    def if_keyword: () -> String?

    # :call-seq:
    #   then_keyword -> String | nil
    #
    # Slice the location of then_keyword_loc from the source.
    # --
    # : () -> String?
    def then_keyword: () -> String?

    # :call-seq:
    #   end_keyword -> String | nil
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String?
    def end_keyword: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an imaginary number literal.
  #
  #     1.0i
  #     ^^^^
  class ImaginaryNode < Node
    @numeric: FloatNode | IntegerNode | RationalNode

    # Initialize a new ImaginaryNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (FloatNode | IntegerNode | RationalNode) numeric) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, FloatNode | IntegerNode | RationalNode numeric) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ImaginaryNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?numeric: (FloatNode | IntegerNode | RationalNode)) -> ImaginaryNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?numeric: FloatNode | IntegerNode | RationalNode) -> ImaginaryNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :imaginary_node
    def type: () -> :imaginary_node

    # See `Node.type`.
    # --
    # : () -> :imaginary_node
    def self.type: () -> :imaginary_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   numeric -> FloatNode | IntegerNode | RationalNode
    #
    # Returns the `numeric` attribute.
    # --
    # : () -> (FloatNode | IntegerNode | RationalNode)
    def numeric: () -> (FloatNode | IntegerNode | RationalNode)

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
  #
  #     { foo: }
  #       ^^^^
  #
  #     { Foo: }
  #       ^^^^
  #
  #     foo in { bar: }
  #              ^^^^
  class ImplicitNode < Node
    @value: LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode

    # Initialize a new ImplicitNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode) value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ImplicitNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: (LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode)) -> ImplicitNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode) -> ImplicitNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :implicit_node
    def type: () -> :implicit_node

    # See `Node.type`.
    # --
    # : () -> :implicit_node
    def self.type: () -> :implicit_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   value -> LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode
    #
    # Returns the `value` attribute.
    # --
    # : () -> (LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode)
    def value: () -> (LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode)

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents using a trailing comma to indicate an implicit rest parameter.
  #
  #     foo { |bar,| }
  #               ^
  #
  #     foo in [bar,]
  #                ^
  #
  #     for foo, in bar do end
  #            ^
  #
  #     foo, = bar
  #        ^
  class ImplicitRestNode < Node
    # Initialize a new ImplicitRestNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ImplicitRestNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> ImplicitRestNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ImplicitRestNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :implicit_rest_node
    def type: () -> :implicit_rest_node

    # See `Node.type`.
    # --
    # : () -> :implicit_rest_node
    def self.type: () -> :implicit_rest_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `in` keyword in a case statement.
  #
  #     case a; in b then c end
  #             ^^^^^^^^^^^
  class InNode < Node
    @then_loc: Location?

    @in_loc: Location

    @statements: StatementsNode?

    @pattern: Prism::node

    # Initialize a new InNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node pattern, StatementsNode? statements, Location in_loc, Location? then_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node pattern, StatementsNode? statements, Location in_loc, Location? then_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?pattern: Prism::node, ?statements: StatementsNode?, ?in_loc: Location, ?then_loc: Location?) -> InNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?pattern: Prism::node, ?statements: StatementsNode?, ?in_loc: Location, ?then_loc: Location?) -> InNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :in_node
    def type: () -> :in_node

    # See `Node.type`.
    # --
    # : () -> :in_node
    def self.type: () -> :in_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   pattern -> Node
    #
    # Returns the `pattern` attribute.
    # --
    # : () -> Prism::node
    def pattern: () -> Prism::node

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :category: Locations
    # :call-seq:
    #   in_loc -> Location
    #
    # Returns the Location represented by `in_loc`.
    # --
    # : () -> Location
    def in_loc: () -> Location

    # :category: Repository
    # Save the in_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_in_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   then_loc -> Location | nil
    #
    # Returns the Location represented by `then_loc`.
    # --
    # : () -> Location?
    def then_loc: () -> Location?

    # :category: Repository
    # Save the then_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_then_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   in -> String
    #
    # Slice the location of in_loc from the source.
    # --
    # : () -> String
    def in: () -> String

    # :call-seq:
    #   then -> String | nil
    #
    # Slice the location of then_loc from the source.
    # --
    # : () -> String?
    def then: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&=` operator on a call to the `[]` method.
  #
  #     foo.bar[baz] &&= value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class IndexAndWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @block: BlockArgumentNode?

    @closing_loc: Location

    @arguments: ArgumentsNode?

    @opening_loc: Location

    @call_operator_loc: Location?

    @receiver: Prism::node?

    # Initialize a new IndexAndWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> IndexAndWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?operator_loc: Location, ?value: Prism::node) -> IndexAndWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?operator_loc: Location, ?value: Prism::node) -> IndexAndWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :index_and_write_node
    def type: () -> :index_and_write_node

    # See `Node.type`.
    # --
    # : () -> :index_and_write_node
    def self.type: () -> :index_and_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node | nil
    #
    # Returns the `receiver` attribute.
    # --
    # : () -> Prism::node?
    def receiver: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   call_operator_loc -> Location | nil
    #
    # Returns the Location represented by `call_operator_loc`.
    # --
    # : () -> Location?
    def call_operator_loc: () -> Location?

    # :category: Repository
    # Save the call_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_call_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Returns the `arguments` attribute.
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   block -> BlockArgumentNode | nil
    #
    # Returns the `block` attribute.
    # --
    # : () -> BlockArgumentNode?
    def block: () -> BlockArgumentNode?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   call_operator -> String | nil
    #
    # Slice the location of call_operator_loc from the source.
    # --
    # : () -> String?
    def call_operator: () -> String?

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of an assignment operator on a call to `[]`.
  #
  #     foo.bar[baz] += value
  #     ^^^^^^^^^^^^^^^^^^^^^
  class IndexOperatorWriteNode < Node
    @value: Prism::node

    @binary_operator_loc: Location

    @binary_operator: Symbol

    @block: BlockArgumentNode?

    @closing_loc: Location

    @arguments: ArgumentsNode?

    @opening_loc: Location

    @call_operator_loc: Location?

    @receiver: Prism::node?

    # Initialize a new IndexOperatorWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Symbol binary_operator, Location binary_operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Symbol binary_operator, Location binary_operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> IndexOperatorWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?binary_operator: Symbol, ?binary_operator_loc: Location, ?value: Prism::node) -> IndexOperatorWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?binary_operator: Symbol, ?binary_operator_loc: Location, ?value: Prism::node) -> IndexOperatorWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :index_operator_write_node
    def type: () -> :index_operator_write_node

    # See `Node.type`.
    # --
    # : () -> :index_operator_write_node
    def self.type: () -> :index_operator_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node | nil
    #
    # Returns the `receiver` attribute.
    # --
    # : () -> Prism::node?
    def receiver: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   call_operator_loc -> Location | nil
    #
    # Returns the Location represented by `call_operator_loc`.
    # --
    # : () -> Location?
    def call_operator_loc: () -> Location?

    # :category: Repository
    # Save the call_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_call_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Returns the `arguments` attribute.
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   block -> BlockArgumentNode | nil
    #
    # Returns the `block` attribute.
    # --
    # : () -> BlockArgumentNode?
    def block: () -> BlockArgumentNode?

    # :call-seq:
    #   binary_operator -> Symbol
    #
    # Returns the `binary_operator` attribute.
    # --
    # : () -> Symbol
    def binary_operator: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   binary_operator_loc -> Location
    #
    # Returns the Location represented by `binary_operator_loc`.
    # --
    # : () -> Location
    def binary_operator_loc: () -> Location

    # :category: Repository
    # Save the binary_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_binary_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   call_operator -> String | nil
    #
    # Slice the location of call_operator_loc from the source.
    # --
    # : () -> String?
    def call_operator: () -> String?

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||=` operator on a call to `[]`.
  #
  #     foo.bar[baz] ||= value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class IndexOrWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @block: BlockArgumentNode?

    @closing_loc: Location

    @arguments: ArgumentsNode?

    @opening_loc: Location

    @call_operator_loc: Location?

    @receiver: Prism::node?

    # Initialize a new IndexOrWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> IndexOrWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?operator_loc: Location, ?value: Prism::node) -> IndexOrWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?operator_loc: Location, ?value: Prism::node) -> IndexOrWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :index_or_write_node
    def type: () -> :index_or_write_node

    # See `Node.type`.
    # --
    # : () -> :index_or_write_node
    def self.type: () -> :index_or_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node | nil
    #
    # Returns the `receiver` attribute.
    # --
    # : () -> Prism::node?
    def receiver: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   call_operator_loc -> Location | nil
    #
    # Returns the Location represented by `call_operator_loc`.
    # --
    # : () -> Location?
    def call_operator_loc: () -> Location?

    # :category: Repository
    # Save the call_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_call_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Returns the `arguments` attribute.
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   block -> BlockArgumentNode | nil
    #
    # Returns the `block` attribute.
    # --
    # : () -> BlockArgumentNode?
    def block: () -> BlockArgumentNode?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   call_operator -> String | nil
    #
    # Slice the location of call_operator_loc from the source.
    # --
    # : () -> String?
    def call_operator: () -> String?

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to an index.
  #
  #     foo[bar], = 1
  #     ^^^^^^^^
  #
  #     begin
  #     rescue => foo[bar]
  #               ^^^^^^^^
  #     end
  #
  #     for foo[bar] in baz do end
  #         ^^^^^^^^
  class IndexTargetNode < Node
    @block: BlockArgumentNode?

    @closing_loc: Location

    @arguments: ArgumentsNode?

    @opening_loc: Location

    @receiver: Prism::node

    # Initialize a new IndexTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node receiver, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node receiver, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> IndexTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?) -> IndexTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?) -> IndexTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :index_target_node
    def type: () -> :index_target_node

    # See `Node.type`.
    # --
    # : () -> :index_target_node
    def self.type: () -> :index_target_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # &. operator
    # --
    # : () -> bool
    def safe_navigation?: () -> bool

    # :category: Flags
    # a call that could have been a local variable
    # --
    # : () -> bool
    def variable_call?: () -> bool

    # :category: Flags
    # a call that is an attribute write, so the value being written should be returned
    # --
    # : () -> bool
    def attribute_write?: () -> bool

    # :category: Flags
    # a call that ignores method visibility
    # --
    # : () -> bool
    def ignore_visibility?: () -> bool

    # :call-seq:
    #   receiver -> Node
    #
    # Returns the `receiver` attribute.
    # --
    # : () -> Prism::node
    def receiver: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Returns the `arguments` attribute.
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   block -> BlockArgumentNode | nil
    #
    # Returns the `block` attribute.
    # --
    # : () -> BlockArgumentNode?
    def block: () -> BlockArgumentNode?

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&=` operator for assignment to an instance variable.
  #
  #     @target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableAndWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new InstanceVariableAndWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InstanceVariableAndWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> InstanceVariableAndWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> InstanceVariableAndWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :instance_variable_and_write_node
    def type: () -> :instance_variable_and_write_node

    # See `Node.type`.
    # --
    # : () -> :instance_variable_and_write_node
    def self.type: () -> :instance_variable_and_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to an instance variable using an operator that isn't `=`.
  #
  #     @target += value
  #     ^^^^^^^^^^^^^^^^
  class InstanceVariableOperatorWriteNode < Node
    @binary_operator: Symbol

    @value: Prism::node

    @binary_operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new InstanceVariableOperatorWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InstanceVariableOperatorWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> InstanceVariableOperatorWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> InstanceVariableOperatorWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :instance_variable_operator_write_node
    def type: () -> :instance_variable_operator_write_node

    # See `Node.type`.
    # --
    # : () -> :instance_variable_operator_write_node
    def self.type: () -> :instance_variable_operator_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   binary_operator_loc -> Location
    #
    # Returns the Location represented by `binary_operator_loc`.
    # --
    # : () -> Location
    def binary_operator_loc: () -> Location

    # :category: Repository
    # Save the binary_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_binary_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   binary_operator -> Symbol
    #
    # Returns the `binary_operator` attribute.
    # --
    # : () -> Symbol
    def binary_operator: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||=` operator for assignment to an instance variable.
  #
  #     @target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableOrWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new InstanceVariableOrWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InstanceVariableOrWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> InstanceVariableOrWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> InstanceVariableOrWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :instance_variable_or_write_node
    def type: () -> :instance_variable_or_write_node

    # See `Node.type`.
    # --
    # : () -> :instance_variable_or_write_node
    def self.type: () -> :instance_variable_or_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents referencing an instance variable.
  #
  #     @foo
  #     ^^^^
  class InstanceVariableReadNode < Node
    @name: Symbol

    # Initialize a new InstanceVariableReadNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InstanceVariableReadNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> InstanceVariableReadNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> InstanceVariableReadNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :instance_variable_read_node
    def type: () -> :instance_variable_read_node

    # See `Node.type`.
    # --
    # : () -> :instance_variable_read_node
    def self.type: () -> :instance_variable_read_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
    #
    #     @x     # name `:@x`
    #
    #     @_test # name `:@_test`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to an instance variable in a context that doesn't have an explicit value.
  #
  #     @foo, @bar = baz
  #     ^^^^  ^^^^
  class InstanceVariableTargetNode < Node
    @name: Symbol

    # Initialize a new InstanceVariableTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InstanceVariableTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> InstanceVariableTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> InstanceVariableTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :instance_variable_target_node
    def type: () -> :instance_variable_target_node

    # See `Node.type`.
    # --
    # : () -> :instance_variable_target_node
    def self.type: () -> :instance_variable_target_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to an instance variable.
  #
  #     @foo = 1
  #     ^^^^^^^^
  class InstanceVariableWriteNode < Node
    @operator_loc: Location

    @value: Prism::node

    @name_loc: Location

    @name: Symbol

    # Initialize a new InstanceVariableWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InstanceVariableWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> InstanceVariableWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> InstanceVariableWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :instance_variable_write_node
    def type: () -> :instance_variable_write_node

    # See `Node.type`.
    # --
    # : () -> :instance_variable_write_node
    def self.type: () -> :instance_variable_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
    #
    #     @x = :y       # name `:@x`
    #
    #     @_foo = "bar" # name `@_foo`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # The Location of the variable name.
    #
    #     @_x = 1
    #     ^^^
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # The value to write to the instance variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     @foo = :bar
    #            ^^^^
    #
    #     @_x = 1234
    #           ^^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `=` operator.
    #
    #     @x = y
    #        ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an integer number literal.
  #
  #     1
  #     ^
  class IntegerNode < Node
    @value: Integer

    # Initialize a new IntegerNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Integer value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Integer value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> IntegerNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Integer) -> IntegerNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Integer) -> IntegerNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :integer_node
    def type: () -> :integer_node

    # See `Node.type`.
    # --
    # : () -> :integer_node
    def self.type: () -> :integer_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # 0b prefix
    # --
    # : () -> bool
    def binary?: () -> bool

    # :category: Flags
    # 0d or no prefix
    # --
    # : () -> bool
    def decimal?: () -> bool

    # :category: Flags
    # 0o or 0 prefix
    # --
    # : () -> bool
    def octal?: () -> bool

    # :category: Flags
    # 0x prefix
    # --
    # : () -> bool
    def hexadecimal?: () -> bool

    # :call-seq:
    #   value -> Integer
    #
    # The value of the integer literal as a number.
    # --
    # : () -> Integer
    def value: () -> Integer

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
  #
  #     if /foo #{bar} baz/ then end
  #        ^^^^^^^^^^^^^^^^
  class InterpolatedMatchLastLineNode < Node
    @closing_loc: Location

    @parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]

    @opening_loc: Location

    # Initialize a new InterpolatedMatchLastLineNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InterpolatedMatchLastLineNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedMatchLastLineNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedMatchLastLineNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :interpolated_match_last_line_node
    def type: () -> :interpolated_match_last_line_node

    # See `Node.type`.
    # --
    # : () -> :interpolated_match_last_line_node
    def self.type: () -> :interpolated_match_last_line_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # i - ignores the case of characters when matching
    # --
    # : () -> bool
    def ignore_case?: () -> bool

    # :category: Flags
    # x - ignores whitespace and allows comments in regular expressions
    # --
    # : () -> bool
    def extended?: () -> bool

    # :category: Flags
    # m - allows $ to match the end of lines within strings
    # --
    # : () -> bool
    def multi_line?: () -> bool

    # :category: Flags
    # o - only interpolates values into the regular expression once
    # --
    # : () -> bool
    def once?: () -> bool

    # :category: Flags
    # e - forces the EUC-JP encoding
    # --
    # : () -> bool
    def euc_jp?: () -> bool

    # :category: Flags
    # n - forces the ASCII-8BIT encoding
    # --
    # : () -> bool
    def ascii_8bit?: () -> bool

    # :category: Flags
    # s - forces the Windows-31J encoding
    # --
    # : () -> bool
    def windows_31j?: () -> bool

    # :category: Flags
    # u - forces the UTF-8 encoding
    # --
    # : () -> bool
    def utf_8?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to UTF-8
    # --
    # : () -> bool
    def forced_utf8_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to binary
    # --
    # : () -> bool
    def forced_binary_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to US-ASCII
    # --
    # : () -> bool
    def forced_us_ascii_encoding?: () -> bool

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   parts -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    #
    # Returns the `parts` attribute.
    # --
    # : () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    def parts: () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a regular expression literal that contains interpolation.
  #
  #     /foo #{bar} baz/
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedRegularExpressionNode < Node
    @closing_loc: Location

    @parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]

    @opening_loc: Location

    # Initialize a new InterpolatedRegularExpressionNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InterpolatedRegularExpressionNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedRegularExpressionNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedRegularExpressionNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :interpolated_regular_expression_node
    def type: () -> :interpolated_regular_expression_node

    # See `Node.type`.
    # --
    # : () -> :interpolated_regular_expression_node
    def self.type: () -> :interpolated_regular_expression_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # i - ignores the case of characters when matching
    # --
    # : () -> bool
    def ignore_case?: () -> bool

    # :category: Flags
    # x - ignores whitespace and allows comments in regular expressions
    # --
    # : () -> bool
    def extended?: () -> bool

    # :category: Flags
    # m - allows $ to match the end of lines within strings
    # --
    # : () -> bool
    def multi_line?: () -> bool

    # :category: Flags
    # o - only interpolates values into the regular expression once
    # --
    # : () -> bool
    def once?: () -> bool

    # :category: Flags
    # e - forces the EUC-JP encoding
    # --
    # : () -> bool
    def euc_jp?: () -> bool

    # :category: Flags
    # n - forces the ASCII-8BIT encoding
    # --
    # : () -> bool
    def ascii_8bit?: () -> bool

    # :category: Flags
    # s - forces the Windows-31J encoding
    # --
    # : () -> bool
    def windows_31j?: () -> bool

    # :category: Flags
    # u - forces the UTF-8 encoding
    # --
    # : () -> bool
    def utf_8?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to UTF-8
    # --
    # : () -> bool
    def forced_utf8_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to binary
    # --
    # : () -> bool
    def forced_binary_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to US-ASCII
    # --
    # : () -> bool
    def forced_us_ascii_encoding?: () -> bool

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   parts -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    #
    # Returns the `parts` attribute.
    # --
    # : () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    def parts: () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a string literal that contains interpolation.
  #
  #     "foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedStringNode < Node
    @closing_loc: Location?

    @parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode]

    @opening_loc: Location?

    # Initialize a new InterpolatedStringNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode] parts, Location? closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode] parts, Location? closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InterpolatedStringNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode], ?closing_loc: Location?) -> InterpolatedStringNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode], ?closing_loc: Location?) -> InterpolatedStringNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :interpolated_string_node
    def type: () -> :interpolated_string_node

    # See `Node.type`.
    # --
    # : () -> :interpolated_string_node
    def self.type: () -> :interpolated_string_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`
    # --
    # : () -> bool
    def frozen?: () -> bool

    # :category: Flags
    # mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`
    # --
    # : () -> bool
    def mutable?: () -> bool

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   parts -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode]
    #
    # Returns the `parts` attribute.
    # --
    # : () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode]
    def parts: () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode]

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a symbol literal that contains interpolation.
  #
  #     :"foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^^
  class InterpolatedSymbolNode < Node
    @closing_loc: Location?

    @parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]

    @opening_loc: Location?

    # Initialize a new InterpolatedSymbolNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location? closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location? closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InterpolatedSymbolNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location?) -> InterpolatedSymbolNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location?) -> InterpolatedSymbolNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :interpolated_symbol_node
    def type: () -> :interpolated_symbol_node

    # See `Node.type`.
    # --
    # : () -> :interpolated_symbol_node
    def self.type: () -> :interpolated_symbol_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   parts -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    #
    # Returns the `parts` attribute.
    # --
    # : () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    def parts: () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an xstring literal that contains interpolation.
  #
  #     `foo #{bar} baz`
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedXStringNode < Node
    @closing_loc: Location

    @parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]

    @opening_loc: Location

    # Initialize a new InterpolatedXStringNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> InterpolatedXStringNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedXStringNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedXStringNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :interpolated_x_string_node
    def type: () -> :interpolated_x_string_node

    # See `Node.type`.
    # --
    # : () -> :interpolated_x_string_node
    def self.type: () -> :interpolated_x_string_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   parts -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    #
    # Returns the `parts` attribute.
    # --
    # : () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    def parts: () -> Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents reading from the implicit `it` local variable.
  #
  #     -> { it }
  #          ^^
  class ItLocalVariableReadNode < Node
    # Initialize a new ItLocalVariableReadNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ItLocalVariableReadNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> ItLocalVariableReadNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ItLocalVariableReadNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :it_local_variable_read_node
    def type: () -> :it_local_variable_read_node

    # See `Node.type`.
    # --
    # : () -> :it_local_variable_read_node
    def self.type: () -> :it_local_variable_read_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.
  #
  #     -> { it + it }
  #     ^^^^^^^^^^^^^^
  class ItParametersNode < Node
    # Initialize a new ItParametersNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ItParametersNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> ItParametersNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ItParametersNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :it_parameters_node
    def type: () -> :it_parameters_node

    # See `Node.type`.
    # --
    # : () -> :it_parameters_node
    def self.type: () -> :it_parameters_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a hash literal without opening and closing braces.
  #
  #     foo(a: b)
  #         ^^^^
  class KeywordHashNode < Node
    @elements: Array[AssocNode | AssocSplatNode]

    # Initialize a new KeywordHashNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[AssocNode | AssocSplatNode] elements) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[AssocNode | AssocSplatNode] elements) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> KeywordHashNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?elements: Array[AssocNode | AssocSplatNode]) -> KeywordHashNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?elements: Array[AssocNode | AssocSplatNode]) -> KeywordHashNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :keyword_hash_node
    def type: () -> :keyword_hash_node

    # See `Node.type`.
    # --
    # : () -> :keyword_hash_node
    def self.type: () -> :keyword_hash_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments
    # --
    # : () -> bool
    def symbol_keys?: () -> bool

    # :call-seq:
    #   elements -> Array[AssocNode | AssocSplatNode]
    #
    # Returns the `elements` attribute.
    # --
    # : () -> Array[AssocNode | AssocSplatNode]
    def elements: () -> Array[AssocNode | AssocSplatNode]

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a keyword rest parameter to a method, block, or lambda definition.
  #
  #     def a(**b)
  #           ^^^
  #     end
  class KeywordRestParameterNode < Node
    @operator_loc: Location

    @name_loc: Location?

    @name: Symbol?

    # Initialize a new KeywordRestParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> KeywordRestParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> KeywordRestParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> KeywordRestParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :keyword_rest_parameter_node
    def type: () -> :keyword_rest_parameter_node

    # See `Node.type`.
    # --
    # : () -> :keyword_rest_parameter_node
    def self.type: () -> :keyword_rest_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a parameter name that has been repeated in the method signature
    # --
    # : () -> bool
    def repeated_parameter?: () -> bool

    # :call-seq:
    #   name -> Symbol | nil
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol?
    def name: () -> Symbol?

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location | nil
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location?
    def name_loc: () -> Location?

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_name_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents using a lambda literal (not the lambda method call).
  #
  #     ->(value) { value * 2 }
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class LambdaNode < Node
    @body: (StatementsNode | BeginNode)?

    @parameters: (BlockParametersNode | NumberedParametersNode | ItParametersNode)?

    @closing_loc: Location

    @opening_loc: Location

    @operator_loc: Location

    @locals: Array[Symbol]

    # Initialize a new LambdaNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location operator_loc, Location opening_loc, Location closing_loc, (BlockParametersNode | NumberedParametersNode | ItParametersNode)? parameters, (StatementsNode | BeginNode)? body) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location operator_loc, Location opening_loc, Location closing_loc, (BlockParametersNode | NumberedParametersNode | ItParametersNode)? parameters, (StatementsNode | BeginNode)? body) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> LambdaNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?operator_loc: Location, ?opening_loc: Location, ?closing_loc: Location, ?parameters: (BlockParametersNode | NumberedParametersNode | ItParametersNode)?, ?body: (StatementsNode | BeginNode)?) -> LambdaNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?operator_loc: Location, ?opening_loc: Location, ?closing_loc: Location, ?parameters: (BlockParametersNode | NumberedParametersNode | ItParametersNode)?, ?body: (StatementsNode | BeginNode)?) -> LambdaNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :lambda_node
    def type: () -> :lambda_node

    # See `Node.type`.
    # --
    # : () -> :lambda_node
    def self.type: () -> :lambda_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   locals -> Array[Symbol]
    #
    # Returns the `locals` attribute.
    # --
    # : () -> Array[Symbol]
    def locals: () -> Array[Symbol]

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   parameters -> BlockParametersNode | NumberedParametersNode | ItParametersNode | nil
    #
    # Returns the `parameters` attribute.
    # --
    # : () -> (BlockParametersNode | NumberedParametersNode | ItParametersNode)?
    def parameters: () -> (BlockParametersNode | NumberedParametersNode | ItParametersNode)?

    # :call-seq:
    #   body -> StatementsNode | BeginNode | nil
    #
    # Returns the `body` attribute.
    # --
    # : () -> (StatementsNode | BeginNode)?
    def body: () -> (StatementsNode | BeginNode)?

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `&&=` operator for assignment to a local variable.
  #
  #     target &&= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableAndWriteNode < Node
    @depth: Integer

    @name: Symbol

    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    # Initialize a new LocalVariableAndWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location operator_loc, Prism::node value, Symbol name, Integer depth) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location operator_loc, Prism::node value, Symbol name, Integer depth) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> LocalVariableAndWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer) -> LocalVariableAndWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer) -> LocalVariableAndWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :local_variable_and_write_node
    def type: () -> :local_variable_and_write_node

    # See `Node.type`.
    # --
    # : () -> :local_variable_and_write_node
    def self.type: () -> :local_variable_and_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :call-seq:
    #   depth -> Integer
    #
    # Returns the `depth` attribute.
    # --
    # : () -> Integer
    def depth: () -> Integer

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents assigning to a local variable using an operator that isn't `=`.
  #
  #     target += value
  #     ^^^^^^^^^^^^^^^
  class LocalVariableOperatorWriteNode < Node
    @depth: Integer

    @binary_operator: Symbol

    @name: Symbol

    @value: Prism::node

    @binary_operator_loc: Location

    @name_loc: Location

    # Initialize a new LocalVariableOperatorWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol name, Symbol binary_operator, Integer depth) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol name, Symbol binary_operator, Integer depth) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> LocalVariableOperatorWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?binary_operator: Symbol, ?depth: Integer) -> LocalVariableOperatorWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?binary_operator: Symbol, ?depth: Integer) -> LocalVariableOperatorWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :local_variable_operator_write_node
    def type: () -> :local_variable_operator_write_node

    # See `Node.type`.
    # --
    # : () -> :local_variable_operator_write_node
    def self.type: () -> :local_variable_operator_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   binary_operator_loc -> Location
    #
    # Returns the Location represented by `binary_operator_loc`.
    # --
    # : () -> Location
    def binary_operator_loc: () -> Location

    # :category: Repository
    # Save the binary_operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_binary_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :call-seq:
    #   binary_operator -> Symbol
    #
    # Returns the `binary_operator` attribute.
    # --
    # : () -> Symbol
    def binary_operator: () -> Symbol

    # :call-seq:
    #   depth -> Integer
    #
    # Returns the `depth` attribute.
    # --
    # : () -> Integer
    def depth: () -> Integer

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||=` operator for assignment to a local variable.
  #
  #     target ||= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableOrWriteNode < Node
    @depth: Integer

    @name: Symbol

    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    # Initialize a new LocalVariableOrWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location operator_loc, Prism::node value, Symbol name, Integer depth) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location operator_loc, Prism::node value, Symbol name, Integer depth) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> LocalVariableOrWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer) -> LocalVariableOrWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer) -> LocalVariableOrWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :local_variable_or_write_node
    def type: () -> :local_variable_or_write_node

    # See `Node.type`.
    # --
    # : () -> :local_variable_or_write_node
    def self.type: () -> :local_variable_or_write_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :call-seq:
    #   depth -> Integer
    #
    # Returns the `depth` attribute.
    # --
    # : () -> Integer
    def depth: () -> Integer

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
  #
  #     foo
  #     ^^^
  class LocalVariableReadNode < Node
    @depth: Integer

    @name: Symbol

    # Initialize a new LocalVariableReadNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> LocalVariableReadNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer) -> LocalVariableReadNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer) -> LocalVariableReadNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :local_variable_read_node
    def type: () -> :local_variable_read_node

    # See `Node.type`.
    # --
    # : () -> :local_variable_read_node
    def self.type: () -> :local_variable_read_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
    #
    #     x      # name `:x`
    #
    #     _Test  # name `:_Test`
    #
    # Note that this can also be an underscore followed by a number for the default block parameters.
    #
    #     _1     # name `:_1`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :call-seq:
    #   depth -> Integer
    #
    # The number of visible scopes that should be searched to find the origin of this local variable.
    #
    #     foo = 1; foo # depth 0
    #
    #     bar = 2; tap { bar } # depth 1
    #
    # The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md).
    # --
    # : () -> Integer
    def depth: () -> Integer

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a local variable in a context that doesn't have an explicit value.
  #
  #     foo, bar = baz
  #     ^^^  ^^^
  #
  #     foo => baz
  #            ^^^
  class LocalVariableTargetNode < Node
    @depth: Integer

    @name: Symbol

    # Initialize a new LocalVariableTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> LocalVariableTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer) -> LocalVariableTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer) -> LocalVariableTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :local_variable_target_node
    def type: () -> :local_variable_target_node

    # See `Node.type`.
    # --
    # : () -> :local_variable_target_node
    def self.type: () -> :local_variable_target_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :call-seq:
    #   depth -> Integer
    #
    # Returns the `depth` attribute.
    # --
    # : () -> Integer
    def depth: () -> Integer

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing to a local variable.
  #
  #     foo = 1
  #     ^^^^^^^
  class LocalVariableWriteNode < Node
    @operator_loc: Location

    @value: Prism::node

    @name_loc: Location

    @depth: Integer

    @name: Symbol

    # Initialize a new LocalVariableWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth, Location name_loc, Prism::node value, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth, Location name_loc, Prism::node value, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> LocalVariableWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> LocalVariableWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> LocalVariableWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :local_variable_write_node
    def type: () -> :local_variable_write_node

    # See `Node.type`.
    # --
    # : () -> :local_variable_write_node
    def self.type: () -> :local_variable_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   name -> Symbol
    #
    # The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
    #
    #     foo = :bar # name `:foo`
    #
    #     abc = 123  # name `:abc`
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :call-seq:
    #   depth -> Integer
    #
    # The number of semantic scopes we have to traverse to find the declaration of this variable.
    #
    #     foo = 1         # depth 0
    #
    #     tap { foo = 1 } # depth 1
    #
    # The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md).
    # --
    # : () -> Integer
    def depth: () -> Integer

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # The Location of the variable name.
    #
    #     foo = :bar
    #     ^^^
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # The value to write to the local variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     foo = :bar
    #           ^^^^
    #
    #     abc = 1234
    #           ^^^^
    #
    # Note that since the name of a local variable is known before the value is parsed, it is valid for a local variable to appear within the value of its own write.
    #
    #     foo = foo
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `=` operator.
    #
    #     x = :y
    #       ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
  #
  #     if /foo/i then end
  #        ^^^^^^
  class MatchLastLineNode < Node
    @unescaped: String

    @closing_loc: Location

    @content_loc: Location

    @opening_loc: Location

    # Initialize a new MatchLastLineNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> MatchLastLineNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> MatchLastLineNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> MatchLastLineNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :match_last_line_node
    def type: () -> :match_last_line_node

    # See `Node.type`.
    # --
    # : () -> :match_last_line_node
    def self.type: () -> :match_last_line_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # i - ignores the case of characters when matching
    # --
    # : () -> bool
    def ignore_case?: () -> bool

    # :category: Flags
    # x - ignores whitespace and allows comments in regular expressions
    # --
    # : () -> bool
    def extended?: () -> bool

    # :category: Flags
    # m - allows $ to match the end of lines within strings
    # --
    # : () -> bool
    def multi_line?: () -> bool

    # :category: Flags
    # o - only interpolates values into the regular expression once
    # --
    # : () -> bool
    def once?: () -> bool

    # :category: Flags
    # e - forces the EUC-JP encoding
    # --
    # : () -> bool
    def euc_jp?: () -> bool

    # :category: Flags
    # n - forces the ASCII-8BIT encoding
    # --
    # : () -> bool
    def ascii_8bit?: () -> bool

    # :category: Flags
    # s - forces the Windows-31J encoding
    # --
    # : () -> bool
    def windows_31j?: () -> bool

    # :category: Flags
    # u - forces the UTF-8 encoding
    # --
    # : () -> bool
    def utf_8?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to UTF-8
    # --
    # : () -> bool
    def forced_utf8_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to binary
    # --
    # : () -> bool
    def forced_binary_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to US-ASCII
    # --
    # : () -> bool
    def forced_us_ascii_encoding?: () -> bool

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   content_loc -> Location
    #
    # Returns the Location represented by `content_loc`.
    # --
    # : () -> Location
    def content_loc: () -> Location

    # :category: Repository
    # Save the content_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_content_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   unescaped -> String
    #
    # Returns the `unescaped` attribute.
    # --
    # : () -> String
    def unescaped: () -> String

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   content -> String
    #
    # Slice the location of content_loc from the source.
    # --
    # : () -> String
    def content: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the modifier `in` operator.
  #
  #     foo in bar
  #     ^^^^^^^^^^
  class MatchPredicateNode < Node
    @operator_loc: Location

    @pattern: Prism::node

    @value: Prism::node

    # Initialize a new MatchPredicateNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node value, Prism::node pattern, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node value, Prism::node pattern, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> MatchPredicateNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location) -> MatchPredicateNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location) -> MatchPredicateNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :match_predicate_node
    def type: () -> :match_predicate_node

    # See `Node.type`.
    # --
    # : () -> :match_predicate_node
    def self.type: () -> :match_predicate_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   pattern -> Node
    #
    # Returns the `pattern` attribute.
    # --
    # : () -> Prism::node
    def pattern: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `=>` operator.
  #
  #     foo => bar
  #     ^^^^^^^^^^
  class MatchRequiredNode < Node
    @operator_loc: Location

    @pattern: Prism::node

    @value: Prism::node

    # Initialize a new MatchRequiredNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node value, Prism::node pattern, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node value, Prism::node pattern, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> MatchRequiredNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location) -> MatchRequiredNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location) -> MatchRequiredNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :match_required_node
    def type: () -> :match_required_node

    # See `Node.type`.
    # --
    # : () -> :match_required_node
    def self.type: () -> :match_required_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   value -> Node
    #
    # Represents the left-hand side of the operator.
    #
    #     foo => bar
    #     ^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   pattern -> Node
    #
    # Represents the right-hand side of the operator. The type of the node depends on the expression.
    #
    # Anything that looks like a local variable name (including `_`) will result in a `LocalVariableTargetNode`.
    #
    #     foo => a # This is equivalent to writing `a = foo`
    #            ^
    #
    # Using an explicit `Array` or combining expressions with `,` will result in a `ArrayPatternNode`. This can be preceded by a constant.
    #
    #     foo => [a]
    #            ^^^
    #
    #     foo => a, b
    #            ^^^^
    #
    #     foo => Bar[a, b]
    #            ^^^^^^^^^
    #
    # If the array pattern contains at least two wildcard matches, a `FindPatternNode` is created instead.
    #
    #     foo => *, 1, *a
    #            ^^^^^
    #
    # Using an explicit `Hash` or a constant with square brackets and hash keys in the square brackets will result in a `HashPatternNode`.
    #
    #     foo => { a: 1, b: }
    #
    #     foo => Bar[a: 1, b:]
    #
    #     foo => Bar[**]
    #
    # To use any variable that needs run time evaluation, pinning is required. This results in a `PinnedVariableNode`
    #
    #     foo => ^a
    #            ^^
    #
    # Similar, any expression can be used with pinning. This results in a `PinnedExpressionNode`.
    #
    #     foo => ^(a + 1)
    #
    # Anything else will result in the regular node for that expression, for example a `ConstantReadNode`.
    #
    #     foo => CONST
    # --
    # : () -> Prism::node
    def pattern: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the operator.
    #
    #     foo => bar
    #         ^^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents writing local variables using a regular expression match with named capture groups.
  #
  #     /(?<foo>bar)/ =~ baz
  #     ^^^^^^^^^^^^^^^^^^^^
  class MatchWriteNode < Node
    @targets: Array[LocalVariableTargetNode]

    @call: CallNode

    # Initialize a new MatchWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, CallNode call, Array[LocalVariableTargetNode] targets) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, CallNode call, Array[LocalVariableTargetNode] targets) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> MatchWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?call: CallNode, ?targets: Array[LocalVariableTargetNode]) -> MatchWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?call: CallNode, ?targets: Array[LocalVariableTargetNode]) -> MatchWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :match_write_node
    def type: () -> :match_write_node

    # See `Node.type`.
    # --
    # : () -> :match_write_node
    def self.type: () -> :match_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   call -> CallNode
    #
    # Returns the `call` attribute.
    # --
    # : () -> CallNode
    def call: () -> CallNode

    # :call-seq:
    #   targets -> Array[LocalVariableTargetNode]
    #
    # Returns the `targets` attribute.
    # --
    # : () -> Array[LocalVariableTargetNode]
    def targets: () -> Array[LocalVariableTargetNode]

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a node that is missing from the source and results in a syntax error.
  class MissingNode < Node
    # Initialize a new MissingNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> MissingNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> MissingNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> MissingNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :missing_node
    def type: () -> :missing_node

    # See `Node.type`.
    # --
    # : () -> :missing_node
    def self.type: () -> :missing_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a module declaration involving the `module` keyword.
  #
  #     module Foo end
  #     ^^^^^^^^^^^^^^
  class ModuleNode < Node
    @name: Symbol

    @end_keyword_loc: Location

    @body: (StatementsNode | BeginNode)?

    @constant_path: ConstantReadNode | ConstantPathNode | MissingNode

    @module_keyword_loc: Location

    @locals: Array[Symbol]

    # Initialize a new ModuleNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location module_keyword_loc, (ConstantReadNode | ConstantPathNode | MissingNode) constant_path, (StatementsNode | BeginNode)? body, Location end_keyword_loc, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location module_keyword_loc, ConstantReadNode | ConstantPathNode | MissingNode constant_path, (StatementsNode | BeginNode)? body, Location end_keyword_loc, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ModuleNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?module_keyword_loc: Location, ?constant_path: (ConstantReadNode | ConstantPathNode | MissingNode), ?body: (StatementsNode | BeginNode)?, ?end_keyword_loc: Location, ?name: Symbol) -> ModuleNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?module_keyword_loc: Location, ?constant_path: ConstantReadNode | ConstantPathNode | MissingNode, ?body: (StatementsNode | BeginNode)?, ?end_keyword_loc: Location, ?name: Symbol) -> ModuleNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :module_node
    def type: () -> :module_node

    # See `Node.type`.
    # --
    # : () -> :module_node
    def self.type: () -> :module_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   locals -> Array[Symbol]
    #
    # Returns the `locals` attribute.
    # --
    # : () -> Array[Symbol]
    def locals: () -> Array[Symbol]

    # :category: Locations
    # :call-seq:
    #   module_keyword_loc -> Location
    #
    # Returns the Location represented by `module_keyword_loc`.
    # --
    # : () -> Location
    def module_keyword_loc: () -> Location

    # :category: Repository
    # Save the module_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_module_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   constant_path -> ConstantReadNode | ConstantPathNode | MissingNode
    #
    # Returns the `constant_path` attribute.
    # --
    # : () -> (ConstantReadNode | ConstantPathNode | MissingNode)
    def constant_path: () -> (ConstantReadNode | ConstantPathNode | MissingNode)

    # :call-seq:
    #   body -> StatementsNode | BeginNode | nil
    #
    # Returns the `body` attribute.
    # --
    # : () -> (StatementsNode | BeginNode)?
    def body: () -> (StatementsNode | BeginNode)?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location
    #
    # Returns the Location represented by `end_keyword_loc`.
    # --
    # : () -> Location
    def end_keyword_loc: () -> Location

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :call-seq:
    #   module_keyword -> String
    #
    # Slice the location of module_keyword_loc from the source.
    # --
    # : () -> String
    def module_keyword: () -> String

    # :call-seq:
    #   end_keyword -> String
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String
    def end_keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a multi-target expression.
  #
  #     a, (b, c) = 1, 2, 3
  #        ^^^^^^
  #
  # This can be a part of `MultiWriteNode` as above, or the target of a `for` loop
  #
  #     for a, b in [[1, 2], [3, 4]]
  #         ^^^^
  class MultiTargetNode < Node
    @rparen_loc: Location?

    @lparen_loc: Location?

    @rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]

    @rest: (ImplicitRestNode | SplatNode)?

    @lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]

    # Initialize a new MultiTargetNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode] lefts, (ImplicitRestNode | SplatNode)? rest, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode] rights, Location? lparen_loc, Location? rparen_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode] lefts, (ImplicitRestNode | SplatNode)? rest, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode] rights, Location? lparen_loc, Location? rparen_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> MultiTargetNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: (ImplicitRestNode | SplatNode)?, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?) -> MultiTargetNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: (ImplicitRestNode | SplatNode)?, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?) -> MultiTargetNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :multi_target_node
    def type: () -> :multi_target_node

    # See `Node.type`.
    # --
    # : () -> :multi_target_node
    def self.type: () -> :multi_target_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   lefts -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]
    #
    # Represents the targets expressions before a splat node.
    #
    #     a, (b, c, *) = 1, 2, 3, 4, 5
    #         ^^^^
    #
    # The splat node can be absent, in that case all target expressions are in the left field.
    #
    #     a, (b, c) = 1, 2, 3, 4, 5
    #         ^^^^
    # --
    # : () -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]
    def lefts: () -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]

    # :call-seq:
    #   rest -> ImplicitRestNode | SplatNode | nil
    #
    # Represents a splat node in the target expression.
    #
    #     a, (b, *c) = 1, 2, 3, 4
    #            ^^
    #
    # The variable can be empty, this results in a `SplatNode` with a `nil` expression field.
    #
    #     a, (b, *) = 1, 2, 3, 4
    #            ^
    #
    # If the `*` is omitted, this field will contain an `ImplicitRestNode`
    #
    #     a, (b,) = 1, 2, 3, 4
    #          ^
    # --
    # : () -> (ImplicitRestNode | SplatNode)?
    def rest: () -> (ImplicitRestNode | SplatNode)?

    # :call-seq:
    #   rights -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]
    #
    # Represents the targets expressions after a splat node.
    #
    #     a, (*, b, c) = 1, 2, 3, 4, 5
    #            ^^^^
    # --
    # : () -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]
    def rights: () -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]

    # :category: Locations
    # :call-seq:
    #   lparen_loc -> Location | nil
    #
    # The Location of the opening parenthesis.
    #
    #     a, (b, c) = 1, 2, 3
    #        ^
    # --
    # : () -> Location?
    def lparen_loc: () -> Location?

    # :category: Repository
    # Save the lparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_lparen_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   rparen_loc -> Location | nil
    #
    # The Location of the closing parenthesis.
    #
    #     a, (b, c) = 1, 2, 3
    #             ^
    # --
    # : () -> Location?
    def rparen_loc: () -> Location?

    # :category: Repository
    # Save the rparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_rparen_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   lparen -> String | nil
    #
    # Slice the location of lparen_loc from the source.
    # --
    # : () -> String?
    def lparen: () -> String?

    # :call-seq:
    #   rparen -> String | nil
    #
    # Slice the location of rparen_loc from the source.
    # --
    # : () -> String?
    def rparen: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a write to a multi-target expression.
  #
  #     a, b, c = 1, 2, 3
  #     ^^^^^^^^^^^^^^^^^
  class MultiWriteNode < Node
    @value: Prism::node

    @operator_loc: Location

    @rparen_loc: Location?

    @lparen_loc: Location?

    @rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]

    @rest: (ImplicitRestNode | SplatNode)?

    @lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]

    # Initialize a new MultiWriteNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode] lefts, (ImplicitRestNode | SplatNode)? rest, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode] rights, Location? lparen_loc, Location? rparen_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode] lefts, (ImplicitRestNode | SplatNode)? rest, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode] rights, Location? lparen_loc, Location? rparen_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> MultiWriteNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: (ImplicitRestNode | SplatNode)?, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?, ?operator_loc: Location, ?value: Prism::node) -> MultiWriteNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: (ImplicitRestNode | SplatNode)?, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?, ?operator_loc: Location, ?value: Prism::node) -> MultiWriteNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :multi_write_node
    def type: () -> :multi_write_node

    # See `Node.type`.
    # --
    # : () -> :multi_write_node
    def self.type: () -> :multi_write_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   lefts -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]
    #
    # Represents the targets expressions before a splat node.
    #
    #     a, b, * = 1, 2, 3, 4, 5
    #     ^^^^
    #
    # The splat node can be absent, in that case all target expressions are in the left field.
    #
    #     a, b, c = 1, 2, 3, 4, 5
    #     ^^^^^^^
    # --
    # : () -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]
    def lefts: () -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]

    # :call-seq:
    #   rest -> ImplicitRestNode | SplatNode | nil
    #
    # Represents a splat node in the target expression.
    #
    #     a, b, *c = 1, 2, 3, 4
    #           ^^
    #
    # The variable can be empty, this results in a `SplatNode` with a `nil` expression field.
    #
    #     a, b, * = 1, 2, 3, 4
    #           ^
    #
    # If the `*` is omitted, this field will contain an `ImplicitRestNode`
    #
    #     a, b, = 1, 2, 3, 4
    #         ^
    # --
    # : () -> (ImplicitRestNode | SplatNode)?
    def rest: () -> (ImplicitRestNode | SplatNode)?

    # :call-seq:
    #   rights -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]
    #
    # Represents the targets expressions after a splat node.
    #
    #     a, *, b, c = 1, 2, 3, 4, 5
    #           ^^^^
    # --
    # : () -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]
    def rights: () -> Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]

    # :category: Locations
    # :call-seq:
    #   lparen_loc -> Location | nil
    #
    # The Location of the opening parenthesis.
    #
    #     (a, b, c) = 1, 2, 3
    #     ^
    # --
    # : () -> Location?
    def lparen_loc: () -> Location?

    # :category: Repository
    # Save the lparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_lparen_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   rparen_loc -> Location | nil
    #
    # The Location of the closing parenthesis.
    #
    #     (a, b, c) = 1, 2, 3
    #             ^
    # --
    # : () -> Location?
    def rparen_loc: () -> Location?

    # :category: Repository
    # Save the rparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_rparen_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the operator.
    #
    #     a, b, c = 1, 2, 3
    #             ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # The value to write to the targets. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     a, b, c = 1, 2, 3
    #               ^^^^^^^
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   lparen -> String | nil
    #
    # Slice the location of lparen_loc from the source.
    # --
    # : () -> String?
    def lparen: () -> String?

    # :call-seq:
    #   rparen -> String | nil
    #
    # Slice the location of rparen_loc from the source.
    # --
    # : () -> String?
    def rparen: () -> String?

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `next` keyword.
  #
  #     next 1
  #     ^^^^^^
  class NextNode < Node
    @keyword_loc: Location

    @arguments: ArgumentsNode?

    # Initialize a new NextNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ArgumentsNode? arguments, Location keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, ArgumentsNode? arguments, Location keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> NextNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: ArgumentsNode?, ?keyword_loc: Location) -> NextNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: ArgumentsNode?, ?keyword_loc: Location) -> NextNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :next_node
    def type: () -> :next_node

    # See `Node.type`.
    # --
    # : () -> :next_node
    def self.type: () -> :next_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Returns the `arguments` attribute.
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `nil` keyword.
  #
  #     nil
  #     ^^^
  class NilNode < Node
    # Initialize a new NilNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> NilNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> NilNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> NilNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :nil_node
    def type: () -> :nil_node

    # See `Node.type`.
    # --
    # : () -> :nil_node
    def self.type: () -> :nil_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of `&nil` inside method arguments.
  #
  #     def a(&nil)
  #           ^^^^
  #     end
  class NoBlockParameterNode < Node
    @keyword_loc: Location

    @operator_loc: Location

    # Initialize a new NoBlockParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, Location keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, Location keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> NoBlockParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?keyword_loc: Location) -> NoBlockParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?keyword_loc: Location) -> NoBlockParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :no_block_parameter_node
    def type: () -> :no_block_parameter_node

    # See `Node.type`.
    # --
    # : () -> :no_block_parameter_node
    def self.type: () -> :no_block_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of `**nil` inside method arguments.
  #
  #     def a(**nil)
  #           ^^^^^
  #     end
  class NoKeywordsParameterNode < Node
    @keyword_loc: Location

    @operator_loc: Location

    # Initialize a new NoKeywordsParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, Location keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, Location keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> NoKeywordsParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?keyword_loc: Location) -> NoKeywordsParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?keyword_loc: Location) -> NoKeywordsParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :no_keywords_parameter_node
    def type: () -> :no_keywords_parameter_node

    # See `Node.type`.
    # --
    # : () -> :no_keywords_parameter_node
    def self.type: () -> :no_keywords_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
  #
  #     -> { _1 + _2 }
  #     ^^^^^^^^^^^^^^
  class NumberedParametersNode < Node
    @maximum: Integer

    # Initialize a new NumberedParametersNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Integer maximum) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Integer maximum) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> NumberedParametersNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?maximum: Integer) -> NumberedParametersNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?maximum: Integer) -> NumberedParametersNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :numbered_parameters_node
    def type: () -> :numbered_parameters_node

    # See `Node.type`.
    # --
    # : () -> :numbered_parameters_node
    def self.type: () -> :numbered_parameters_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   maximum -> Integer
    #
    # Returns the `maximum` attribute.
    # --
    # : () -> Integer
    def maximum: () -> Integer

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents reading a numbered reference to a capture in the previous match.
  #
  #     $1
  #     ^^
  class NumberedReferenceReadNode < Node
    @number: Integer

    # Initialize a new NumberedReferenceReadNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Integer number) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Integer number) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> NumberedReferenceReadNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?number: Integer) -> NumberedReferenceReadNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?number: Integer) -> NumberedReferenceReadNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :numbered_reference_read_node
    def type: () -> :numbered_reference_read_node

    # See `Node.type`.
    # --
    # : () -> :numbered_reference_read_node
    def self.type: () -> :numbered_reference_read_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   number -> Integer
    #
    # The (1-indexed, from the left) number of the capture group. Numbered references that are too large result in this value being `0`.
    #
    #     $1          # number `1`
    #
    #     $5432       # number `5432`
    #
    #     $4294967296 # number `0`
    # --
    # : () -> Integer
    def number: () -> Integer

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an optional keyword parameter to a method, block, or lambda definition.
  #
  #     def a(b: 1)
  #           ^^^^
  #     end
  class OptionalKeywordParameterNode < Node
    @value: Prism::node

    @name_loc: Location

    @name: Symbol

    # Initialize a new OptionalKeywordParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> OptionalKeywordParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node) -> OptionalKeywordParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node) -> OptionalKeywordParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :optional_keyword_parameter_node
    def type: () -> :optional_keyword_parameter_node

    # See `Node.type`.
    # --
    # : () -> :optional_keyword_parameter_node
    def self.type: () -> :optional_keyword_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a parameter name that has been repeated in the method signature
    # --
    # : () -> bool
    def repeated_parameter?: () -> bool

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an optional parameter to a method, block, or lambda definition.
  #
  #     def a(b = 1)
  #           ^^^^^
  #     end
  class OptionalParameterNode < Node
    @value: Prism::node

    @operator_loc: Location

    @name_loc: Location

    @name: Symbol

    # Initialize a new OptionalParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> OptionalParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> OptionalParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> OptionalParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :optional_parameter_node
    def type: () -> :optional_parameter_node

    # See `Node.type`.
    # --
    # : () -> :optional_parameter_node
    def self.type: () -> :optional_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a parameter name that has been repeated in the method signature
    # --
    # : () -> bool
    def repeated_parameter?: () -> bool

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   value -> Node
    #
    # Returns the `value` attribute.
    # --
    # : () -> Prism::node
    def value: () -> Prism::node

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `||` operator or the `or` keyword.
  #
  #     left or right
  #     ^^^^^^^^^^^^^
  class OrNode < Node
    @operator_loc: Location

    @right: Prism::node

    @left: Prism::node

    # Initialize a new OrNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> OrNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> OrNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> OrNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :or_node
    def type: () -> :or_node

    # See `Node.type`.
    # --
    # : () -> :or_node
    def self.type: () -> :or_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   left -> Node
    #
    # Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     left or right
    #     ^^^^
    #
    #     1 || 2
    #     ^
    # --
    # : () -> Prism::node
    def left: () -> Prism::node

    # :call-seq:
    #   right -> Node
    #
    # Represents the right side of the expression.
    #
    #     left || right
    #             ^^^^^
    #
    #     1 or 2
    #          ^
    # --
    # : () -> Prism::node
    def right: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `or` keyword or the `||` operator.
    #
    #     left or right
    #          ^^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the list of parameters on a method, block, or lambda definition.
  #
  #     def a(b, c, d)
  #           ^^^^^^^
  #     end
  class ParametersNode < Node
    @block: (BlockParameterNode | NoBlockParameterNode)?

    @keyword_rest: (KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode)?

    @keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode]

    @posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode | BlockParameterNode | NoBlockParameterNode]

    @rest: (RestParameterNode | ImplicitRestNode)?

    @optionals: Array[OptionalParameterNode]

    @requireds: Array[RequiredParameterNode | MultiTargetNode]

    # Initialize a new ParametersNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[RequiredParameterNode | MultiTargetNode] requireds, Array[OptionalParameterNode] optionals, (RestParameterNode | ImplicitRestNode)? rest, Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode | BlockParameterNode | NoBlockParameterNode] posts, Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode] keywords, (KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode)? keyword_rest, (BlockParameterNode | NoBlockParameterNode)? block) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[RequiredParameterNode | MultiTargetNode] requireds, Array[OptionalParameterNode] optionals, (RestParameterNode | ImplicitRestNode)? rest, Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode | BlockParameterNode | NoBlockParameterNode] posts, Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode] keywords, (KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode)? keyword_rest, (BlockParameterNode | NoBlockParameterNode)? block) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ParametersNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?requireds: Array[RequiredParameterNode | MultiTargetNode], ?optionals: Array[OptionalParameterNode], ?rest: (RestParameterNode | ImplicitRestNode)?, ?posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode | BlockParameterNode | NoBlockParameterNode], ?keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode], ?keyword_rest: (KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode)?, ?block: (BlockParameterNode | NoBlockParameterNode)?) -> ParametersNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?requireds: Array[RequiredParameterNode | MultiTargetNode], ?optionals: Array[OptionalParameterNode], ?rest: (RestParameterNode | ImplicitRestNode)?, ?posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode | BlockParameterNode | NoBlockParameterNode], ?keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode], ?keyword_rest: (KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode)?, ?block: (BlockParameterNode | NoBlockParameterNode)?) -> ParametersNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :parameters_node
    def type: () -> :parameters_node

    # See `Node.type`.
    # --
    # : () -> :parameters_node
    def self.type: () -> :parameters_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   requireds -> Array[RequiredParameterNode | MultiTargetNode]
    #
    # Returns the `requireds` attribute.
    # --
    # : () -> Array[RequiredParameterNode | MultiTargetNode]
    def requireds: () -> Array[RequiredParameterNode | MultiTargetNode]

    # :call-seq:
    #   optionals -> Array[OptionalParameterNode]
    #
    # Returns the `optionals` attribute.
    # --
    # : () -> Array[OptionalParameterNode]
    def optionals: () -> Array[OptionalParameterNode]

    # :call-seq:
    #   rest -> RestParameterNode | ImplicitRestNode | nil
    #
    # Returns the `rest` attribute.
    # --
    # : () -> (RestParameterNode | ImplicitRestNode)?
    def rest: () -> (RestParameterNode | ImplicitRestNode)?

    # :call-seq:
    #   posts -> Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode | BlockParameterNode | NoBlockParameterNode]
    #
    # Returns the `posts` attribute.
    # --
    # : () -> Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode | BlockParameterNode | NoBlockParameterNode]
    def posts: () -> Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode | BlockParameterNode | NoBlockParameterNode]

    # :call-seq:
    #   keywords -> Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode]
    #
    # Returns the `keywords` attribute.
    # --
    # : () -> Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode]
    def keywords: () -> Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode]

    # :call-seq:
    #   keyword_rest -> KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil
    #
    # Returns the `keyword_rest` attribute.
    # --
    # : () -> (KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode)?
    def keyword_rest: () -> (KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode)?

    # :call-seq:
    #   block -> BlockParameterNode | NoBlockParameterNode | nil
    #
    # Returns the `block` attribute.
    # --
    # : () -> (BlockParameterNode | NoBlockParameterNode)?
    def block: () -> (BlockParameterNode | NoBlockParameterNode)?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a parenthesized expression
  #
  #     (10 + 34)
  #     ^^^^^^^^^
  class ParenthesesNode < Node
    @closing_loc: Location

    @opening_loc: Location

    @body: Prism::node?

    # Initialize a new ParenthesesNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? body, Location opening_loc, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? body, Location opening_loc, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ParenthesesNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?body: Prism::node?, ?opening_loc: Location, ?closing_loc: Location) -> ParenthesesNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?body: Prism::node?, ?opening_loc: Location, ?closing_loc: Location) -> ParenthesesNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :parentheses_node
    def type: () -> :parentheses_node

    # See `Node.type`.
    # --
    # : () -> :parentheses_node
    def self.type: () -> :parentheses_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # parentheses that contain multiple potentially void statements
    # --
    # : () -> bool
    def multiple_statements?: () -> bool

    # :call-seq:
    #   body -> Node | nil
    #
    # Returns the `body` attribute.
    # --
    # : () -> Prism::node?
    def body: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
  #
  #     foo in ^(bar)
  #            ^^^^^^
  class PinnedExpressionNode < Node
    @rparen_loc: Location

    @lparen_loc: Location

    @operator_loc: Location

    @expression: Prism::node

    # Initialize a new PinnedExpressionNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node expression, Location operator_loc, Location lparen_loc, Location rparen_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node expression, Location operator_loc, Location lparen_loc, Location rparen_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> PinnedExpressionNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node, ?operator_loc: Location, ?lparen_loc: Location, ?rparen_loc: Location) -> PinnedExpressionNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node, ?operator_loc: Location, ?lparen_loc: Location, ?rparen_loc: Location) -> PinnedExpressionNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :pinned_expression_node
    def type: () -> :pinned_expression_node

    # See `Node.type`.
    # --
    # : () -> :pinned_expression_node
    def self.type: () -> :pinned_expression_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   expression -> Node
    #
    # The expression used in the pinned expression
    #
    #     foo in ^(bar)
    #              ^^^
    # --
    # : () -> Prism::node
    def expression: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `^` operator
    #
    #     foo in ^(bar)
    #            ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   lparen_loc -> Location
    #
    # The Location of the opening parenthesis.
    #
    #     foo in ^(bar)
    #             ^
    # --
    # : () -> Location
    def lparen_loc: () -> Location

    # :category: Repository
    # Save the lparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_lparen_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   rparen_loc -> Location
    #
    # The Location of the closing parenthesis.
    #
    #     foo in ^(bar)
    #                 ^
    # --
    # : () -> Location
    def rparen_loc: () -> Location

    # :category: Repository
    # Save the rparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_rparen_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # :call-seq:
    #   lparen -> String
    #
    # Slice the location of lparen_loc from the source.
    # --
    # : () -> String
    def lparen: () -> String

    # :call-seq:
    #   rparen -> String
    #
    # Slice the location of rparen_loc from the source.
    # --
    # : () -> String
    def rparen: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
  #
  #     foo in ^bar
  #            ^^^^
  class PinnedVariableNode < Node
    @operator_loc: Location

    @variable: LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode

    # Initialize a new PinnedVariableNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode) variable, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode variable, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> PinnedVariableNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?variable: (LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode), ?operator_loc: Location) -> PinnedVariableNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?variable: LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode, ?operator_loc: Location) -> PinnedVariableNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :pinned_variable_node
    def type: () -> :pinned_variable_node

    # See `Node.type`.
    # --
    # : () -> :pinned_variable_node
    def self.type: () -> :pinned_variable_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   variable -> LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode
    #
    # The variable used in the pinned expression
    #
    #     foo in ^bar
    #             ^^^
    # --
    # : () -> (LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode)
    def variable: () -> (LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode)

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `^` operator
    #
    #     foo in ^bar
    #            ^
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `END` keyword.
  #
  #     END { foo }
  #     ^^^^^^^^^^^
  class PostExecutionNode < Node
    @closing_loc: Location

    @opening_loc: Location

    @keyword_loc: Location

    @statements: StatementsNode?

    # Initialize a new PostExecutionNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> PostExecutionNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location) -> PostExecutionNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location) -> PostExecutionNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :post_execution_node
    def type: () -> :post_execution_node

    # See `Node.type`.
    # --
    # : () -> :post_execution_node
    def self.type: () -> :post_execution_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `BEGIN` keyword.
  #
  #     BEGIN { foo }
  #     ^^^^^^^^^^^^^
  class PreExecutionNode < Node
    @closing_loc: Location

    @opening_loc: Location

    @keyword_loc: Location

    @statements: StatementsNode?

    # Initialize a new PreExecutionNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> PreExecutionNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location) -> PreExecutionNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location) -> PreExecutionNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :pre_execution_node
    def type: () -> :pre_execution_node

    # See `Node.type`.
    # --
    # : () -> :pre_execution_node
    def self.type: () -> :pre_execution_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # The top level node of any parse tree.
  class ProgramNode < Node
    @statements: StatementsNode

    @locals: Array[Symbol]

    # Initialize a new ProgramNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, StatementsNode statements) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, StatementsNode statements) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ProgramNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?statements: StatementsNode) -> ProgramNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?statements: StatementsNode) -> ProgramNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :program_node
    def type: () -> :program_node

    # See `Node.type`.
    # --
    # : () -> :program_node
    def self.type: () -> :program_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   locals -> Array[Symbol]
    #
    # Returns the `locals` attribute.
    # --
    # : () -> Array[Symbol]
    def locals: () -> Array[Symbol]

    # :call-seq:
    #   statements -> StatementsNode
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode
    def statements: () -> StatementsNode

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `..` or `...` operators.
  #
  #     1..2
  #     ^^^^
  #
  #     c if a =~ /left/ ... b =~ /right/
  #          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class RangeNode < Node
    @operator_loc: Location

    @right: Prism::node?

    @left: Prism::node?

    # Initialize a new RangeNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node? left, Prism::node? right, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? left, Prism::node? right, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RangeNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location) -> RangeNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location) -> RangeNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :range_node
    def type: () -> :range_node

    # See `Node.type`.
    # --
    # : () -> :range_node
    def self.type: () -> :range_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # ... operator
    # --
    # : () -> bool
    def exclude_end?: () -> bool

    # :call-seq:
    #   left -> Node | nil
    #
    # The left-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     1...
    #     ^
    #
    #     hello...goodbye
    #     ^^^^^
    # --
    # : () -> Prism::node?
    def left: () -> Prism::node?

    # :call-seq:
    #   right -> Node | nil
    #
    # The right-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     ..5
    #       ^
    #
    #     1...foo
    #         ^^^
    # If neither right-hand or left-hand side was included, this will be a MissingNode.
    # --
    # : () -> Prism::node?
    def right: () -> Prism::node?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # The Location of the `..` or `...` operator.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a rational number literal.
  #
  #     1.0r
  #     ^^^^
  class RationalNode < Node
    @denominator: Integer

    @numerator: Integer

    # Initialize a new RationalNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Integer numerator, Integer denominator) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Integer numerator, Integer denominator) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RationalNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?numerator: Integer, ?denominator: Integer) -> RationalNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?numerator: Integer, ?denominator: Integer) -> RationalNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :rational_node
    def type: () -> :rational_node

    # See `Node.type`.
    # --
    # : () -> :rational_node
    def self.type: () -> :rational_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # 0b prefix
    # --
    # : () -> bool
    def binary?: () -> bool

    # :category: Flags
    # 0d or no prefix
    # --
    # : () -> bool
    def decimal?: () -> bool

    # :category: Flags
    # 0o or 0 prefix
    # --
    # : () -> bool
    def octal?: () -> bool

    # :category: Flags
    # 0x prefix
    # --
    # : () -> bool
    def hexadecimal?: () -> bool

    # :call-seq:
    #   numerator -> Integer
    #
    # The numerator of the rational number.
    #
    #     1.5r # numerator 3
    # --
    # : () -> Integer
    def numerator: () -> Integer

    # :call-seq:
    #   denominator -> Integer
    #
    # The denominator of the rational number.
    #
    #     1.5r # denominator 2
    # --
    # : () -> Integer
    def denominator: () -> Integer

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `redo` keyword.
  #
  #     redo
  #     ^^^^
  class RedoNode < Node
    # Initialize a new RedoNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RedoNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> RedoNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> RedoNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :redo_node
    def type: () -> :redo_node

    # See `Node.type`.
    # --
    # : () -> :redo_node
    def self.type: () -> :redo_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a regular expression literal with no interpolation.
  #
  #     /foo/i
  #     ^^^^^^
  class RegularExpressionNode < Node
    @unescaped: String

    @closing_loc: Location

    @content_loc: Location

    @opening_loc: Location

    # Initialize a new RegularExpressionNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RegularExpressionNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> RegularExpressionNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> RegularExpressionNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :regular_expression_node
    def type: () -> :regular_expression_node

    # See `Node.type`.
    # --
    # : () -> :regular_expression_node
    def self.type: () -> :regular_expression_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # i - ignores the case of characters when matching
    # --
    # : () -> bool
    def ignore_case?: () -> bool

    # :category: Flags
    # x - ignores whitespace and allows comments in regular expressions
    # --
    # : () -> bool
    def extended?: () -> bool

    # :category: Flags
    # m - allows $ to match the end of lines within strings
    # --
    # : () -> bool
    def multi_line?: () -> bool

    # :category: Flags
    # o - only interpolates values into the regular expression once
    # --
    # : () -> bool
    def once?: () -> bool

    # :category: Flags
    # e - forces the EUC-JP encoding
    # --
    # : () -> bool
    def euc_jp?: () -> bool

    # :category: Flags
    # n - forces the ASCII-8BIT encoding
    # --
    # : () -> bool
    def ascii_8bit?: () -> bool

    # :category: Flags
    # s - forces the Windows-31J encoding
    # --
    # : () -> bool
    def windows_31j?: () -> bool

    # :category: Flags
    # u - forces the UTF-8 encoding
    # --
    # : () -> bool
    def utf_8?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to UTF-8
    # --
    # : () -> bool
    def forced_utf8_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to binary
    # --
    # : () -> bool
    def forced_binary_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to US-ASCII
    # --
    # : () -> bool
    def forced_us_ascii_encoding?: () -> bool

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   content_loc -> Location
    #
    # Returns the Location represented by `content_loc`.
    # --
    # : () -> Location
    def content_loc: () -> Location

    # :category: Repository
    # Save the content_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_content_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   unescaped -> String
    #
    # Returns the `unescaped` attribute.
    # --
    # : () -> String
    def unescaped: () -> String

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   content -> String
    #
    # Slice the location of content_loc from the source.
    # --
    # : () -> String
    def content: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a required keyword parameter to a method, block, or lambda definition.
  #
  #     def a(b: )
  #           ^^
  #     end
  class RequiredKeywordParameterNode < Node
    @name_loc: Location

    @name: Symbol

    # Initialize a new RequiredKeywordParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RequiredKeywordParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location) -> RequiredKeywordParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location) -> RequiredKeywordParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :required_keyword_parameter_node
    def type: () -> :required_keyword_parameter_node

    # See `Node.type`.
    # --
    # : () -> :required_keyword_parameter_node
    def self.type: () -> :required_keyword_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a parameter name that has been repeated in the method signature
    # --
    # : () -> bool
    def repeated_parameter?: () -> bool

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location
    def name_loc: () -> Location

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_name_loc: (_Repository repository) -> Relocation::Entry

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a required parameter to a method, block, or lambda definition.
  #
  #     def a(b)
  #           ^
  #     end
  class RequiredParameterNode < Node
    @name: Symbol

    # Initialize a new RequiredParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RequiredParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> RequiredParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> RequiredParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :required_parameter_node
    def type: () -> :required_parameter_node

    # See `Node.type`.
    # --
    # : () -> :required_parameter_node
    def self.type: () -> :required_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a parameter name that has been repeated in the method signature
    # --
    # : () -> bool
    def repeated_parameter?: () -> bool

    # :call-seq:
    #   name -> Symbol
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol
    def name: () -> Symbol

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an expression modified with a rescue.
  #
  #     foo rescue nil
  #     ^^^^^^^^^^^^^^
  class RescueModifierNode < Node
    @rescue_expression: Prism::node

    @keyword_loc: Location

    @expression: Prism::node

    # Initialize a new RescueModifierNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Prism::node expression, Location keyword_loc, Prism::node rescue_expression) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node expression, Location keyword_loc, Prism::node rescue_expression) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RescueModifierNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node, ?keyword_loc: Location, ?rescue_expression: Prism::node) -> RescueModifierNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node, ?keyword_loc: Location, ?rescue_expression: Prism::node) -> RescueModifierNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :rescue_modifier_node
    def type: () -> :rescue_modifier_node

    # See `Node.type`.
    # --
    # : () -> :rescue_modifier_node
    def self.type: () -> :rescue_modifier_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   expression -> Node
    #
    # Returns the `expression` attribute.
    # --
    # : () -> Prism::node
    def expression: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   rescue_expression -> Node
    #
    # Returns the `rescue_expression` attribute.
    # --
    # : () -> Prism::node
    def rescue_expression: () -> Prism::node

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a rescue statement.
  #
  #     begin
  #     rescue Foo, *splat, Bar => ex
  #       foo
  #     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  #     end
  #
  # `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.
  class RescueNode < Node
    @subsequent: RescueNode?

    @statements: StatementsNode?

    @then_keyword_loc: Location?

    @reference: (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)?

    @operator_loc: Location?

    @exceptions: Array[Prism::node]

    @keyword_loc: Location

    # Initialize a new RescueNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Array[Prism::node] exceptions, Location? operator_loc, (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)? reference, Location? then_keyword_loc, StatementsNode? statements, RescueNode? subsequent) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Array[Prism::node] exceptions, Location? operator_loc, (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)? reference, Location? then_keyword_loc, StatementsNode? statements, RescueNode? subsequent) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RescueNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?exceptions: Array[Prism::node], ?operator_loc: Location?, ?reference: (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)?, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?subsequent: RescueNode?) -> RescueNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?exceptions: Array[Prism::node], ?operator_loc: Location?, ?reference: (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)?, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?subsequent: RescueNode?) -> RescueNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :rescue_node
    def type: () -> :rescue_node

    # See `Node.type`.
    # --
    # : () -> :rescue_node
    def self.type: () -> :rescue_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   exceptions -> Array[Node]
    #
    # Returns the `exceptions` attribute.
    # --
    # : () -> Array[Prism::node]
    def exceptions: () -> Array[Prism::node]

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location | nil
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location?
    def operator_loc: () -> Location?

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_operator_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   reference -> LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode | nil
    #
    # Returns the `reference` attribute.
    # --
    # : () -> (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)?
    def reference: () -> (LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode)?

    # :category: Locations
    # :call-seq:
    #   then_keyword_loc -> Location | nil
    #
    # Returns the Location represented by `then_keyword_loc`.
    # --
    # : () -> Location?
    def then_keyword_loc: () -> Location?

    # :category: Repository
    # Save the then_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_then_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :call-seq:
    #   subsequent -> RescueNode | nil
    #
    # Returns the `subsequent` attribute.
    # --
    # : () -> RescueNode?
    def subsequent: () -> RescueNode?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   operator -> String | nil
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String?
    def operator: () -> String?

    # :call-seq:
    #   then_keyword -> String | nil
    #
    # Slice the location of then_keyword_loc from the source.
    # --
    # : () -> String?
    def then_keyword: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a rest parameter to a method, block, or lambda definition.
  #
  #     def a(*b)
  #           ^^
  #     end
  class RestParameterNode < Node
    @operator_loc: Location

    @name_loc: Location?

    @name: Symbol?

    # Initialize a new RestParameterNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RestParameterNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> RestParameterNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> RestParameterNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :rest_parameter_node
    def type: () -> :rest_parameter_node

    # See `Node.type`.
    # --
    # : () -> :rest_parameter_node
    def self.type: () -> :rest_parameter_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a parameter name that has been repeated in the method signature
    # --
    # : () -> bool
    def repeated_parameter?: () -> bool

    # :call-seq:
    #   name -> Symbol | nil
    #
    # Returns the `name` attribute.
    # --
    # : () -> Symbol?
    def name: () -> Symbol?

    # :category: Locations
    # :call-seq:
    #   name_loc -> Location | nil
    #
    # Returns the Location represented by `name_loc`.
    # --
    # : () -> Location?
    def name_loc: () -> Location?

    # :category: Repository
    # Save the name_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_name_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `retry` keyword.
  #
  #     retry
  #     ^^^^^
  class RetryNode < Node
    # Initialize a new RetryNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> RetryNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> RetryNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> RetryNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :retry_node
    def type: () -> :retry_node

    # See `Node.type`.
    # --
    # : () -> :retry_node
    def self.type: () -> :retry_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `return` keyword.
  #
  #     return 1
  #     ^^^^^^^^
  class ReturnNode < Node
    @arguments: ArgumentsNode?

    @keyword_loc: Location

    # Initialize a new ReturnNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, ArgumentsNode? arguments) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, ArgumentsNode? arguments) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ReturnNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?arguments: ArgumentsNode?) -> ReturnNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?arguments: ArgumentsNode?) -> ReturnNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :return_node
    def type: () -> :return_node

    # See `Node.type`.
    # --
    # : () -> :return_node
    def self.type: () -> :return_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Returns the `arguments` attribute.
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the `self` keyword.
  #
  #     self
  #     ^^^^
  class SelfNode < Node
    # Initialize a new SelfNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> SelfNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> SelfNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SelfNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :self_node
    def type: () -> :self_node

    # See `Node.type`.
    # --
    # : () -> :self_node
    def self.type: () -> :self_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.
  #
  #     # shareable_constant_value: literal
  #     C = { a: 1 }
  #     ^^^^^^^^^^^^
  class ShareableConstantNode < Node
    @write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode

    # Initialize a new ShareableConstantNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, (ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode) write) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode write) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> ShareableConstantNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?write: (ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode)) -> ShareableConstantNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode) -> ShareableConstantNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :shareable_constant_node
    def type: () -> :shareable_constant_node

    # See `Node.type`.
    # --
    # : () -> :shareable_constant_node
    def self.type: () -> :shareable_constant_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # constant writes that should be modified with shareable constant value literal
    # --
    # : () -> bool
    def literal?: () -> bool

    # :category: Flags
    # constant writes that should be modified with shareable constant value experimental everything
    # --
    # : () -> bool
    def experimental_everything?: () -> bool

    # :category: Flags
    # constant writes that should be modified with shareable constant value experimental copy
    # --
    # : () -> bool
    def experimental_copy?: () -> bool

    # :call-seq:
    #   write -> ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode
    #
    # The constant write that should be modified with the shareability state.
    # --
    # : () -> (ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode)
    def write: () -> (ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode)

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a singleton class declaration involving the `class` keyword.
  #
  #     class << self end
  #     ^^^^^^^^^^^^^^^^^
  class SingletonClassNode < Node
    @end_keyword_loc: Location

    @body: (StatementsNode | BeginNode)?

    @expression: Prism::node

    @operator_loc: Location

    @class_keyword_loc: Location

    @locals: Array[Symbol]

    # Initialize a new SingletonClassNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location class_keyword_loc, Location operator_loc, Prism::node expression, (StatementsNode | BeginNode)? body, Location end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location class_keyword_loc, Location operator_loc, Prism::node expression, (StatementsNode | BeginNode)? body, Location end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> SingletonClassNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?class_keyword_loc: Location, ?operator_loc: Location, ?expression: Prism::node, ?body: (StatementsNode | BeginNode)?, ?end_keyword_loc: Location) -> SingletonClassNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?class_keyword_loc: Location, ?operator_loc: Location, ?expression: Prism::node, ?body: (StatementsNode | BeginNode)?, ?end_keyword_loc: Location) -> SingletonClassNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :singleton_class_node
    def type: () -> :singleton_class_node

    # See `Node.type`.
    # --
    # : () -> :singleton_class_node
    def self.type: () -> :singleton_class_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   locals -> Array[Symbol]
    #
    # Returns the `locals` attribute.
    # --
    # : () -> Array[Symbol]
    def locals: () -> Array[Symbol]

    # :category: Locations
    # :call-seq:
    #   class_keyword_loc -> Location
    #
    # Returns the Location represented by `class_keyword_loc`.
    # --
    # : () -> Location
    def class_keyword_loc: () -> Location

    # :category: Repository
    # Save the class_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_class_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   expression -> Node
    #
    # Returns the `expression` attribute.
    # --
    # : () -> Prism::node
    def expression: () -> Prism::node

    # :call-seq:
    #   body -> StatementsNode | BeginNode | nil
    #
    # Returns the `body` attribute.
    # --
    # : () -> (StatementsNode | BeginNode)?
    def body: () -> (StatementsNode | BeginNode)?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location
    #
    # Returns the Location represented by `end_keyword_loc`.
    # --
    # : () -> Location
    def end_keyword_loc: () -> Location

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   class_keyword -> String
    #
    # Slice the location of class_keyword_loc from the source.
    # --
    # : () -> String
    def class_keyword: () -> String

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # :call-seq:
    #   end_keyword -> String
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String
    def end_keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `__ENCODING__` keyword.
  #
  #     __ENCODING__
  #     ^^^^^^^^^^^^
  class SourceEncodingNode < Node
    # Initialize a new SourceEncodingNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> SourceEncodingNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> SourceEncodingNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SourceEncodingNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :source_encoding_node
    def type: () -> :source_encoding_node

    # See `Node.type`.
    # --
    # : () -> :source_encoding_node
    def self.type: () -> :source_encoding_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `__FILE__` keyword.
  #
  #     __FILE__
  #     ^^^^^^^^
  class SourceFileNode < Node
    @filepath: String

    # Initialize a new SourceFileNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, String filepath) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, String filepath) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> SourceFileNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?filepath: String) -> SourceFileNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?filepath: String) -> SourceFileNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :source_file_node
    def type: () -> :source_file_node

    # See `Node.type`.
    # --
    # : () -> :source_file_node
    def self.type: () -> :source_file_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # internal bytes forced the encoding to UTF-8
    # --
    # : () -> bool
    def forced_utf8_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to binary
    # --
    # : () -> bool
    def forced_binary_encoding?: () -> bool

    # :category: Flags
    # frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`
    # --
    # : () -> bool
    def frozen?: () -> bool

    # :category: Flags
    # mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`
    # --
    # : () -> bool
    def mutable?: () -> bool

    # :call-seq:
    #   filepath -> String
    #
    # Represents the file path being parsed. This corresponds directly to the `filepath` option given to the various `Prism.parse*` APIs.
    # --
    # : () -> String
    def filepath: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `__LINE__` keyword.
  #
  #     __LINE__
  #     ^^^^^^^^
  class SourceLineNode < Node
    # Initialize a new SourceLineNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> SourceLineNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> SourceLineNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SourceLineNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :source_line_node
    def type: () -> :source_line_node

    # See `Node.type`.
    # --
    # : () -> :source_line_node
    def self.type: () -> :source_line_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the splat operator.
  #
  #     [*a]
  #      ^^
  class SplatNode < Node
    @expression: Prism::node?

    @operator_loc: Location

    # Initialize a new SplatNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, Prism::node? expression) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, Prism::node? expression) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> SplatNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?expression: Prism::node?) -> SplatNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?expression: Prism::node?) -> SplatNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :splat_node
    def type: () -> :splat_node

    # See `Node.type`.
    # --
    # : () -> :splat_node
    def self.type: () -> :splat_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   operator_loc -> Location
    #
    # Returns the Location represented by `operator_loc`.
    # --
    # : () -> Location
    def operator_loc: () -> Location

    # :category: Repository
    # Save the operator_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_operator_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   expression -> Node | nil
    #
    # Returns the `expression` attribute.
    # --
    # : () -> Prism::node?
    def expression: () -> Prism::node?

    # :call-seq:
    #   operator -> String
    #
    # Slice the location of operator_loc from the source.
    # --
    # : () -> String
    def operator: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a set of statements contained within some scope.
  #
  #     foo; bar; baz
  #     ^^^^^^^^^^^^^
  class StatementsNode < Node
    @body: Array[Prism::node]

    # Initialize a new StatementsNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] body) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] body) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> StatementsNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?body: Array[Prism::node]) -> StatementsNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?body: Array[Prism::node]) -> StatementsNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :statements_node
    def type: () -> :statements_node

    # See `Node.type`.
    # --
    # : () -> :statements_node
    def self.type: () -> :statements_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   body -> Array[Node]
    #
    # Returns the `body` attribute.
    # --
    # : () -> Array[Prism::node]
    def body: () -> Array[Prism::node]

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
  #
  #     "foo"
  #     ^^^^^
  #
  #     %w[foo]
  #        ^^^
  #
  #     "foo #{bar} baz"
  #      ^^^^      ^^^^
  class StringNode < Node
    @unescaped: String

    @closing_loc: Location?

    @content_loc: Location

    @opening_loc: Location?

    # Initialize a new StringNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Location content_loc, Location? closing_loc, String unescaped) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Location content_loc, Location? closing_loc, String unescaped) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> StringNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?content_loc: Location, ?closing_loc: Location?, ?unescaped: String) -> StringNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?content_loc: Location, ?closing_loc: Location?, ?unescaped: String) -> StringNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :string_node
    def type: () -> :string_node

    # See `Node.type`.
    # --
    # : () -> :string_node
    def self.type: () -> :string_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # internal bytes forced the encoding to UTF-8
    # --
    # : () -> bool
    def forced_utf8_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to binary
    # --
    # : () -> bool
    def forced_binary_encoding?: () -> bool

    # :category: Flags
    # frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`
    # --
    # : () -> bool
    def frozen?: () -> bool

    # :category: Flags
    # mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`
    # --
    # : () -> bool
    def mutable?: () -> bool

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   content_loc -> Location
    #
    # Returns the Location represented by `content_loc`.
    # --
    # : () -> Location
    def content_loc: () -> Location

    # :category: Repository
    # Save the content_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_content_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   unescaped -> String
    #
    # Returns the `unescaped` attribute.
    # --
    # : () -> String
    def unescaped: () -> String

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   content -> String
    #
    # Slice the location of content_loc from the source.
    # --
    # : () -> String
    def content: () -> String

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `super` keyword with parentheses or arguments.
  #
  #     super()
  #     ^^^^^^^
  #
  #     super foo, bar
  #     ^^^^^^^^^^^^^^
  #
  # If no arguments are provided (except for a block), it would be a `ForwardingSuperNode` instead.
  class SuperNode < Node
    @block: (BlockNode | BlockArgumentNode)?

    @rparen_loc: Location?

    @arguments: ArgumentsNode?

    @lparen_loc: Location?

    @keyword_loc: Location

    # Initialize a new SuperNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc, (BlockNode | BlockArgumentNode)? block) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc, (BlockNode | BlockArgumentNode)? block) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> SuperNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?, ?block: (BlockNode | BlockArgumentNode)?) -> SuperNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?, ?block: (BlockNode | BlockArgumentNode)?) -> SuperNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :super_node
    def type: () -> :super_node

    # See `Node.type`.
    # --
    # : () -> :super_node
    def self.type: () -> :super_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   lparen_loc -> Location | nil
    #
    # Returns the Location represented by `lparen_loc`.
    # --
    # : () -> Location?
    def lparen_loc: () -> Location?

    # :category: Repository
    # Save the lparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_lparen_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Can be only `nil` when there are empty parentheses, like `super()`.
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   rparen_loc -> Location | nil
    #
    # Returns the Location represented by `rparen_loc`.
    # --
    # : () -> Location?
    def rparen_loc: () -> Location?

    # :category: Repository
    # Save the rparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_rparen_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   block -> BlockNode | BlockArgumentNode | nil
    #
    # Returns the `block` attribute.
    # --
    # : () -> (BlockNode | BlockArgumentNode)?
    def block: () -> (BlockNode | BlockArgumentNode)?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   lparen -> String | nil
    #
    # Slice the location of lparen_loc from the source.
    # --
    # : () -> String?
    def lparen: () -> String?

    # :call-seq:
    #   rparen -> String | nil
    #
    # Slice the location of rparen_loc from the source.
    # --
    # : () -> String?
    def rparen: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents a symbol literal or a symbol contained within a `%i` list.
  #
  #     :foo
  #     ^^^^
  #
  #     %i[foo]
  #        ^^^
  class SymbolNode < Node
    @unescaped: String

    @closing_loc: Location?

    @value_loc: Location?

    @opening_loc: Location?

    # Initialize a new SymbolNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Location? value_loc, Location? closing_loc, String unescaped) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Location? value_loc, Location? closing_loc, String unescaped) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> SymbolNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?value_loc: Location?, ?closing_loc: Location?, ?unescaped: String) -> SymbolNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?value_loc: Location?, ?closing_loc: Location?, ?unescaped: String) -> SymbolNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :symbol_node
    def type: () -> :symbol_node

    # See `Node.type`.
    # --
    # : () -> :symbol_node
    def self.type: () -> :symbol_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # internal bytes forced the encoding to UTF-8
    # --
    # : () -> bool
    def forced_utf8_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to binary
    # --
    # : () -> bool
    def forced_binary_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to US-ASCII
    # --
    # : () -> bool
    def forced_us_ascii_encoding?: () -> bool

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location | nil
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location?
    def opening_loc: () -> Location?

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_opening_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   value_loc -> Location | nil
    #
    # Returns the Location represented by `value_loc`.
    # --
    # : () -> Location?
    def value_loc: () -> Location?

    # :category: Repository
    # Save the value_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_value_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   unescaped -> String
    #
    # Returns the `unescaped` attribute.
    # --
    # : () -> String
    def unescaped: () -> String

    # :call-seq:
    #   opening -> String | nil
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String?
    def opening: () -> String?

    # :call-seq:
    #   value -> String | nil
    #
    # Slice the location of value_loc from the source.
    # --
    # : () -> String?
    def value: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the literal `true` keyword.
  #
  #     true
  #     ^^^^
  class TrueNode < Node
    # Initialize a new TrueNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, ) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> TrueNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ) -> TrueNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> TrueNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :true_node
    def type: () -> :true_node

    # See `Node.type`.
    # --
    # : () -> :true_node
    def self.type: () -> :true_node

    # : () -> String
    def inspect: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `undef` keyword.
  #
  #     undef :foo, :bar, :baz
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class UndefNode < Node
    @keyword_loc: Location

    @names: Array[SymbolNode | InterpolatedSymbolNode]

    # Initialize a new UndefNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Array[SymbolNode | InterpolatedSymbolNode] names, Location keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[SymbolNode | InterpolatedSymbolNode] names, Location keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> UndefNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?names: Array[SymbolNode | InterpolatedSymbolNode], ?keyword_loc: Location) -> UndefNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?names: Array[SymbolNode | InterpolatedSymbolNode], ?keyword_loc: Location) -> UndefNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :undef_node
    def type: () -> :undef_node

    # See `Node.type`.
    # --
    # : () -> :undef_node
    def self.type: () -> :undef_node

    # : () -> String
    def inspect: () -> String

    # :call-seq:
    #   names -> Array[SymbolNode | InterpolatedSymbolNode]
    #
    # Returns the `names` attribute.
    # --
    # : () -> Array[SymbolNode | InterpolatedSymbolNode]
    def names: () -> Array[SymbolNode | InterpolatedSymbolNode]

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `unless` keyword, either in the block form or the modifier form.
  #
  #     bar unless foo
  #     ^^^^^^^^^^^^^^
  #
  #     unless foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class UnlessNode < Node
    @end_keyword_loc: Location?

    @else_clause: ElseNode?

    @statements: StatementsNode?

    @then_keyword_loc: Location?

    @predicate: Prism::node

    @keyword_loc: Location

    # Initialize a new UnlessNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Prism::node predicate, Location? then_keyword_loc, StatementsNode? statements, ElseNode? else_clause, Location? end_keyword_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Prism::node predicate, Location? then_keyword_loc, StatementsNode? statements, ElseNode? else_clause, Location? end_keyword_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> UnlessNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?else_clause: ElseNode?, ?end_keyword_loc: Location?) -> UnlessNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?else_clause: ElseNode?, ?end_keyword_loc: Location?) -> UnlessNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :unless_node
    def type: () -> :unless_node

    # See `Node.type`.
    # --
    # : () -> :unless_node
    def self.type: () -> :unless_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # The Location of the `unless` keyword.
    #
    #     unless cond then bar end
    #     ^^^^^^
    #
    #     bar unless cond
    #         ^^^^^^
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   predicate -> Node
    #
    # The condition to be evaluated for the unless expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
    #
    #     unless cond then bar end
    #            ^^^^
    #
    #     bar unless cond
    #                ^^^^
    # --
    # : () -> Prism::node
    def predicate: () -> Prism::node

    # :category: Locations
    # :call-seq:
    #   then_keyword_loc -> Location | nil
    #
    # The Location of the `then` keyword, if present.
    #
    #     unless cond then bar end
    #                 ^^^^
    # --
    # : () -> Location?
    def then_keyword_loc: () -> Location?

    # :category: Repository
    # Save the then_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_then_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # The body of statements that will executed if the unless condition is
    # falsey. Will be `nil` if no body is provided.
    #
    #     unless cond then bar end
    #                      ^^^
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :call-seq:
    #   else_clause -> ElseNode | nil
    #
    # The else clause of the unless expression, if present.
    #
    #     unless cond then bar else baz end
    #                          ^^^^^^^^
    # --
    # : () -> ElseNode?
    def else_clause: () -> ElseNode?

    # :category: Locations
    # :call-seq:
    #   end_keyword_loc -> Location | nil
    #
    # The Location of the `end` keyword, if present.
    #
    #     unless cond then bar end
    #                          ^^^
    # --
    # : () -> Location?
    def end_keyword_loc: () -> Location?

    # :category: Repository
    # Save the end_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_end_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   then_keyword -> String | nil
    #
    # Slice the location of then_keyword_loc from the source.
    # --
    # : () -> String?
    def then_keyword: () -> String?

    # :call-seq:
    #   end_keyword -> String | nil
    #
    # Slice the location of end_keyword_loc from the source.
    # --
    # : () -> String?
    def end_keyword: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `until` keyword, either in the block form or the modifier form.
  #
  #     bar until foo
  #     ^^^^^^^^^^^^^
  #
  #     until foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class UntilNode < Node
    @statements: StatementsNode?

    @predicate: Prism::node

    @closing_loc: Location?

    @do_keyword_loc: Location?

    @keyword_loc: Location

    # Initialize a new UntilNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? do_keyword_loc, Location? closing_loc, Prism::node predicate, StatementsNode? statements) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? do_keyword_loc, Location? closing_loc, Prism::node predicate, StatementsNode? statements) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> UntilNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?do_keyword_loc: Location?, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?) -> UntilNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?do_keyword_loc: Location?, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?) -> UntilNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :until_node
    def type: () -> :until_node

    # See `Node.type`.
    # --
    # : () -> :until_node
    def self.type: () -> :until_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a loop after a begin statement, so the body is executed first before the condition
    # --
    # : () -> bool
    def begin_modifier?: () -> bool

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   do_keyword_loc -> Location | nil
    #
    # Returns the Location represented by `do_keyword_loc`.
    # --
    # : () -> Location?
    def do_keyword_loc: () -> Location?

    # :category: Repository
    # Save the do_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_do_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   predicate -> Node
    #
    # Returns the `predicate` attribute.
    # --
    # : () -> Prism::node
    def predicate: () -> Prism::node

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   do_keyword -> String | nil
    #
    # Slice the location of do_keyword_loc from the source.
    # --
    # : () -> String?
    def do_keyword: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `when` keyword within a case statement.
  #
  #     case true
  #     when true
  #     ^^^^^^^^^
  #     end
  class WhenNode < Node
    @statements: StatementsNode?

    @then_keyword_loc: Location?

    @conditions: Array[Prism::node]

    @keyword_loc: Location

    # Initialize a new WhenNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Array[Prism::node] conditions, Location? then_keyword_loc, StatementsNode? statements) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Array[Prism::node] conditions, Location? then_keyword_loc, StatementsNode? statements) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> WhenNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?conditions: Array[Prism::node], ?then_keyword_loc: Location?, ?statements: StatementsNode?) -> WhenNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?conditions: Array[Prism::node], ?then_keyword_loc: Location?, ?statements: StatementsNode?) -> WhenNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :when_node
    def type: () -> :when_node

    # See `Node.type`.
    # --
    # : () -> :when_node
    def self.type: () -> :when_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   conditions -> Array[Node]
    #
    # Returns the `conditions` attribute.
    # --
    # : () -> Array[Prism::node]
    def conditions: () -> Array[Prism::node]

    # :category: Locations
    # :call-seq:
    #   then_keyword_loc -> Location | nil
    #
    # Returns the Location represented by `then_keyword_loc`.
    # --
    # : () -> Location?
    def then_keyword_loc: () -> Location?

    # :category: Repository
    # Save the then_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_then_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   then_keyword -> String | nil
    #
    # Slice the location of then_keyword_loc from the source.
    # --
    # : () -> String?
    def then_keyword: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `while` keyword, either in the block form or the modifier form.
  #
  #     bar while foo
  #     ^^^^^^^^^^^^^
  #
  #     while foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class WhileNode < Node
    @statements: StatementsNode?

    @predicate: Prism::node

    @closing_loc: Location?

    @do_keyword_loc: Location?

    @keyword_loc: Location

    # Initialize a new WhileNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? do_keyword_loc, Location? closing_loc, Prism::node predicate, StatementsNode? statements) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? do_keyword_loc, Location? closing_loc, Prism::node predicate, StatementsNode? statements) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> WhileNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?do_keyword_loc: Location?, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?) -> WhileNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?do_keyword_loc: Location?, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?) -> WhileNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :while_node
    def type: () -> :while_node

    # See `Node.type`.
    # --
    # : () -> :while_node
    def self.type: () -> :while_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # a loop after a begin statement, so the body is executed first before the condition
    # --
    # : () -> bool
    def begin_modifier?: () -> bool

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   do_keyword_loc -> Location | nil
    #
    # Returns the Location represented by `do_keyword_loc`.
    # --
    # : () -> Location?
    def do_keyword_loc: () -> Location?

    # :category: Repository
    # Save the do_keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_do_keyword_loc: (_Repository repository) -> Relocation::Entry?

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location | nil
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location?
    def closing_loc: () -> Location?

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_closing_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   predicate -> Node
    #
    # Returns the `predicate` attribute.
    # --
    # : () -> Prism::node
    def predicate: () -> Prism::node

    # :call-seq:
    #   statements -> StatementsNode | nil
    #
    # Returns the `statements` attribute.
    # --
    # : () -> StatementsNode?
    def statements: () -> StatementsNode?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   do_keyword -> String | nil
    #
    # Slice the location of do_keyword_loc from the source.
    # --
    # : () -> String?
    def do_keyword: () -> String?

    # :call-seq:
    #   closing -> String | nil
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String?
    def closing: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents an xstring literal with no interpolation.
  #
  #     `foo`
  #     ^^^^^
  class XStringNode < Node
    @unescaped: String

    @closing_loc: Location

    @content_loc: Location

    @opening_loc: Location

    # Initialize a new XStringNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> XStringNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> XStringNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> XStringNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :x_string_node
    def type: () -> :x_string_node

    # See `Node.type`.
    # --
    # : () -> :x_string_node
    def self.type: () -> :x_string_node

    # : () -> String
    def inspect: () -> String

    # :category: Flags
    # internal bytes forced the encoding to UTF-8
    # --
    # : () -> bool
    def forced_utf8_encoding?: () -> bool

    # :category: Flags
    # internal bytes forced the encoding to binary
    # --
    # : () -> bool
    def forced_binary_encoding?: () -> bool

    # :category: Locations
    # :call-seq:
    #   opening_loc -> Location
    #
    # Returns the Location represented by `opening_loc`.
    # --
    # : () -> Location
    def opening_loc: () -> Location

    # :category: Repository
    # Save the opening_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_opening_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   content_loc -> Location
    #
    # Returns the Location represented by `content_loc`.
    # --
    # : () -> Location
    def content_loc: () -> Location

    # :category: Repository
    # Save the content_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_content_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   closing_loc -> Location
    #
    # Returns the Location represented by `closing_loc`.
    # --
    # : () -> Location
    def closing_loc: () -> Location

    # :category: Repository
    # Save the closing_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_closing_loc: (_Repository repository) -> Relocation::Entry

    # :call-seq:
    #   unescaped -> String
    #
    # Returns the `unescaped` attribute.
    # --
    # : () -> String
    def unescaped: () -> String

    # :call-seq:
    #   opening -> String
    #
    # Slice the location of opening_loc from the source.
    # --
    # : () -> String
    def opening: () -> String

    # :call-seq:
    #   content -> String
    #
    # Slice the location of content_loc from the source.
    # --
    # : () -> String
    def content: () -> String

    # :call-seq:
    #   closing -> String
    #
    # Slice the location of closing_loc from the source.
    # --
    # : () -> String
    def closing: () -> String

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Represents the use of the `yield` keyword.
  #
  #     yield 1
  #     ^^^^^^^
  class YieldNode < Node
    @rparen_loc: Location?

    @arguments: ArgumentsNode?

    @lparen_loc: Location?

    @keyword_loc: Location

    # Initialize a new YieldNode node.
    # --
    # : (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc) -> void
    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc) -> void

    # See Node.accept.
    # --
    # : (_Visitor visitor) -> untyped
    def accept: (_Visitor visitor) -> untyped

    # See Node.child_nodes.
    # --
    # : () -> Array[node?]
    def child_nodes: () -> Array[node?]

    # See Node.each_child_node.
    # --
    # : () { (node) -> void } -> void
    # : () -> Enumerator[node, void]
    def each_child_node: () { (node) -> void } -> void
                       | () -> Enumerator[node, void]

    # See Node.compact_child_nodes.
    # --
    # : () -> Array[node]
    def compact_child_nodes: () -> Array[node]

    # See Node.comment_targets.
    # --
    # : () -> Array[node | Location]
    def comment_targets: () -> Array[node | Location]

    # :call-seq:
    #   copy(**fields) -> YieldNode
    #
    # Creates a copy of self with the given fields, using self as the template.
    # --
    # : (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?) -> YieldNode
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?) -> YieldNode

    alias deconstruct child_nodes

    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # See `Node#type`.
    # --
    # : () -> :yield_node
    def type: () -> :yield_node

    # See `Node.type`.
    # --
    # : () -> :yield_node
    def self.type: () -> :yield_node

    # : () -> String
    def inspect: () -> String

    # :category: Locations
    # :call-seq:
    #   keyword_loc -> Location
    #
    # Returns the Location represented by `keyword_loc`.
    # --
    # : () -> Location
    def keyword_loc: () -> Location

    # :category: Repository
    # Save the keyword_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry
    def save_keyword_loc: (_Repository repository) -> Relocation::Entry

    # :category: Locations
    # :call-seq:
    #   lparen_loc -> Location | nil
    #
    # Returns the Location represented by `lparen_loc`.
    # --
    # : () -> Location?
    def lparen_loc: () -> Location?

    # :category: Repository
    # Save the lparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_lparen_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   arguments -> ArgumentsNode | nil
    #
    # Returns the `arguments` attribute.
    # --
    # : () -> ArgumentsNode?
    def arguments: () -> ArgumentsNode?

    # :category: Locations
    # :call-seq:
    #   rparen_loc -> Location | nil
    #
    # Returns the Location represented by `rparen_loc`.
    # --
    # : () -> Location?
    def rparen_loc: () -> Location?

    # :category: Repository
    # Save the rparen_loc location using the given saved source so that
    # it can be retrieved later.
    # --
    # : (_Repository repository) -> Relocation::Entry?
    def save_rparen_loc: (_Repository repository) -> Relocation::Entry?

    # :call-seq:
    #   keyword -> String
    #
    # Slice the location of keyword_loc from the source.
    # --
    # : () -> String
    def keyword: () -> String

    # :call-seq:
    #   lparen -> String | nil
    #
    # Slice the location of lparen_loc from the source.
    # --
    # : () -> String?
    def lparen: () -> String?

    # :call-seq:
    #   rparen -> String | nil
    #
    # Slice the location of rparen_loc from the source.
    # --
    # : () -> String?
    def rparen: () -> String?

    # : (untyped other) -> bool
    def ===: (untyped other) -> bool
  end

  # Flags for arguments nodes.
  module ArgumentsNodeFlags
    # if the arguments contain forwarding
    CONTAINS_FORWARDING: untyped

    # if the arguments contain keywords
    CONTAINS_KEYWORDS: untyped

    # if the arguments contain a keyword splat
    CONTAINS_KEYWORD_SPLAT: untyped

    # if the arguments contain a splat
    CONTAINS_SPLAT: untyped

    # if the arguments contain multiple splats
    CONTAINS_MULTIPLE_SPLATS: untyped
  end

  # Flags for array nodes.
  module ArrayNodeFlags
    # if array contains splat nodes
    CONTAINS_SPLAT: untyped
  end

  # Flags for call nodes.
  module CallNodeFlags
    # &. operator
    SAFE_NAVIGATION: untyped

    # a call that could have been a local variable
    VARIABLE_CALL: untyped

    # a call that is an attribute write, so the value being written should be returned
    ATTRIBUTE_WRITE: untyped

    # a call that ignores method visibility
    IGNORE_VISIBILITY: untyped
  end

  # Flags for nodes that have unescaped content.
  module EncodingFlags
    # internal bytes forced the encoding to UTF-8
    FORCED_UTF8_ENCODING: untyped

    # internal bytes forced the encoding to binary
    FORCED_BINARY_ENCODING: untyped
  end

  # Flags for integer nodes that correspond to the base of the integer.
  module IntegerBaseFlags
    # 0b prefix
    BINARY: untyped

    # 0d or no prefix
    DECIMAL: untyped

    # 0o or 0 prefix
    OCTAL: untyped

    # 0x prefix
    HEXADECIMAL: untyped
  end

  # Flags for interpolated string nodes that indicated mutability if they are also marked as literals.
  module InterpolatedStringNodeFlags
    # frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`
    FROZEN: untyped

    # mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`
    MUTABLE: untyped
  end

  # Flags for keyword hash nodes.
  module KeywordHashNodeFlags
    # a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments
    SYMBOL_KEYS: untyped
  end

  # Flags for while and until loop nodes.
  module LoopFlags
    # a loop after a begin statement, so the body is executed first before the condition
    BEGIN_MODIFIER: untyped
  end

  # Flags for parameter nodes.
  module ParameterFlags
    # a parameter name that has been repeated in the method signature
    REPEATED_PARAMETER: untyped
  end

  # Flags for parentheses nodes.
  module ParenthesesNodeFlags
    # parentheses that contain multiple potentially void statements
    MULTIPLE_STATEMENTS: untyped
  end

  # Flags for range and flip-flop nodes.
  module RangeFlags
    # ... operator
    EXCLUDE_END: untyped
  end

  # Flags for regular expression and match last line nodes.
  module RegularExpressionFlags
    # i - ignores the case of characters when matching
    IGNORE_CASE: untyped

    # x - ignores whitespace and allows comments in regular expressions
    EXTENDED: untyped

    # m - allows $ to match the end of lines within strings
    MULTI_LINE: untyped

    # o - only interpolates values into the regular expression once
    ONCE: untyped

    # e - forces the EUC-JP encoding
    EUC_JP: untyped

    # n - forces the ASCII-8BIT encoding
    ASCII_8BIT: untyped

    # s - forces the Windows-31J encoding
    WINDOWS_31J: untyped

    # u - forces the UTF-8 encoding
    UTF_8: untyped

    # internal bytes forced the encoding to UTF-8
    FORCED_UTF8_ENCODING: untyped

    # internal bytes forced the encoding to binary
    FORCED_BINARY_ENCODING: untyped

    # internal bytes forced the encoding to US-ASCII
    FORCED_US_ASCII_ENCODING: untyped
  end

  # Flags for shareable constant nodes.
  module ShareableConstantNodeFlags
    # constant writes that should be modified with shareable constant value literal
    LITERAL: untyped

    # constant writes that should be modified with shareable constant value experimental everything
    EXPERIMENTAL_EVERYTHING: untyped

    # constant writes that should be modified with shareable constant value experimental copy
    EXPERIMENTAL_COPY: untyped
  end

  # Flags for string nodes.
  module StringFlags
    # internal bytes forced the encoding to UTF-8
    FORCED_UTF8_ENCODING: untyped

    # internal bytes forced the encoding to binary
    FORCED_BINARY_ENCODING: untyped

    # frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`
    FROZEN: untyped

    # mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`
    MUTABLE: untyped
  end

  # Flags for symbol nodes.
  module SymbolFlags
    # internal bytes forced the encoding to UTF-8
    FORCED_UTF8_ENCODING: untyped

    # internal bytes forced the encoding to binary
    FORCED_BINARY_ENCODING: untyped

    # internal bytes forced the encoding to US-ASCII
    FORCED_US_ASCII_ENCODING: untyped
  end

  # The flags that are common to all nodes.
  module NodeFlags
    # A flag to indicate that the node is a candidate to emit a :line event
    # through tracepoint when compiled.
    NEWLINE: ::Integer

    # A flag to indicate that the value that the node represents is a value that
    # can be determined at parse-time.
    STATIC_LITERAL: ::Integer
  end
end
