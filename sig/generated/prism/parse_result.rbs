# Generated from lib/prism/parse_result.rb with RBS::Inline

module Prism
  # An internal interface for a cache that can be used to compute code
  # units from byte offsets.
  interface _CodeUnitsCache
    def []: (Integer byte_offset) -> Integer
  end

  # This represents a source of Ruby code that has been parsed. It is used in
  # conjunction with locations to allow them to resolve line numbers and source
  # ranges.
  class Source
    # Create a new source object with the given source code. This method should
    # be used instead of `new` and it will return either a `Source` or a
    # specialized and more performant `ASCIISource` if no multibyte characters
    # are present in the source code.
    # --
    # : (String source, ?Integer start_line, ?Array[Integer] offsets) -> Source
    def self.for: (String source, ?Integer start_line, ?Array[Integer] offsets) -> Source

    # The source code that this source object represents.
    attr_reader source: String

    # The line number where this source starts.
    attr_reader start_line: Integer

    # The list of newline byte offsets in the source code.
    attr_reader offsets: Array[Integer]

    # Create a new source object with the given source code.
    # --
    # : (String source, ?Integer start_line, ?Array[Integer] offsets) -> void
    def initialize: (String source, ?Integer start_line, ?Array[Integer] offsets) -> void

    # Replace the value of start_line with the given value.
    # --
    # : (Integer start_line) -> void
    def replace_start_line: (Integer start_line) -> void

    # Replace the value of offsets with the given value.
    # --
    # : (Array[Integer] offsets) -> void
    def replace_offsets: (Array[Integer] offsets) -> void

    # Returns the encoding of the source code, which is set by parameters to the
    # parser or by the encoding magic comment.
    # --
    # : () -> Encoding
    def encoding: () -> Encoding

    # Returns the lines of the source code as an array of strings.
    # --
    # : () -> Array[String]
    def lines: () -> Array[String]

    # Perform a byteslice on the source code using the given byte offset and
    # byte length.
    # --
    # : (Integer byte_offset, Integer length) -> String
    def slice: (Integer byte_offset, Integer length) -> String

    # Converts the line number and column in bytes to a byte offset.
    # --
    # : (Integer line, Integer column) -> Integer
    def byte_offset: (Integer line, Integer column) -> Integer

    # Binary search through the offsets to find the line number for the given
    # byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def line: (Integer byte_offset) -> Integer

    # Return the byte offset of the start of the line corresponding to the given
    # byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def line_start: (Integer byte_offset) -> Integer

    # Returns the byte offset of the end of the line corresponding to the given
    # byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def line_end: (Integer byte_offset) -> Integer

    # Return the column in bytes for the given byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def column: (Integer byte_offset) -> Integer

    # Return the character offset for the given byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def character_offset: (Integer byte_offset) -> Integer

    # Return the column in characters for the given byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def character_column: (Integer byte_offset) -> Integer

    # Returns the offset from the start of the file for the given byte offset
    # counting in code units for the given encoding.
    #
    # This method is tested with UTF-8, UTF-16, and UTF-32. If there is the
    # concept of code units that differs from the number of characters in other
    # encodings, it is not captured here.
    #
    # We purposefully replace invalid and undefined characters with replacement
    # characters in this conversion. This happens for two reasons. First, it's
    # possible that the given byte offset will not occur on a character
    # boundary. Second, it's possible that the source code will contain a
    # character that has no equivalent in the given encoding.
    # --
    # : (Integer byte_offset, Encoding encoding) -> Integer
    def code_units_offset: (Integer byte_offset, Encoding encoding) -> Integer

    # Generate a cache that targets a specific encoding for calculating code
    # unit offsets.
    # --
    # : (Encoding encoding) -> CodeUnitsCache
    def code_units_cache: (Encoding encoding) -> CodeUnitsCache

    # Returns the column in code units for the given encoding for the
    # given byte offset.
    # --
    # : (Integer byte_offset, Encoding encoding) -> Integer
    def code_units_column: (Integer byte_offset, Encoding encoding) -> Integer

    # Freeze this object and the objects it contains.
    # --
    # : () -> void
    def deep_freeze: () -> void

    private

    # Binary search through the offsets to find the line number for the given
    # byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def find_line: (Integer byte_offset) -> Integer
  end

  # A cache that can be used to quickly compute code unit offsets from byte
  # offsets. It purposefully provides only a single #[] method to access the
  # cache in order to minimize surface area.
  #
  # Note that there are some known issues here that may or may not be addressed
  # in the future:
  #
  # * The first is that there are issues when the cache computes values that are
  #   not on character boundaries. This can result in subsequent computations
  #   being off by one or more code units.
  # * The second is that this cache is currently unbounded. In theory we could
  #   introduce some kind of LRU cache to limit the number of entries, but this
  #   has not yet been implemented.
  class CodeUnitsCache
    class UTF16Counter
      @source: String

      @encoding: Encoding

      # : (String source, Encoding encoding) -> void
      def initialize: (String source, Encoding encoding) -> void

      # : (Integer byte_offset, Integer byte_length) -> Integer
      def count: (Integer byte_offset, Integer byte_length) -> Integer
    end

    class LengthCounter
      @source: String

      @encoding: Encoding

      # : (String source, Encoding encoding) -> void
      def initialize: (String source, Encoding encoding) -> void

      # : (Integer byte_offset, Integer byte_length) -> Integer
      def count: (Integer byte_offset, Integer byte_length) -> Integer
    end

    @source: String

    @counter: UTF16Counter | LengthCounter

    @cache: Hash[Integer, Integer]

    @offsets: Array[Integer]

    # Initialize a new cache with the given source and encoding.
    # --
    # : (String source, Encoding encoding) -> void
    def initialize: (String source, Encoding encoding) -> void

    # Retrieve the code units offset from the given byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def []: (Integer byte_offset) -> Integer
  end

  # Specialized version of Prism::Source for source code that includes ASCII
  # characters only. This class is used to apply performance optimizations that
  # cannot be applied to sources that include multibyte characters.
  #
  # In the extremely rare case that a source includes multi-byte characters but
  # is marked as binary because of a magic encoding comment and it cannot be
  # eagerly converted to UTF-8, this class will be used as well. This is because
  # at that point we will treat everything as single-byte characters.
  class ASCIISource < Source
    # Return the character offset for the given byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def character_offset: (Integer byte_offset) -> Integer

    # Return the column in characters for the given byte offset.
    # --
    # : (Integer byte_offset) -> Integer
    def character_column: (Integer byte_offset) -> Integer

    # Returns the offset from the start of the file for the given byte offset
    # counting in code units for the given encoding.
    #
    # This method is tested with UTF-8, UTF-16, and UTF-32. If there is the
    # concept of code units that differs from the number of characters in other
    # encodings, it is not captured here.
    # --
    # : (Integer byte_offset, Encoding encoding) -> Integer
    def code_units_offset: (Integer byte_offset, Encoding encoding) -> Integer

    # Returns a cache that is the identity function in order to maintain the
    # same interface. We can do this because code units are always equivalent to
    # byte offsets for ASCII-only sources.
    # --
    # : (Encoding encoding) -> _CodeUnitsCache
    def code_units_cache: (Encoding encoding) -> _CodeUnitsCache

    # Specialized version of `code_units_column` that does not depend on
    # `code_units_offset`, which is a more expensive operation. This is
    # essentially the same as `Prism::Source#column`.
    # --
    # : (Integer byte_offset, Encoding encoding) -> Integer
    def code_units_column: (Integer byte_offset, Encoding encoding) -> Integer
  end

  # This represents a location in the source.
  class Location
    # A Source object that is used to determine more information from the given
    # offset and length.
    attr_reader source: Source

    # The byte offset from the beginning of the source where this location
    # starts.
    attr_reader start_offset: Integer

    # The length of this location in bytes.
    attr_reader length: Integer

    @trailing_comments: Array[Comment]?

    @leading_comments: Array[Comment]?

    # Create a new location object with the given source, start byte offset, and
    # byte length.
    # --
    # : (Source source, Integer start_offset, Integer length) -> void
    def initialize: (Source source, Integer start_offset, Integer length) -> void

    # These are the comments that are associated with this location that exist
    # before the start of this location.
    # --
    # : () -> Array[Comment]
    def leading_comments: () -> Array[Comment]

    # Attach a comment to the leading comments of this location.
    # --
    # : (Comment comment) -> void
    def leading_comment: (Comment comment) -> void

    # These are the comments that are associated with this location that exist
    # after the end of this location.
    # --
    # : () -> Array[Comment]
    def trailing_comments: () -> Array[Comment]

    # Attach a comment to the trailing comments of this location.
    # --
    # : (Comment comment) -> void
    def trailing_comment: (Comment comment) -> void

    # Returns all comments that are associated with this location (both leading
    # and trailing comments).
    # --
    # : () -> Array[Comment]
    def comments: () -> Array[Comment]

    # Create a new location object with the given options.
    # --
    # : (?source: Source, ?start_offset: Integer, ?length: Integer) -> Location
    def copy: (?source: Source, ?start_offset: Integer, ?length: Integer) -> Location

    # Returns a new location that is the result of chopping off the last byte.
    # --
    # : () -> Location
    def chop: () -> Location

    # Returns a string representation of this location.
    # --
    # : () -> String
    def inspect: () -> String

    # Returns all of the lines of the source code associated with this location.
    # --
    # : () -> Array[String]
    def source_lines: () -> Array[String]

    # The source code that this location represents.
    # --
    # : () -> String
    def slice: () -> String

    # The source code that this location represents starting from the beginning
    # of the line that this location starts on to the end of the line that this
    # location ends on.
    # --
    # : () -> String
    def slice_lines: () -> String

    # The character offset from the beginning of the source where this location
    # starts.
    # --
    # : () -> Integer
    def start_character_offset: () -> Integer

    # The offset from the start of the file in code units of the given encoding.
    # --
    # : (Encoding encoding) -> Integer
    def start_code_units_offset: (Encoding encoding) -> Integer

    # The start offset from the start of the file in code units using the given
    # cache to fetch or calculate the value.
    # --
    # : (_CodeUnitsCache cache) -> Integer
    def cached_start_code_units_offset: (_CodeUnitsCache cache) -> Integer

    # The byte offset from the beginning of the source where this location ends.
    # --
    # : () -> Integer
    def end_offset: () -> Integer

    # The character offset from the beginning of the source where this location
    # ends.
    # --
    # : () -> Integer
    def end_character_offset: () -> Integer

    # The offset from the start of the file in code units of the given encoding.
    # --
    # : (Encoding encoding) -> Integer
    def end_code_units_offset: (Encoding encoding) -> Integer

    # The end offset from the start of the file in code units using the given
    # cache to fetch or calculate the value.
    # --
    # : (_CodeUnitsCache cache) -> Integer
    def cached_end_code_units_offset: (_CodeUnitsCache cache) -> Integer

    # The line number where this location starts.
    # --
    # : () -> Integer
    def start_line: () -> Integer

    # The content of the line where this location starts before this location.
    # --
    # : () -> String
    def start_line_slice: () -> String

    # The line number where this location ends.
    # --
    # : () -> Integer
    def end_line: () -> Integer

    # The column in bytes where this location starts from the start of
    # the line.
    # --
    # : () -> Integer
    def start_column: () -> Integer

    # The column in characters where this location ends from the start of
    # the line.
    # --
    # : () -> Integer
    def start_character_column: () -> Integer

    # The column in code units of the given encoding where this location
    # starts from the start of the line.
    # --
    # : (?Encoding encoding) -> Integer
    def start_code_units_column: (?Encoding encoding) -> Integer

    # The start column in code units using the given cache to fetch or calculate
    # the value.
    # --
    # : (_CodeUnitsCache cache) -> Integer
    def cached_start_code_units_column: (_CodeUnitsCache cache) -> Integer

    # The column in bytes where this location ends from the start of the
    # line.
    # --
    # : () -> Integer
    def end_column: () -> Integer

    # The column in characters where this location ends from the start of
    # the line.
    # --
    # : () -> Integer
    def end_character_column: () -> Integer

    # The column in code units of the given encoding where this location
    # ends from the start of the line.
    # --
    # : (?Encoding encoding) -> Integer
    def end_code_units_column: (?Encoding encoding) -> Integer

    # The end column in code units using the given cache to fetch or calculate
    # the value.
    # --
    # : (_CodeUnitsCache cache) -> Integer
    def cached_end_code_units_column: (_CodeUnitsCache cache) -> Integer

    # Implement the hash pattern matching interface for Location.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # Implement the pretty print interface for Location.
    # --
    # : (PP q) -> void
    def pretty_print: (PP q) -> void

    # Returns true if the given other location is equal to this location.
    # --
    # : (untyped other) -> bool
    def ==: (untyped other) -> bool

    # Returns a new location that stretches from this location to the given
    # other location. Raises an error if this location is not before the other
    # location or if they don't share the same source.
    # --
    # : (Location other) -> Location
    def join: (Location other) -> Location

    # Join this location with the first occurrence of the string in the source
    # that occurs after this location on the same line, and return the new
    # location. This will raise an error if the string does not exist.
    # --
    # : (String string) -> Location
    def adjoin: (String string) -> Location
  end

  # This represents a comment that was encountered during parsing. It is the
  # base class for all comment types.
  class Comment
    # The Location of this comment in the source.
    attr_reader location: Location

    # Create a new comment object with the given location.
    # --
    # : (Location location) -> void
    def initialize: (Location location) -> void

    # Implement the hash pattern matching interface for Comment.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # Returns the content of the comment by slicing it from the source code.
    # --
    # : () -> String
    def slice: () -> String

    # Returns true if this comment happens on the same line as other code and
    # false if the comment is by itself. This can only be true for inline
    # comments and should be false for block comments.
    # --
    # : () -> bool
    def trailing?: () -> bool
  end

  # InlineComment objects are the most common. They correspond to comments in
  # the source file like this one that start with #.
  class InlineComment < Comment
    # Returns true if this comment happens on the same line as other code and
    # false if the comment is by itself.
    # --
    # : () -> bool
    def trailing?: () -> bool

    # Returns a string representation of this comment.
    # --
    # : () -> String
    def inspect: () -> String
  end

  # EmbDocComment objects correspond to comments that are surrounded by =begin
  # and =end.
  class EmbDocComment < Comment
    # Returns false. This can only be true for inline comments.
    # --
    # : () -> bool
    def trailing?: () -> bool

    # Returns a string representation of this comment.
    # --
    # : () -> String
    def inspect: () -> String
  end

  # This represents a magic comment that was encountered during parsing.
  class MagicComment
    # A Location object representing the location of the key in the source.
    attr_reader key_loc: Location

    # A Location object representing the location of the value in the source.
    attr_reader value_loc: Location

    # Create a new magic comment object with the given key and value locations.
    # --
    # : (Location key_loc, Location value_loc) -> void
    def initialize: (Location key_loc, Location value_loc) -> void

    # Returns the key of the magic comment by slicing it from the source code.
    # --
    # : () -> String
    def key: () -> String

    # Returns the value of the magic comment by slicing it from the source code.
    # --
    # : () -> String
    def value: () -> String

    # Implement the hash pattern matching interface for MagicComment.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # Returns a string representation of this magic comment.
    # --
    # : () -> String
    def inspect: () -> String
  end

  # This represents an error that was encountered during parsing.
  class ParseError
    # The type of error. This is an _internal_ symbol that is used for
    # communicating with translation layers. It is not meant to be public API.
    attr_reader type: Symbol

    # The message associated with this error.
    attr_reader message: String

    # A Location object representing the location of this error in the source.
    attr_reader location: Location

    # The level of this error.
    attr_reader level: Symbol

    # Create a new error object with the given message and location.
    # --
    # : (Symbol type, String message, Location location, Symbol level) -> void
    def initialize: (Symbol type, String message, Location location, Symbol level) -> void

    # Implement the hash pattern matching interface for ParseError.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # Returns a string representation of this error.
    # --
    # : () -> String
    def inspect: () -> String
  end

  # This represents a warning that was encountered during parsing.
  class ParseWarning
    # The type of warning. This is an _internal_ symbol that is used for
    # communicating with translation layers. It is not meant to be public API.
    attr_reader type: Symbol

    # The message associated with this warning.
    attr_reader message: String

    # A Location object representing the location of this warning in the source.
    attr_reader location: Location

    # The level of this warning.
    attr_reader level: Symbol

    # Create a new warning object with the given message and location.
    # --
    # : (Symbol type, String message, Location location, Symbol level) -> void
    def initialize: (Symbol type, String message, Location location, Symbol level) -> void

    # Implement the hash pattern matching interface for ParseWarning.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # Returns a string representation of this warning.
    # --
    # : () -> String
    def inspect: () -> String
  end

  # This represents the result of a call to Prism.parse or Prism.parse_file.
  # It contains the requested structure, any comments that were encounters,
  # and any errors that were encountered.
  class Result
    # The list of comments that were encountered during parsing.
    attr_reader comments: Array[Comment]

    # The list of magic comments that were encountered during parsing.
    attr_reader magic_comments: Array[MagicComment]

    # An optional location that represents the location of the __END__ marker
    # and the rest of the content of the file. This content is loaded into the
    # DATA constant when the file being parsed is the main file being executed.
    attr_reader data_loc: Location?

    # The list of errors that were generated during parsing.
    attr_reader errors: Array[ParseError]

    # The list of warnings that were generated during parsing.
    attr_reader warnings: Array[ParseWarning]

    # A Source instance that represents the source code that was parsed.
    attr_reader source: Source

    # Create a new result object with the given values.
    # --
    # : (Array[Comment] comments, Array[MagicComment] magic_comments, Location? data_loc, Array[ParseError] errors, Array[ParseWarning] warnings, Source source) -> void
    def initialize: (Array[Comment] comments, Array[MagicComment] magic_comments, Location? data_loc, Array[ParseError] errors, Array[ParseWarning] warnings, Source source) -> void

    # Implement the hash pattern matching interface for Result.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # Returns the encoding of the source code that was parsed.
    # --
    # : () -> Encoding
    def encoding: () -> Encoding

    # Returns true if there were no errors during parsing and false if there
    # were.
    # --
    # : () -> bool
    def success?: () -> bool

    # Returns true if there were errors during parsing and false if there were
    # not.
    # --
    # : () -> bool
    def failure?: () -> bool

    # Create a code units cache for the given encoding.
    # --
    # : (Encoding encoding) -> _CodeUnitsCache
    def code_units_cache: (Encoding encoding) -> _CodeUnitsCache
  end

  # This is a result specific to the `parse` and `parse_file` methods.
  class ParseResult < Result
    # The syntax tree that was parsed from the source code.
    attr_reader value: ProgramNode

    # Create a new parse result object with the given values.
    # --
    # : (ProgramNode value, Array[Comment] comments, Array[MagicComment] magic_comments, Location? data_loc, Array[ParseError] errors, Array[ParseWarning] warnings, Source source) -> void
    def initialize: (ProgramNode value, Array[Comment] comments, Array[MagicComment] magic_comments, Location? data_loc, Array[ParseError] errors, Array[ParseWarning] warnings, Source source) -> void

    # Implement the hash pattern matching interface for ParseResult.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # Attach the list of comments to their respective locations in the tree.
    # --
    # : () -> void
    def attach_comments!: () -> void

    # Walk the tree and mark nodes that are on a new line, loosely emulating
    # the behavior of CRuby's `:line` tracepoint event.
    # --
    # : () -> void
    def mark_newlines!: () -> void

    # Returns a string representation of the syntax tree with the errors
    # displayed inline.
    # --
    # : () -> String
    def errors_format: () -> String
  end

  # This is a result specific to the `lex` and `lex_file` methods.
  class LexResult < Result
    # The list of tokens that were parsed from the source code.
    attr_reader value: Array[[ Token, Integer ]]

    # Create a new lex result object with the given values.
    # --
    # : (Array[[Token, Integer]] value, Array[Comment] comments, Array[MagicComment] magic_comments, Location? data_loc, Array[ParseError] errors, Array[ParseWarning] warnings, Source source) -> void
    def initialize: (Array[[ Token, Integer ]] value, Array[Comment] comments, Array[MagicComment] magic_comments, Location? data_loc, Array[ParseError] errors, Array[ParseWarning] warnings, Source source) -> void

    # Implement the hash pattern matching interface for LexResult.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]
  end

  # This is a result specific to the `parse_lex` and `parse_lex_file` methods.
  class ParseLexResult < Result
    # A tuple of the syntax tree and the list of tokens that were parsed from
    # the source code.
    attr_reader value: [ ProgramNode, Array[[ Token, Integer ]] ]

    # Create a new parse lex result object with the given values.
    # --
    # : ([ProgramNode, Array[[Token, Integer]]] value, Array[Comment] comments, Array[MagicComment] magic_comments, Location? data_loc, Array[ParseError] errors, Array[ParseWarning] warnings, Source source) -> void
    def initialize: ([ ProgramNode, Array[[ Token, Integer ]] ] value, Array[Comment] comments, Array[MagicComment] magic_comments, Location? data_loc, Array[ParseError] errors, Array[ParseWarning] warnings, Source source) -> void

    # Implement the hash pattern matching interface for ParseLexResult.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]
  end

  # This represents a token from the Ruby source.
  class Token
    # The Source object that represents the source this token came from.
    attr_reader source: Source

    # The type of token that this token is.
    attr_reader type: Symbol

    # A byteslice of the source that this token represents.
    attr_reader value: String

    @location: Location | Integer

    # Create a new token object with the given type, value, and location.
    # --
    # : (Source source, Symbol type, String value, Location | Integer location) -> void
    def initialize: (Source source, Symbol type, String value, Location | Integer location) -> void

    # Implement the hash pattern matching interface for Token.
    # --
    # : (Array[Symbol]? keys) -> Hash[Symbol, untyped]
    def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]

    # A Location object representing the location of this token in the source.
    # --
    # : () -> Location
    def location: () -> Location

    # Implement the pretty print interface for Token.
    # --
    # : (PP q) -> void
    def pretty_print: (PP q) -> void

    # Returns true if the given other token is equal to this token.
    # --
    # : (untyped other) -> bool
    def ==: (untyped other) -> bool

    # Returns a string representation of this token.
    # --
    # : () -> String
    def inspect: () -> String

    # Freeze this object and the objects it contains.
    # --
    # : () -> void
    def deep_freeze: () -> void
  end

  # This object is passed to the various Prism.* methods that accept the
  # `scopes` option as an element of the list. It defines both the local
  # variables visible at that scope as well as the forwarding parameters
  # available at that scope.
  class Scope
    # The list of local variables that are defined in this scope. This should be
    # defined as an array of symbols.
    attr_reader locals: Array[Symbol]

    # The list of local variables that are forwarded to the next scope. This
    # should by defined as an array of symbols containing the specific values of
    # :*, :**, :&, or :"...".
    attr_reader forwarding: Array[Symbol]

    # Create a new scope object with the given locals and forwarding.
    # --
    # : (Array[Symbol] locals, Array[Symbol] forwarding) -> void
    def initialize: (Array[Symbol] locals, Array[Symbol] forwarding) -> void
  end

  # Create a new scope with the given locals and forwarding options that is
  # suitable for passing into one of the Prism.* methods that accepts the
  # `scopes` option.
  # --
  # : (?locals: Array[Symbol], ?forwarding: Array[Symbol]) -> Scope
  def self.scope: (?locals: Array[Symbol], ?forwarding: Array[Symbol]) -> Scope
end
