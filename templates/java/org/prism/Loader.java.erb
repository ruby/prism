<%- string_type = Prism::JAVA_STRING_TYPE -%>
package org.prism;

import java.lang.Short;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Locale;

// GENERATED BY <%= File.basename(__FILE__) %>
// @formatter:off
public class Loader {

    public static ParseResult load(byte[] serialized, Nodes.Source source) {
        return new Loader(serialized, source).load();
    }

    // Overridable methods

    public Charset getEncodingCharset(String encodingName) {
        encodingName = encodingName.toLowerCase(Locale.ROOT);
        if (encodingName.equals("ascii-8bit")) {
            return StandardCharsets.US_ASCII;
        }
        return Charset.forName(encodingName);
    }

    public <%= string_type %> bytesToName(byte[] bytes) {
        <%- if string_type == "String" -%>
        return new String(bytes, encodingCharset).intern();
        <%- else -%>
        return null; // Must be implemented by subclassing Loader
        <%- end -%>
    }

    private static final class ConstantPool {

        private final Loader loader;
        private final byte[] source;
        private final int bufferOffset;
        private final <%= string_type %>[] cache;

        ConstantPool(Loader loader, byte[] source, int bufferOffset, int length) {
            this.loader = loader;
            this.source = source;
            this.bufferOffset = bufferOffset;
            cache = new <%= string_type %>[length];
        }

        <%= string_type %> get(ByteBuffer buffer, int oneBasedIndex) {
            int index = oneBasedIndex - 1;
            <%= string_type %> constant = cache[index];

            if (constant == null) {
                int offset = bufferOffset + index * 8;
                int start = buffer.getInt(offset);
                int length = buffer.getInt(offset + 4);

                byte[] bytes = new byte[length];

                if (Integer.compareUnsigned(start, 0x7FFFFFFF) <= 0) {
                    System.arraycopy(source, start, bytes, 0, length);
                } else {
                    int position = buffer.position();
                    buffer.position(start & 0x7FFFFFFF);
                    buffer.get(bytes, 0, length);
                    buffer.position(position);
                }

                constant = loader.bytesToName(bytes);
                cache[index] = constant;
            }

            return constant;
        }

    }

    private final ByteBuffer buffer;
    private final Nodes.Source source;
    protected String encodingName;
    <%- if string_type == "String" -%>
    private Charset encodingCharset;
    <%- end -%>
    private ConstantPool constantPool;

    protected Loader(byte[] serialized, Nodes.Source source) {
        this.buffer = ByteBuffer.wrap(serialized).order(ByteOrder.nativeOrder());
        this.source = source;
    }

    protected ParseResult load() {
        expect((byte) 'P', "incorrect prism header");
        expect((byte) 'R', "incorrect prism header");
        expect((byte) 'I', "incorrect prism header");
        expect((byte) 'S', "incorrect prism header");
        expect((byte) 'M', "incorrect prism header");

        expect((byte) 0, "prism version does not match");
        expect((byte) 17, "prism version does not match");
        expect((byte) 1, "prism version does not match");

        expect((byte) 1, "Loader.java requires no location fields in the serialized output");

        // This loads the name of the encoding.
        int encodingLength = loadVarInt();
        byte[] encodingNameBytes = new byte[encodingLength];
        buffer.get(encodingNameBytes);
        this.encodingName = new String(encodingNameBytes, StandardCharsets.US_ASCII);
        <%- if string_type == "String" -%>
        this.encodingCharset = getEncodingCharset(this.encodingName);
        <%- end -%>

        source.setStartLine(loadVarInt());

        ParseResult.MagicComment[] magicComments = loadMagicComments();
        ParseResult.Error[] errors = loadSyntaxErrors();
        ParseResult.Warning[] warnings = loadWarnings();

        int constantPoolBufferOffset = buffer.getInt();
        int constantPoolLength = loadVarInt();
        this.constantPool = new ConstantPool(this, source.bytes, constantPoolBufferOffset, constantPoolLength);

        Nodes.Node node = loadNode();

        int left = constantPoolBufferOffset - buffer.position();
        if (left != 0) {
            throw new Error("Expected to consume all bytes while deserializing but there were " + left + " bytes left");
        }

        boolean[] newlineMarked = new boolean[1 + source.getLineCount()];
        MarkNewlinesVisitor visitor = new MarkNewlinesVisitor(source, newlineMarked);
        node.accept(visitor);

        return new ParseResult(node, magicComments, errors, warnings);
    }

    private byte[] loadEmbeddedString() {
        int length = loadVarInt();
        byte[] bytes = new byte[length];
        buffer.get(bytes);
        return bytes;
    }

    private byte[] loadString() {
        switch (buffer.get()) {
            case 1:
                int start = loadVarInt();
                int length = loadVarInt();
                byte[] bytes = new byte[length];
                System.arraycopy(source.bytes, start, bytes, 0, length);
                return bytes;
            case 2:
                return loadEmbeddedString();
            default:
                throw new Error("Expected 0 or 1 but was " + buffer.get());
        }
    }

    private ParseResult.MagicComment[] loadMagicComments() {
        int count = loadVarInt();
        ParseResult.MagicComment[] magicComments = new ParseResult.MagicComment[count];

        for (int i = 0; i < count; i++) {
            Nodes.Location keyLocation = loadLocation();
            Nodes.Location valueLocation = loadLocation();

            ParseResult.MagicComment magicComment = new ParseResult.MagicComment(keyLocation, valueLocation);
            magicComments[i] = magicComment;
        }

        return magicComments;
    }

    private ParseResult.Error[] loadSyntaxErrors() {
        int count = loadVarInt();
        ParseResult.Error[] errors = new ParseResult.Error[count];

        // error messages only contain ASCII characters
        for (int i = 0; i < count; i++) {
            byte[] bytes = loadEmbeddedString();
            String message = new String(bytes, StandardCharsets.US_ASCII);
            Nodes.Location location = loadLocation();

            ParseResult.Error error = new ParseResult.Error(message, location);
            errors[i] = error;
        }

        return errors;
    }

    private ParseResult.Warning[] loadWarnings() {
        int count = loadVarInt();
        ParseResult.Warning[] warnings = new ParseResult.Warning[count];

        // warning messages only contain ASCII characters
        for (int i = 0; i < count; i++) {
            byte[] bytes = loadEmbeddedString();
            String message = new String(bytes, StandardCharsets.US_ASCII);
            Nodes.Location location = loadLocation();

            ParseResult.Warning warning = new ParseResult.Warning(message, location);
            warnings[i] = warning;
        }

        return warnings;
    }

    private Nodes.Node loadOptionalNode() {
        if (buffer.get(buffer.position()) != 0) {
            return loadNode();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private <%= string_type %> loadConstant() {
        return constantPool.get(buffer, loadVarInt());
    }

    private <%= string_type %> loadOptionalConstant() {
        if (buffer.get(buffer.position()) != 0) {
            return loadConstant();
        } else {
            buffer.position(buffer.position() + 1); // continue after the 0 byte
            return null;
        }
    }

    private <%= string_type %>[] loadConstants() {
        int length = loadVarInt();
        if (length == 0) {
            return Nodes.EMPTY_STRING_ARRAY;
        }
        <%= string_type %>[] constants = new <%= string_type %>[length];
        for (int i = 0; i < length; i++) {
            constants[i] = constantPool.get(buffer, loadVarInt());
        }
        return constants;
    }

    private Nodes.Node[] loadNodes() {
        int length = loadVarInt();
        if (length == 0) {
            return Nodes.Node.EMPTY_ARRAY;
        }
        Nodes.Node[] nodes = new Nodes.Node[length];
        for (int i = 0; i < length; i++) {
            nodes[i] = loadNode();
        }
        return nodes;
    }

    private Nodes.Location loadLocation() {
        return new Nodes.Location(loadVarInt(), loadVarInt());
    }

    private Nodes.Location loadOptionalLocation() {
        if (buffer.get() != 0) {
            return loadLocation();
        } else {
            return null;
        }
    }

    // From https://github.com/protocolbuffers/protobuf/blob/v23.1/java/core/src/main/java/com/google/protobuf/BinaryReader.java#L1507
    private int loadVarInt() {
        int x;
        if ((x = buffer.get()) >= 0) {
            return x;
        } else if ((x ^= (buffer.get() << 7)) < 0) {
            x ^= (~0 << 7);
        } else if ((x ^= (buffer.get() << 14)) >= 0) {
            x ^= (~0 << 7) ^ (~0 << 14);
        } else if ((x ^= (buffer.get() << 21)) < 0) {
            x ^= (~0 << 7) ^ (~0 << 14) ^ (~0 << 21);
        } else {
            x ^= buffer.get() << 28;
            x ^= (~0 << 7) ^ (~0 << 14) ^ (~0 << 21) ^ (~0 << 28);
        }
        return x;
    }

    private short loadFlags() {
        int flags = loadVarInt();
        assert flags >= 0 && flags <= Short.MAX_VALUE;
        return (short) flags;
    }

    private Nodes.Node loadNode() {
        int type = buffer.get() & 0xFF;
        int startOffset = loadVarInt();
        int length = loadVarInt();

        switch (type) {
            <%- nodes.each_with_index do |node, index| -%>
            case <%= index + 1 %>:
            <%-
            params = node.needs_serialized_length? ? ["buffer.getInt()"] : []
            params.concat node.semantic_fields.map { |field|
              case field
              when Prism::NodeField then "#{field.java_cast}loadNode()"
              when Prism::OptionalNodeField then "#{field.java_cast}loadOptionalNode()"
              when Prism::StringField then "loadString()"
              when Prism::NodeListField then "loadNodes()"
              when Prism::ConstantField then "loadConstant()"
              when Prism::OptionalConstantField then "loadOptionalConstant()"
              when Prism::ConstantListField then "loadConstants()"
              when Prism::LocationField then "loadLocation()"
              when Prism::OptionalLocationField then "loadOptionalLocation()"
              when Prism::UInt32Field then "loadVarInt()"
              when Prism::FlagsField then "loadFlags()"
              else raise
              end
            }
            params.concat ["startOffset", "length"]
            -%>
                return new Nodes.<%= node.name %>(<%= params.join(", ") -%>);
            <%- end -%>
            default:
                throw new Error("Unknown node type: " + type);
        }
    }

    private void expect(byte value, String error) {
        byte b = buffer.get();
        if (b != value) {
            throw new Error("Deserialization error: " + error + " (expected " + value + " but was " + b + " at position " + buffer.position() + ")");
        }
    }

}
// @formatter:on
