#ifndef YARP_AST_H
#define YARP_AST_H

#include "yarp/defines.h"
#include "yarp/util/yp_constant_pool.h"
#include "yarp/util/yp_string.h"

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

// This enum represents every type of token in the Ruby source.
typedef enum yp_token_type {
<%- tokens.each do |token| -%>
    <%= token.declaration %>
<%- end -%>
    YP_TOKEN_MAXIMUM, // the maximum token value
} yp_token_type_t;

// This struct represents a token in the Ruby source. We use it to track both
// type and location information.
typedef struct {
    yp_token_type_t type;
    const char *start;
    const char *end;
} yp_token_t;

// This represents a range of bytes in the source string to which a node or
// token corresponds.
typedef struct {
    const char *start;
    const char *end;
} yp_location_t;

typedef struct {
    yp_location_t *locations;
    size_t size;
    size_t capacity;
} yp_location_list_t;

struct yp_node;

typedef struct yp_node_list {
    struct yp_node **nodes;
    size_t size;
    size_t capacity;
} yp_node_list_t;

typedef enum {
<%- nodes.each_with_index do |node, index| -%>
    <%= node.type %> = <%= index + 1 %>,
<%- end -%>
} yp_node_type_t;

// We store the node type enum in every node in the tree. We don't have nearly
// as many node types as we do bits in an enum, so we're going to use the top
// half of the enum to store flags about the node.
#define YP_NODE_FLAGS_SHIFT (sizeof(yp_node_type_t) * 8 / 2)
#define YP_NODE_FLAG_NEWLINE (1U << YP_NODE_FLAGS_SHIFT)

// For easy access, we define some macros that manipulate only the bottom half
// of the node type enum.
static const unsigned int YP_NODE_TYPE_MASK = ((1 << (sizeof(yp_node_type_t) * 8 / 2)) - 1);
#define YP_NODE_TYPE(node) ((node)->type & YP_NODE_TYPE_MASK)
#define YP_NODE_TYPE_P(node, type) (YP_NODE_TYPE(node) == (type))

// This is the overall tagged union representing a node in the syntax tree.
typedef struct yp_node {
    // This represents the type of the node. It somewhat maps to the nodes that
    // existed in the original grammar and ripper, but it's not a 1:1 mapping.
    yp_node_type_t type;

    // This is the location of the node in the source. It's a range of bytes
    // containing a start and an end.
    yp_location_t location;
} yp_node_t;
<%- nodes.each do |node| -%>

// <%= node.name %>
typedef struct yp_<%= node.human %> {
    yp_node_t base;
<%- node.params.each do |param| -%>
    <%= case param
    in NodeParam | OptionalNodeParam then "struct #{param.c_type} *#{param.name}"
    in NodeListParam then "struct yp_node_list #{param.name}"
    in LocationListParam then "yp_location_list_t #{param.name}"
    in ConstantParam then "yp_constant_id_t #{param.name}"
    in ConstantListParam then "yp_constant_id_list_t #{param.name}"
    in StringParam then "yp_string_t #{param.name}"
    in LocationParam | OptionalLocationParam then "yp_location_t #{param.name}"
    in UInt32Param then "uint32_t #{param.name}"
    end
    %>;
<%- end -%>
} yp_<%= node.human %>_t;
<%- end -%>
<%- flags.each do |flag| -%>

// <%= flag.name %>
typedef enum {
    <%- flag.values.each_with_index do |value, index| -%>
    YP_<%= flag.human.upcase %>_<%= value.name %> = 1 << <%= index %>,
    <%- end -%>
} yp_<%= flag.human %>_t;
<%- end -%>

#endif // YARP_AST_H
