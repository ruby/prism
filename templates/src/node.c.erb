#line <%= __LINE__ + 1 %> "<%= File.basename(__FILE__) %>"
#include "yarp/node.h"

// Append a token to the given list.
void
yp_location_list_append(yp_location_list_t *list, const yp_token_t *token) {
    if (list->size == list->capacity) {
        size_t next_capacity = list->capacity == 0 ? 2 : list->capacity * 2;
        yp_location_t *next_locations = (yp_location_t *) realloc(list->locations, sizeof(yp_location_t) * next_capacity);

        if (next_locations == NULL) return;
        list->capacity = next_capacity;
        list->locations = next_locations;
    }

    list->locations[list->size++] = (yp_location_t) { .start = token->start, .end = token->end };
}

// Free the memory associated with the token list.
static void
yp_location_list_free(yp_location_list_t *list) {
    if (list->locations != NULL) {
        free(list->locations);
    }
}

// Append a new node onto the end of the node list.
void
yp_node_list_append(yp_node_list_t *list, yp_node_t *node) {
    if (list->size == list->capacity) {
        size_t next_capacity = list->capacity == 0 ? 4 : list->capacity * 2;
        yp_node_t **next_nodes = (yp_node_t **) realloc(list->nodes, sizeof(yp_node_t *) * next_capacity);

        if (next_nodes == NULL) return;
        list->capacity = next_capacity;
        list->nodes = next_nodes;
    }
    list->nodes[list->size++] = node;
}

YP_EXPORTED_FUNCTION void
yp_node_destroy(yp_parser_t *parser, yp_node_t *node);

// Deallocate the inner memory of a list of nodes. The parser argument is not
// used, but is here for the future possibility of pre-allocating memory pools.
static void
yp_node_list_free(yp_parser_t *parser, yp_node_list_t *list) {
    if (list->capacity > 0) {
        for (size_t index = 0; index < list->size; index++) {
            yp_node_destroy(parser, list->nodes[index]);
        }
        free(list->nodes);
    }
}

// Deallocate the space for a yp_node_t. Similarly to yp_node_alloc, we're not
// using the parser argument, but it's there to allow for the future possibility
// of pre-allocating larger memory pools.
YP_EXPORTED_FUNCTION void
yp_node_destroy(yp_parser_t *parser, yp_node_t *node) {
    switch (node->type) {
        <%- nodes.each do |node| -%>
#line <%= __LINE__ + 1 %> "<%= File.basename(__FILE__) %>"
        case <%= node.type %>:
            <%- node.params.each do |param| -%>
            <%- case param -%>
            <%- when LocationParam, OptionalLocationParam, UInt32Param, ConstantParam -%>
            <%- when NodeParam -%>
            yp_node_destroy(parser, (yp_node_t *)((yp_<%= node.human %>_t *)node)-><%= param.name %>);
            <%- when OptionalNodeParam -%>
            if (((yp_<%= node.human %>_t *)node)-><%= param.name %> != NULL) {
                yp_node_destroy(parser, (yp_node_t *)((yp_<%= node.human %>_t *)node)-><%= param.name %>);
            }
            <%- when StringParam -%>
            yp_string_free(&((yp_<%= node.human %>_t *)node)-><%= param.name %>);
            <%- when NodeListParam -%>
            yp_node_list_free(parser, &((yp_<%= node.human %>_t *)node)-><%= param.name %>);
            <%- when LocationListParam -%>
            yp_location_list_free(&((yp_<%= node.human %>_t *)node)-><%= param.name %>);
            <%- when ConstantListParam -%>
            yp_constant_id_list_free(&((yp_<%= node.human %>_t *)node)-><%= param.name %>);
            <%- else -%>
            <%- raise -%>
            <%- end -%>
            <%- end -%>
            break;
        <%- end -%>
#line <%= __LINE__ + 1 %> "<%= File.basename(__FILE__) %>"
        default:
            assert(false && "unreachable");
            break;
    }
    free(node);
}
